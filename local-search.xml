<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>可信计算</title>
    <link href="/trusted-computing01.html"/>
    <url>/trusted-computing01.html</url>
    
    <content type="html"><![CDATA[<p>可信计算是什么？基础什么的？</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">:</span> <span class="hljs-string">/posts/hexo-permalinks.html</span> <span class="hljs-comment"># 举个例子</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/os-01.html"/>
    <url>/os-01.html</url>
    
    <content type="html"><![CDATA[<p>halo</p><p><img src="/os-01/image-20240414163759654.png"></p><p><img src="/os-01/image-20240415124229147.png"></p><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>懒加载又称延迟加载。开启后，当图片或评论插件滚动到可见范围内才会加载，可以大幅提高打开网页的速度。</p><p>该功能默认开启，可以在<strong>主题配置</strong>中修改参数：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">lazyload:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">loading_img:</span> <span class="hljs-string">/img/loading.gif</span><br>  <span class="hljs-attr">onlypost:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">offset_factor:</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><code>loading_img</code>: 指定加载时的占位图片</p><p><code>onlypost</code>: 为 true 时，懒加载仅在文章页生效，如果自定义页面需要使用，可以在 <a href="https://hexo.io/zh-cn/docs/front-matter">front-matter (opens new window)</a>里指定 <code>lazyload: true</code></p><p><code>offset_factor</code>: 触发加载的偏移倍数，基数是视窗高度（即提前 N 屏高度触发加载），可根据部署环境的请求速度调节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">code:<br>  copy_btn: <span class="hljs-literal">true</span><br>  highlight:<br>    enable: <span class="hljs-literal">true</span><br>    line_number: <span class="hljs-literal">true</span><br>    lib: <span class="hljs-string">&quot;highlightjs&quot;</span><br>    highlightjs:<br>      style: <span class="hljs-string">&#x27;Github Gist&#x27;</span><br>      bg_color: <span class="hljs-literal">false</span><br>    prismjs:<br>      style: <span class="hljs-string">&quot;default&quot;</span><br>      preprocess: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
      <category>PlayStation</category>
      
      <category>Games</category>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PS3</tag>
      
      <tag>Games</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/helloworld.html"/>
    <url>/helloworld.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Uubuntu 云镜像重置默认密码</title>
    <link href="/051.html"/>
    <url>/051.html</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>ubuntu的云镜像，默认是没有提供用户名密码的，当我们直接启动时，就无法登陆进去，真的是难受坏了。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>通过重置root密码来设置一个初始化密码即可</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>以ubuntu20.04版本为例</p><p>下载地址：<a href="http://cloud-images-archive.ubuntu.com/releases/focal/release-20211129/">Ubuntu 20.04 LTS （Focal Fossa） [20211129]</a></p><p><img src="/wp-content/uploads/2023/12/image-57.png"></p><p>②：重置密码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yum</span> install -y libguestfs-tools<br><span class="hljs-attribute">virt</span>-customize -a ubuntu-<span class="hljs-number">20</span>.<span class="hljs-number">04</span>-server-cloudimg-arm64.img --root-password password:<span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>登陆后，密码就修改好了。</p><p><img src="/wp-content/uploads/2023/12/image-58.png"></p>]]></content>
    
    
    <categories>
      
      <category>OpenStack</category>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
      <tag>qemu</tag>
      
      <tag>openstack</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一步一图带你深入理解 Linux 虚拟内存管理（转）</title>
    <link href="/023.html"/>
    <url>/023.html</url>
    
    <content type="html"><![CDATA[<p>前言：看到有个大佬写的微信文章，写的非常好，这里分享一下大佬文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328&chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298#rd">一步一图带你深入理解 Linux 虚拟内存管理 (qq.com)</a>：，公众号： bin的技术小屋</p><p>下面是原文：</p><p><img src="/wp-content/uploads/2023/12/image-44-1024x1008.png"></p><h2 id="1-到底什么是虚拟内存地址"><a href="#1-到底什么是虚拟内存地址" class="headerlink" title="1. 到底什么是虚拟内存地址"></a><strong>1. 到底什么是虚拟内存地址</strong></h2><p>首先人们提出地址这个概念的目的就是用来方便定位现实世界中某一个具体事物的真实地理位置，它是一种用于定位的概念模型。</p><p>举一个生活中的例子，比如大家在日常生活中给亲朋好友邮寄一些本地特产时，都会填写收件人地址以及寄件人地址。以及在日常网上购物时，都会在相应电商 APP 中填写自己的收获地址。</p><p><img src="/wp-content/uploads/2023/12/image-46-1024x373.png"></p><p>随后快递小哥就会根据我们填写的收货地址找到我们的真实住所，将我们网购的商品送达到我们的手里。</p><p>收货地址是用来定位我们在现实世界中真实住所地理位置的，而现实世界中我们所在的城市，街道，小区，房屋都是一砖一瓦，一草一木真实存在的。但收货地址这个概念模型在现实世界中并不真实存在，它只是人们提出的一个虚拟概念，通过收货地址这个虚拟概念将它和现实世界真实存在的城市，小区，街道的地理位置一一映射起来，这样我们就可以通过这个虚拟概念来找到现实世界中的具体地理位置。</p><p>综上所述，收货地址是一个虚拟地址，它是人为定义的，而我们的城市，小区，街道是真实存在的，他们的地理位置就是物理地址。</p><p><img src="/wp-content/uploads/2023/12/image-45.png"></p><p>比如现在的广东省深圳市在过去叫宝安县，河北省的石家庄过去叫常山，安徽省的合肥过去叫泸州。不管是常山也好，石家庄也好，又或是合肥也好，泸州也罢，这些都是人为定义的名字而已，但是地方还是那个地方，它所在的地理位置是不变的。也就说虚拟地址可以人为的变来变去，但是物理地址永远是不变的。</p><p>现在让我们把视角在切换到计算机的世界，在计算机的世界里内存地址用来定义数据在内存中的存储位置的，内存地址也分为虚拟地址和物理地址。而虚拟地址也是人为设计的一个概念，类比我们现实世界中的收货地址，而物理地址则是数据在物理内存中的真实存储位置，类比现实世界中的城市，街道，小区的真实地理位置。</p><p>说了这么多，那么到底虚拟内存地址长什么样子呢？</p><p>我们还是以日常生活中的收货地址为例做出类比，我们都很熟悉收货地址的格式：xx省xx市xx区xx街道xx小区xx室，它是按照地区层次递进的。同样，在计算机世界中的虚拟内存地址也有这样的递进关系。</p><p>这里我们以 Intel Core i7 处理器为例，64 位虚拟地址的格式为：全局页目录项（9位）+ 上层页目录项（9位）+ 中间页目录项（9位）+ 页表项（9位）+ 页内偏移（12位）。共 48 位组成的虚拟内存地址。</p><p><img src="/wp-content/uploads/2023/12/image-45-1-1024x287.jpg"></p><p>虚拟内存地址中的全局页目录项就类比我们日常生活中收获地址里的省，上层页目录项就类比市，中间层页目录项类比区县，页表项类比街道小区，页内偏移类比我们所在的楼栋和几层几号。</p><blockquote><p>这里大家只需要大体明白虚拟内存地址到底长什么样子，它的格式是什么，能够和日常生活中的收货地址对比理解起来就可以了，至于页目录项，页表项以及页内偏移这些计算机世界中的概念，大家暂时先不用管，后续文章中笔者会慢慢给大家解释清楚。</p></blockquote><p>32 位虚拟地址的格式为：页目录项（10位）+ 页表项（10位） + 页内偏移（12位）。共 32 位组成的虚拟内存地址。</p><p><img src="/wp-content/uploads/2023/12/image-45-1024x358.jpg"></p><blockquote><p>进程虚拟内存空间中的每一个字节都有与其对应的虚拟内存地址，一个虚拟内存地址表示进程虚拟内存空间中的一个特定的字节。</p></blockquote><h2 id="2-为什么要使用虚拟地址访问内存"><a href="#2-为什么要使用虚拟地址访问内存" class="headerlink" title="2. 为什么要使用虚拟地址访问内存"></a>2. 为什么要使用虚拟地址访问内存</h2><p>经过第一小节的介绍，我们现在明白了计算机世界中的虚拟内存地址的含义及其展现形式。那么大家可能会问了，既然物理内存地址可以直接定位到数据在内存中的存储位置，那为什么我们不直接使用物理内存地址去访问内存而是选择用虚拟内存地址去访问内存呢？</p><p>在回答大家的这个疑问之前，让我们先来看下，如果在程序中直接使用物理内存地址会发生什么情况？</p><p>假设现在没有虚拟内存地址，我们在程序中对内存的操作全都都是使用物理内存地址，在这种情况下，程序员就需要精确的知道每一个变量在内存中的具体位置，我们需要手动对物理内存进行布局，明确哪些数据存储在内存的哪些位置，除此之外我们还需要考虑为每个进程究竟要分配多少内存？内存紧张的时候该怎么办？如何避免进程与进程之间的地址冲突？等等一系列复杂且琐碎的细节。</p><p>如果我们在单进程系统中比如嵌入式设备上开发应用程序，系统中只有一个进程，这单个进程独享所有的物理资源包括内存资源。在这种情况下，上述提到的这些直接使用物理内存的问题可能还好处理一些，但是仍然具有很高的开发门槛。</p><p>然而在现代操作系统中往往支持多个进程，需要处理多进程之间的协同问题，在多进程系统中直接使用物理内存地址操作内存所带来的上述问题就变得非常复杂了。</p><p>这里笔者为大家举一个简单的例子来说明在多进程系统中直接使用物理内存地址的复杂性。</p><p>比如我们现在有这样一个简单的 Java 程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <br>    <span class="hljs-type">string</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>];<br>    ..........<br>&#125;<br></code></pre></td></tr></table></figure><p>在程序代码相同的情况下，我们用这份代码同时启动三个 JVM 进程，我们暂时将进程依次命名为 a , b , c 。</p><p>这三个进程用到的代码是一样的，都是我们提前写好的，可以被多次运行。由于我们是直接操作物理内存地址，假设变量 i 保存在 0x354 这个物理地址上。这三个进程运行起来之后，同时操作这个 0x354 物理地址，这样这个变量 i 的值不就混乱了吗？ 三个进程就会出现变量的地址冲突。</p><p><img src="/wp-content/uploads/2023/12/image-47-1024x376.png"></p><p>所以在直接操作物理内存的情况下，我们需要知道每一个变量的位置都被安排在了哪里，而且还要注意和多个进程同时运行的时候，不能共用同一个地址，否则就会造成地址冲突。</p><p>现实中一个程序会有很多的变量和函数，这样一来我们给它们都需要计算一个合理的位置，还不能与其他进程冲突，这就很复杂了。</p><p>那么我们该如何解决这个问题呢？程序的局部性原理再一次救了我们~~</p><blockquote><p>程序局部性原理表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某块数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。</p></blockquote><p>从程序局部性原理的描述中我们可以得出这样一个结论：进程在运行之后，对于内存的访问不会一下子就要访问全部的内存，相反进程对于内存的访问会表现出明显的倾向性，更加倾向于访问最近访问过的数据以及热点数据附近的数据。</p><p>根据这个结论我们就清楚了，无论一个进程实际可以占用的内存资源有多大，根据程序局部性原理，在某一段时间内，进程真正需要的物理内存其实是很少的一部分，我们只需要为每个进程分配很少的物理内存就可以保证进程的正常执行运转。</p><p>而虚拟内存的引入正是要解决上述的问题，虚拟内存引入之后，进程的视角就会变得非常开阔，每个进程都拥有自己独立的虚拟地址空间，进程与进程之间的虚拟内存地址空间是相互隔离，互不干扰的。每个进程都认为自己独占所有内存空间，自己想干什么就干什么。</p><p><img src="/wp-content/uploads/2023/12/image-47-1-1024x654.jpg"></p><p>系统上还运行了哪些进程和我没有任何关系。这样一来我们就可以将多进程之间协同的相关复杂细节统统交给内核中的内存管理模块来处理，极大地解放了程序员的心智负担。这一切都是因为虚拟内存能够提供内存地址空间的隔离，极大地扩展了可用空间。</p><p><img src="/wp-content/uploads/2023/12/image-47-1024x743.jpg"></p><p>这样进程就以为自己独占了整个内存空间资源，给进程产生了所有内存资源都属于它自己的幻觉，这其实是 CPU 和操作系统使用的一个障眼法罢了，任何一个虚拟内存里所存储的数据，本质上还是保存在真实的物理内存里的。只不过内核帮我们做了虚拟内存到物理内存的这一层映射，将不同进程的虚拟地址和不同内存的物理地址映射起来。</p><p>当 CPU 访问进程的虚拟地址时，经过地址翻译硬件将虚拟地址转换成不同的物理地址，这样不同的进程运行的时候，虽然操作的是同一虚拟地址，但其实背后写入的是不同的物理地址，这样就不会冲突了。</p><h2 id="3-进程虚拟内存空间"><a href="#3-进程虚拟内存空间" class="headerlink" title="3. 进程虚拟内存空间"></a>3. 进程虚拟内存空间</h2><p>上小节中，我们介绍了为了防止多进程运行时造成的内存地址冲突，内核引入了虚拟内存地址，为每个进程提供了一个独立的虚拟内存空间，使得进程以为自己独占全部内存资源。</p><p>那么这个进程独占的虚拟内存空间到底是什么样子呢？在本小节中，笔者就为大家揭开这层神秘的面纱~~~</p><p>在本小节内容开始之前，我们先想象一下，如果我们是内核的设计人员，我们该从哪些方面来规划进程的虚拟内存空间呢？</p><blockquote><p>本小节我们只讨论进程用户态虚拟内存空间的布局，我们先把内核态的虚拟内存空间当做一个黑盒来看待，在后面的小节中笔者再来详细介绍内核态相关内容。</p></blockquote><p>首先我们会想到的是一个进程运行起来是为了执行我们交代给进程的工作，执行这些工作的步骤我们通过程序代码事先编写好，然后编译成二进制文件存放在磁盘中，CPU 会执行二进制文件中的机器码来驱动进程的运行。所以在进程运行之前，这些存放在二进制文件中的机器码需要被加载进内存中，而用于存放这些机器码的虚拟内存空间叫做代码段。</p><p><img src="/wp-content/uploads/2023/12/image-51.png"></p><p>在程序运行起来之后，总要操作变量吧，在程序代码中我们通常会定义大量的全局变量和静态变量，这些全局变量在程序编译之后也会存储在二进制文件中，在程序运行之前，这些全局变量也需要被加载进内存中供程序访问。所以在虚拟内存空间中也需要一段区域来存储这些全局变量。</p><p><img src="/wp-content/uploads/2023/12/image-50.png"></p><p>上面介绍的这些全局变量和静态变量都是在编译期间就确定的，但是我们程序在运行期间往往需要动态的申请内存，所以在虚拟内存空间中也需要一块区域来存放这些动态申请的内存，这块区域就叫做堆。注意这里的堆指的是 OS 堆并不是 JVM 中的堆。</p><p><img src="/wp-content/uploads/2023/12/image-49.png"></p><p>除此之外，我们的程序在运行过程中还需要依赖动态链接库，这些动态链接库以 .so 文件的形式存放在磁盘中，比如 C 程序中的 glibc，里边对系统调用进行了封装。glibc 库里提供的用于动态申请堆内存的 malloc 函数就是对系统调用 sbrk 和 mmap 的封装。这些动态链接库也有自己的对应的代码段，数据段，BSS 段，也需要一起被加载进内存中。</p><p>还有用于内存文件映射的系统调用 mmap，会将文件与内存进行映射，那么映射的这块内存（虚拟内存）也需要在虚拟地址空间中有一块区域存储。</p><p>这些动态链接库中的代码段，数据段，BSS 段，以及通过 mmap 系统调用映射的共享内存区，在虚拟内存空间的存储区域叫做文件映射与匿名映射区。</p><p><img src="/wp-content/uploads/2023/12/image-48.png"></p><p>最后我们在程序运行的时候总该要调用各种函数吧，那么调用函数过程中使用到的局部变量和函数参数也需要一块内存区域来保存。这一块区域在虚拟内存空间中叫做栈。</p><p><img src="/wp-content/uploads/2023/12/image-48.jpg"></p><p>现在进程的虚拟内存空间所包含的主要区域，笔者就为大家介绍完了，我们看到内核根据进程运行的过程中所需要不同种类的数据而为其开辟了对应的地址空间。分别为：</p><ul><li>用于存放进程程序二进制文件中的机器指令的代码段</li><li>用于存放程序二进制文件中定义的全局变量和静态变量的数据段和 BSS 段。</li><li>用于在程序运行过程中动态申请内存的堆。</li><li>用于存放动态链接库以及内存映射区域的文件映射与匿名映射区。</li><li>用于存放函数调用过程中的局部变量和函数参数的栈。</li></ul><p>以上就是我们通过一个程序在运行过程中所需要的数据所规划出的虚拟内存空间的分布，这些只是一个大概的规划，那么在真实的 Linux 系统中，进程的虚拟内存空间的具体规划又是如何的呢？我们接着往下看~~</p><h2 id="4-Linux-进程虚拟内存空间"><a href="#4-Linux-进程虚拟内存空间" class="headerlink" title="4. Linux 进程虚拟内存空间"></a>4. Linux 进程虚拟内存空间</h2><p>在上小节中我们介绍了进程虚拟内存空间中各个内存区域的一个大概分布，在此基础之上，本小节笔者就带大家分别从 32 位 和 64 位机器上看下在 Linux 系统中进程虚拟内存空间的真实分布情况。</p><h3 id="4-1-32-位机器上进程虚拟内存空间分布"><a href="#4-1-32-位机器上进程虚拟内存空间分布" class="headerlink" title="4.1 32 位机器上进程虚拟内存空间分布"></a>4.1 32 位机器上进程虚拟内存空间分布</h3><p>在 32 位机器上，指针的寻址范围为 2^32，所能表达的虚拟内存空间为 4 GB。所以在 32 位机器上进程的虚拟内存地址范围为：0x0000 0000 - 0xFFFF FFFF。</p><p>其中用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000  。</p><p>内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF。</p><p><img src="/wp-content/uploads/2023/12/image-52-3-1024x926.jpg"></p><p>但是用户态虚拟内存空间中的代码段并不是从 0x0000 0000 地址开始的，而是从 0x0804 8000 地址开始。</p><p>0x0000 0000 到 0x0804 8000 这段虚拟内存地址是一段不可访问的保留区，因为在大多数操作系统中，数值比较小的地址通常被认为不是一个合法的地址，这块小地址是不允许访问的。比如在 C 语言中我们通常会将一些无效的指针设置为 NULL，指向这块不允许访问的地址。</p><p>保留区的上边就是代码段和数据段，它们是从程序的二进制文件中直接加载进内存中的，BSS 段中的数据也存在于二进制文件中，因为内核知道这些数据是没有初值的，所以在二进制文件中只会记录 BSS 段的大小，在加载进内存时会生成一段 0 填充的内存空间。</p><p>紧挨着 BSS 段的上边就是我们经常使用到的堆空间，从图中的红色箭头我们可以知道在堆空间中地址的增长方向是从低地址到高地址增长。</p><p>内核中使用 start_brk 标识堆的起始位置，brk 标识堆当前的结束位置。当堆申请新的内存空间时，只需要将 brk 指针增加对应的大小，回收地址时减少对应的大小即可。比如当我们通过 malloc 向内核申请很小的一块内存时（128K 之内），就是通过改变 brk 位置实现的。</p><p>堆空间的上边是一段待分配区域，用于扩展堆空间的使用。接下来就来到了文件映射与匿名映射区域。进程运行时所依赖的动态链接库中的代码段，数据段，BSS 段就加载在这里。还有我们调用 mmap 映射出来的一段虚拟内存空间也保存在这个区域。<strong>注意：在文件映射与匿名映射区的地址增长方向是从高地址向低地址增长</strong>。</p><p>接下来用户态虚拟内存空间的最后一块区域就是栈空间了，在这里会保存函数运行过程所需要的局部变量以及函数参数等函数调用信息。<strong>栈空间中的地址增长方向是从高地址向低地址增长</strong>。每次进程申请新的栈地址时，其地址值是在减少的。</p><p>在内核中使用 start_stack 标识栈的起始位置，RSP 寄存器中保存栈顶指针 stack pointer，RBP 寄存器中保存的是栈基地址。</p><p>在栈空间的下边也有一段待分配区域用于扩展栈空间，在栈空间的上边就是内核空间了，进程虽然可以看到这段内核空间地址，但是就是不能访问。这就好比我们在饭店里虽然可以看到厨房在哪里，但是厨房门上写着 “厨房重地，闲人免进” ，我们就是进不去。</p><p><img src="/wp-content/uploads/2023/12/image-52-2.jpg"></p><h3 id="4-2-64-位机器上进程虚拟内存空间分布"><a href="#4-2-64-位机器上进程虚拟内存空间分布" class="headerlink" title="4.2 64 位机器上进程虚拟内存空间分布"></a>4.2 64 位机器上进程虚拟内存空间分布</h3><p>上小节中介绍的 32 位虚拟内存空间布局和本小节即将要介绍的 64 位虚拟内存空间布局都可以通过 <code>cat /proc/pid/maps</code> 或者 <code>pmap pid</code> 来查看某个进程的实际虚拟内存布局。</p><p>我们知道在 32 位机器上，指针的寻址范围为 2^32，所能表达的虚拟内存空间为 4 GB。</p><p>那么我们理所应当的会认为在 64 位机器上，指针的寻址范围为 2^64，所能表达的虚拟内存空间为 16 EB 。虚拟内存地址范围为：0x0000 0000 0000 0000 0000 - 0xFFFF FFFF FFFF FFFF 。</p><p>好家伙 !!! 16 EB 的内存空间，笔者都没见过这么大的磁盘，在现实情况中根本不会用到这么大范围的内存空间，</p><p>事实上在目前的 64 位系统下只使用了 48 位来描述虚拟内存空间，寻址范围为  2^48 ，所能表达的虚拟内存空间为 256TB。</p><p>其中低 128 T 表示用户态虚拟内存空间，虚拟内存地址范围为：0x0000 0000 0000 0000  - 0x0000 7FFF FFFF F000 。</p><p>高 128 T 表示内核态虚拟内存空间，虚拟内存地址范围为：0xFFFF 8000 0000 0000  - 0xFFFF FFFF FFFF FFFF 。</p><p>这样一来就在用户态虚拟内存空间与内核态虚拟内存空间之间形成了一段 0x0000 7FFF FFFF F000  -  0xFFFF 8000 0000 0000  的地址空洞，我们把这个空洞叫做 canonical address 空洞。</p><p><img src="/wp-content/uploads/2023/12/image-52-1-1024x503.jpg"></p><p>那么这个 canonical address 空洞是如何形成的呢？</p><p>我们都知道在 64 位机器上的指针寻址范围为 2^64，但是在实际使用中我们只使用了其中的低 48 位来表示虚拟内存地址，那么这多出的高 16 位就形成了这个地址空洞。</p><p>大家注意到在低 128T 的用户态地址空间：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF F000 范围中，所以虚拟内存地址的高 16 位全部为 0 。</p><p>如果一个虚拟内存地址的高 16 位全部为 0 ，那么我们就可以直接判断出这是一个用户空间的虚拟内存地址。</p><p>同样的道理，在高 128T 的内核态虚拟内存空间：0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 范围中，所以虚拟内存地址的高 16 位全部为 1 。</p><p>也就是说内核态的虚拟内存地址的高 16 位全部为 1 ，如果一个试图访问内核的虚拟地址的高 16 位不全为 1 ，则可以快速判断这个访问是非法的。</p><p>这个高 16 位的空闲地址被称为 canonical 。如果虚拟内存地址中的高 16 位全部为 0 （表示用户空间虚拟内存地址）或者全部为 1 （表示内核空间虚拟内存地址），这种地址的形式我们叫做 canonical form，对应的地址我们称作 canonical address 。</p><p>那么处于 canonical address 空洞 ：0x0000 7FFF FFFF F000 - 0xFFFF 8000 0000 0000 范围内的地址的高 16 位 不全为 0 也不全为 1 。如果某个虚拟地址落在这段 canonical address 空洞区域中，那就是既不在用户空间，也不在内核空间，肯定是非法访问了。</p><p>未来我们也可以利用这块 canonical address 空洞，来扩展虚拟内存地址的范围，比如扩展到 56 位。</p><p>在我们理解了 canonical address 这个概念之后，我们再来看下 64 位 Linux 系统下的真实虚拟内存空间布局情况：</p><p><img src="/wp-content/uploads/2023/12/image-52-1024x1015.jpg"></p><p>从上图中我们可以看出 64 位系统中的虚拟内存布局和 32 位系统中的虚拟内存布局大体上是差不多的。主要不同的地方有三点：</p><ol><li>就是前边提到的由高 16 位空闲地址造成的  canonical address 空洞。在这段范围内的虚拟内存地址是不合法的，因为它的高 16 位既不全为 0 也不全为 1，不是一个 canonical address，所以称之为 canonical address 空洞。</li><li>在代码段跟数据段的中间还有一段不可以读写的保护段，它的作用是防止程序在读写数据段的时候越界访问到代码段，这个保护段可以让越界访问行为直接崩溃，防止它继续往下运行。</li><li>用户态虚拟内存空间与内核态虚拟内存空间分别占用 128T，其中低128T 分配给用户态虚拟内存空间，高 128T 分配给内核态虚拟内存空间。</li></ol><h2 id="5-进程虚拟内存空间的管理"><a href="#5-进程虚拟内存空间的管理" class="headerlink" title="5. 进程虚拟内存空间的管理"></a>5. 进程虚拟内存空间的管理</h2><p>在上一小节中，笔者为大家介绍了 Linux 操作系统在 32 位机器上和 64 位机器上进程虚拟内存空间的布局分布，我们发现无论是在 32 位机器上还是在 64 位机器上，进程虚拟内存空间的核心区域分布的相对位置是不变的，它们都包含下图所示的这几个核心内存区域。</p><p><img src="/wp-content/uploads/2023/12/image-57-4.jpg"></p><p>唯一不同的是这些核心内存区域在 32 位机器和 64 位机器上的绝对位置分布会有所不同。</p><p>那么在此基础之上，内核如何为进程管理这些虚拟内存区域呢？这将是本小节重点为大家介绍的内容~~</p><p>既然我们要介绍进程的虚拟内存空间管理，那就离不开进程在内核中的描述符 task_struct 结构。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">task_struct</span> &#123;<br>        <span class="hljs-comment">// 进程id</span><br>     pid_t    pid;<br>        <span class="hljs-comment">// 用于标识线程所属的进程 pid</span><br>     pid_t    tgid;<br>        <span class="hljs-comment">// 进程打开的文件信息</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-type">files_struct</span>  *files;<br>        <span class="hljs-comment">// 内存描述符表示进程虚拟地址空间</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-type">mm_struct</span>  *mm;<br><br>        .......... 省略 .......<br>&#125;<br></code></pre></td></tr></table></figure><p>在进程描述符 task_struct 结构中，有一个专门描述进程虚拟地址空间的内存描述符 mm_struct 结构，这个结构体中包含了前边几个小节中介绍的进程虚拟内存空间的全部信息。</p><p>每个进程都有唯一的 mm_struct 结构体，也就是前边提到的每个进程的虚拟地址空间都是独立，互不干扰的。</p><p>当我们调用 fork() 函数创建进程的时候，表示进程地址空间的 mm_struct 结构会随着进程描述符 task_struct 的创建而创建。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lasso">long _do_fork(unsigned long clone_flags,<br>       unsigned long stack_start,<br>       unsigned long stack_size,<br>       int __user *parent_tidptr,<br>       int __user *child_tidptr,<br>       unsigned long tls)<br>&#123;<br>        <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span> 省略 <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br> struct pid *pid;<br> struct task_struct *p;<br><br>        <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span> 省略 <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br>    <span class="hljs-comment">// 为进程创建 task_struct 结构，用父进程的资源填充 task_struct 信息</span><br> p = copy_process(clone_flags, stack_start, stack_size,<br>    child_tidptr, <span class="hljs-built_in">NULL</span>, trace, tls, NUMA_NO_NODE);<br><br>         <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span> 省略 <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br>&#125;<br></code></pre></td></tr></table></figure><p>随后会在 copy_process 函数中创建 task_struct 结构，并拷贝父进程的相关资源到新进程的 task_struct 结构里，其中就包括拷贝父进程的虚拟内存空间 mm_struct 结构。<strong>这里可以看出子进程在新创建出来之后它的虚拟内存空间是和父进程的虚拟内存空间一模一样的，直接拷贝过来</strong>。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs lasso">static __latent_entropy struct task_struct *copy_process(<br>     unsigned long clone_flags,<br>     unsigned long stack_start,<br>     unsigned long stack_size,<br>     int __user *child_tidptr,<br>     struct pid *pid,<br>     int trace,<br>     unsigned long tls,<br>     int node)<br>&#123;<br><br>    struct task_struct *p;<br>    <span class="hljs-comment">// 创建 task_struct 结构</span><br>    p = dup_task_struct(current, node);<br><br>        <span class="hljs-params">...</span><span class="hljs-params">...</span>. 初始化子进程 <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>..<br><br>        <span class="hljs-params">...</span><span class="hljs-params">...</span>. 开始继承拷贝父进程资源  <span class="hljs-params">...</span><span class="hljs-params">...</span>.      <br>    <span class="hljs-comment">// 继承父进程打开的文件描述符</span><br> retval = copy_files(clone_flags, p);<br>    <span class="hljs-comment">// 继承父进程所属的文件系统</span><br> retval = copy_fs(clone_flags, p);<br>    <span class="hljs-comment">// 继承父进程注册的信号以及信号处理函数</span><br> retval = copy_sighand(clone_flags, p);<br> retval = copy_signal(clone_flags, p);<br>    <span class="hljs-comment">// 继承父进程的虚拟内存空间</span><br> retval = copy_mm(clone_flags, p);<br>    <span class="hljs-comment">// 继承父进程的 namespaces</span><br> retval = copy_namespaces(clone_flags, p);<br>    <span class="hljs-comment">// 继承父进程的 IO 信息</span><br> retval = copy_io(clone_flags, p);<br><br>      <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>..省略<span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><br>    <span class="hljs-comment">// 分配 CPU</span><br>    retval = sched_fork(clone_flags, p);<br>    <span class="hljs-comment">// 分配 pid</span><br>    pid = alloc_pid(p-&gt;nsproxy-&gt;pid_ns_for_children);<br><br>.     <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.省略<span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们重点关注 copy_mm 函数，正是在这里完成了子进程虚拟内存空间 mm_struct 结构的的创建以及初始化。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs lasso">static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)<br>&#123;<br> <span class="hljs-comment">// 子进程虚拟内存空间，父进程虚拟内存空间</span><br> struct mm_struct *mm, *oldmm;<br> int retval;<br><br>        <span class="hljs-params">...</span><span class="hljs-params">...</span> 省略 <span class="hljs-params">...</span><span class="hljs-params">...</span><br><br> tsk-&gt;mm = <span class="hljs-built_in">NULL</span>;<br> tsk-&gt;active_mm = <span class="hljs-built_in">NULL</span>;<br>    <span class="hljs-comment">// 获取父进程虚拟内存空间</span><br> oldmm = current-&gt;mm;<br> <span class="hljs-keyword">if</span> (!oldmm)<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-params">...</span><span class="hljs-params">...</span> 省略 <span class="hljs-params">...</span><span class="hljs-params">...</span><br> <span class="hljs-comment">// 通过 vfork 或者 clone 系统调用创建出的子进程（线程）和父进程共享虚拟内存空间</span><br> <span class="hljs-keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;<br>        <span class="hljs-comment">// 增加父进程虚拟地址空间的引用计数</span><br>        mmget(oldmm);<br>        <span class="hljs-comment">// 直接将父进程的虚拟内存空间赋值给子进程（线程）</span><br>        <span class="hljs-comment">// 线程共享其所属进程的虚拟内存空间</span><br>        mm = oldmm;<br>        goto good_mm;<br> &#125;<br><br> retval = <span class="hljs-params">-ENOMEM</span>;<br> <span class="hljs-comment">// 如果是 fork 系统调用创建出的子进程，则将父进程的虚拟内存空间以及相关页表拷贝到子进程中的 mm_struct 结构中。</span><br> mm = dup_mm(tsk);<br> <span class="hljs-keyword">if</span> (!mm)<br>  goto fail_nomem;<br><br>good_mm:<br> <span class="hljs-comment">// 将拷贝出来的父进程虚拟内存空间 mm_struct 赋值给子进程</span><br> tsk-&gt;mm = mm;<br> tsk-&gt;active_mm = mm;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-params">...</span><span class="hljs-params">...</span> 省略 <span class="hljs-params">...</span><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>由于本小节中我们举的示例是通过  fork() 函数创建子进程的情形，所以这里大家先占时忽略 <code>if (clone_flags &amp; CLONE_VM)</code> 这个条件判断逻辑，我们先跳过往后看~~</p><p>copy_mm  函数首先会将父进程的虚拟内存空间 current-&gt;mm 赋值给指针 oldmm。然后通过 dup_mm 函数将父进程的虚拟内存空间以及<strong>相关页表</strong>拷贝到子进程的 mm_struct 结构中。最后将拷贝出来的 mm_struct 赋值给子进程的 task_struct 结构。</p><blockquote><p>通过 fork() 函数创建出的子进程，它的虚拟内存空间以及相关页表相当于父进程虚拟内存空间的一份拷贝，直接从父进程中拷贝到子进程中。</p></blockquote><p>而当我们通过 vfork 或者 clone 系统调用创建出的子进程，首先会设置 CLONE_VM 标识，这样来到 copy_mm 函数中就会进入  <code>if (clone_flags &amp; CLONE_VM)</code>  条件中，在这个分支中会将父进程的虚拟内存空间以及相关页表直接赋值给子进程。这样一来父进程和子进程的虚拟内存空间就变成共享的了。也就是说父子进程之间使用的虚拟内存空间是一样的，并不是一份拷贝。</p><p>子进程共享了父进程的虚拟内存空间，这样子进程就变成了我们熟悉的线程，<strong>是否共享地址空间几乎是进程和线程之间的本质区别。Linux 内核并不区别对待它们，线程对于内核来说仅仅是一个共享特定资源的进程而已</strong>。</p><p>内核线程和用户态线程的区别就是内核线程没有相关的内存描述符 mm_struct ，内核线程对应的 task_struct 结构中的 mm 域指向 Null，所以内核线程之间调度是不涉及地址空间切换的。</p><p>当一个内核线程被调度时，它会发现自己的虚拟地址空间为 Null，虽然它不会访问用户态的内存，但是它会访问内核内存，聪明的内核会将调度之前的上一个用户态进程的虚拟内存空间 mm_struct 直接赋值给内核线程，因为内核线程不会访问用户空间的内存，它仅仅只会访问内核空间的内存，所以直接复用上一个用户态进程的虚拟地址空间就可以避免为内核线程分配 mm_struct 和相关页表的开销，以及避免内核线程之间调度时地址空间的切换开销。</p><blockquote><p>父进程与子进程的区别，进程与线程的区别，以及内核线程与用户态线程的区别其实都是围绕着这个 mm_struct 展开的。</p></blockquote><p>现在我们知道了表示进程虚拟内存空间的 mm_struct 结构是如何被创建出来的相关背景，那么接下来笔者就带大家深入 mm_struct 结构内部，来看一下内核如何通过这么一个 mm_struct 结构体来管理进程的虚拟内存空间的。</p><h3 id="5-1-内核如何划分用户态和内核态虚拟内存空间"><a href="#5-1-内核如何划分用户态和内核态虚拟内存空间" class="headerlink" title="5.1 内核如何划分用户态和内核态虚拟内存空间"></a>5.1 内核如何划分用户态和内核态虚拟内存空间</h3><p>通过 《3. 进程虚拟内存空间》小节的介绍我们知道，进程的虚拟内存空间分为两个部分：一部分是用户态虚拟内存空间，另一部分是内核态虚拟内存空间。</p><p><img src="/wp-content/uploads/2023/12/image-52-4.jpg"></p><p>那么用户态的地址空间和内核态的地址空间在内核中是如何被划分的呢？</p><p>这就用到了进程的内存描述符 mm_struct 结构体中的 task_size 变量，task_size 定义了用户态地址空间与内核态地址空间之间的分界线。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> task_size; <span class="hljs-comment">/* size of task vm space */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过前边小节的内容介绍，我们知道在  32 位系统中用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000 。</p><p>内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF。</p><p><img src="/wp-content/uploads/2023/12/image-52-5-1024x926.jpg"></p><p>32 位系统中用户地址空间和内核地址空间的分界线在 0xC000 000 地址处，那么自然进程的 mm_struct 结构中的 task_size 为 0xC000 000。</p><p>我们来看下内核在 <code>/arch/x86/include/asm/page_32_types.h</code> 文件中关于 TASK_SIZE 的定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * User space process size: 3GB (default).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_SIZE  __PAGE_OFFSET</span><br></code></pre></td></tr></table></figure><p>如下图所示：__PAGE_OFFSET 的值在 32 位系统下为  0xC000 000。</p><p><img src="/wp-content/uploads/2023/12/image-52-1024x637.png"></p><p>而在 64 位系统中，只使用了其中的低 48 位来表示虚拟内存地址。其中用户态虚拟内存空间为低 128 T，虚拟内存地址范围为：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF F000 。</p><p>内核态虚拟内存空间为高 128 T，虚拟内存地址范围为：0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 。</p><p><img src="/wp-content/uploads/2023/12/image-53-1024x1015.jpg"></p><p>64 位系统中用户地址空间和内核地址空间的分界线在  0x0000 7FFF FFFF F000 地址处，那么自然进程的 mm_struct 结构中的 task_size 为 0x0000 7FFF FFFF F000 。</p><p>我们来看下内核在 <code>/arch/x86/include/asm/page_64_types.h</code> 文件中关于 TASK_SIZE 的定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_SIZE  (test_thread_flag(TIF_ADDR32) ? \</span><br><span class="hljs-meta">     IA32_PAGE_OFFSET : TASK_SIZE_MAX)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_SIZE_MAX  task_size_max()</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> task_size_max()  ((_AC(1,UL) &lt;&lt; __VIRTUAL_MASK_SHIFT) - PAGE_SIZE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __VIRTUAL_MASK_SHIFT 47</span><br></code></pre></td></tr></table></figure><p>我们来看下在 64 位系统中内核如何来计算 TASK_SIZE，在  task_size_max() 的计算逻辑中 1 左移 47 位得到的地址是 0x0000800000000000，然后减去一个 PAGE_SIZE （默认为 4K），就是 0x00007FFFFFFFF000，共 128T。所以在 64 位系统中的 TASK_SIZE 为 0x00007FFFFFFFF000 。</p><blockquote><p>这里我们可以看出，64 位虚拟内存空间的布局是和物理内存页 page 的大小有关的，物理内存页 page 默认大小 PAGE_SIZE 为 4K。</p></blockquote><p>PAGE_SIZE 定义在 <code>/arch/x86/include/asm/page_types.h</code>文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* PAGE_SHIFT determines the page size */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SHIFT  12</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SIZE  (_AC(1,UL) &lt;&lt; PAGE_SHIFT)</span><br></code></pre></td></tr></table></figure><p>而内核空间的起始地址是 0xFFFF 8000 0000 0000 。在 0x00007FFFFFFFF000 - 0xFFFF 8000 0000 0000 之间的内存区域就是我们在 《4.2 64 位机器上进程虚拟内存空间分布》小节中介绍的 canonical address 空洞。</p><h3 id="5-2-内核如何布局进程虚拟内存空间"><a href="#5-2-内核如何布局进程虚拟内存空间" class="headerlink" title="5.2 内核如何布局进程虚拟内存空间"></a>5.2 内核如何布局进程虚拟内存空间</h3><p>在我们理解了内核是如何划分进程虚拟内存空间和内核虚拟内存空间之后，那么在 《3. 进程虚拟内存空间》小节中介绍的那些虚拟内存区域在内核中又是如何划分的呢？</p><p>接下来笔者就为大家介绍下内核是如何划分进程虚拟内存空间中的这些内存区域的，本小节的示例图中，笔者只保留了进程虚拟内存空间中的核心区域，方便大家理解。</p><p><img src="/wp-content/uploads/2023/12/image-53-1-1024x549.jpg"></p><p>前边我们提到，内核中采用了一个叫做内存描述符的 mm_struct 结构体来表示进程虚拟内存空间的全部信息。在本小节中笔者就带大家到 mm_struct 结构体内部去寻找下相关的线索。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> task_size;    <span class="hljs-comment">/* size of task vm space */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_code, end_code, start_data, end_data;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_brk, brk, start_stack;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg_start, arg_end, env_start, env_end;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_base;  <span class="hljs-comment">/* base of mmap area */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> total_vm;    <span class="hljs-comment">/* Total pages mapped */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> locked_vm;  <span class="hljs-comment">/* Pages that have PG_mlocked set */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pinned_vm;  <span class="hljs-comment">/* Refcount permanently increased */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data_vm;    <span class="hljs-comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> exec_vm;    <span class="hljs-comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_vm;    <span class="hljs-comment">/* VM_STACK */</span><br><br>       ...... 省略 ........<br>&#125;<br></code></pre></td></tr></table></figure><p>内核中用 mm_struct 结构体中的上述属性来定义上图中虚拟内存空间里的不同内存区域。</p><p>start_code 和 end_code 定义代码段的起始和结束位置，程序编译后的二进制文件中的机器码被加载进内存之后就存放在这里。</p><p>start_data 和 end_data 定义数据段的起始和结束位置，二进制文件中存放的全局变量和静态变量被加载进内存中就存放在这里。</p><p>后面紧挨着的是 BSS 段，用于存放未被初始化的全局变量和静态变量，这些变量在加载进内存时会生成一段 0 填充的内存区域 （BSS 段）， BSS 段的大小是固定的，</p><p>下面就是 OS 堆了，在堆中内存地址的增长方向是由低地址向高地址增长， start_brk 定义堆的起始位置，brk 定义堆当前的结束位置。</p><blockquote><p>我们使用 malloc 申请小块内存时（低于 128K），就是通过改变 brk 位置调整堆大小实现的。</p></blockquote><p>接下来就是内存映射区，在内存映射区内存地址的增长方向是由高地址向低地址增长，mmap_base 定义内存映射区的起始地址。进程运行时所依赖的动态链接库中的代码段，数据段，BSS 段以及我们调用 mmap 映射出来的一段虚拟内存空间就保存在这个区域。</p><p>start_stack 是栈的起始位置在 RBP 寄存器中存储，栈的结束位置也就是栈顶指针 stack pointer 在 RSP 寄存器中存储。在栈中内存地址的增长方向也是由高地址向低地址增长。</p><p>arg_start 和 arg_end 是参数列表的位置， env_start 和 env_end 是环境变量的位置。它们都位于栈中的最高地址处。</p><p><img src="/wp-content/uploads/2023/12/image-53-2-1024x433.jpg"></p><p>在 mm_struct 结构体中除了上述用于划分虚拟内存区域的变量之外，还定义了一些虚拟内存与物理内存映射内容相关的统计变量，操作系统会把物理内存划分成一页一页的区域来进行管理，所以物理内存到虚拟内存之间的映射也是按照页为单位进行的。这部分内容笔者会在后续的文章中详细介绍，大家这里只需要有个概念就行。</p><p>mm_struct 结构体中的 total_vm 表示在进程虚拟内存空间中总共与物理内存映射的页的总数。</p><blockquote><p>注意映射这个概念，它表示只是将虚拟内存与物理内存建立关联关系，并不代表真正的分配物理内存。</p></blockquote><p>当内存吃紧的时候，有些页可以换出到硬盘上，而有些页因为比较重要，不能换出。locked_vm 就是被锁定不能换出的内存页总数，pinned_vm  表示既不能换出，也不能移动的内存页总数。</p><p>data_vm 表示数据段中映射的内存页数目，exec_vm 是代码段中存放可执行文件的内存页数目，stack_vm 是栈中所映射的内存页数目，这些变量均是表示进程虚拟内存空间中的虚拟内存使用情况。</p><p>现在关于内核如何对进程虚拟内存空间进行布局的内容我们已经清楚了，那么布局之后划分出的这些虚拟内存区域在内核中又是如何被管理的呢？我们接着往下看~~~</p><h3 id="5-3-内核如何管理虚拟内存区域"><a href="#5-3-内核如何管理虚拟内存区域" class="headerlink" title="5.3 内核如何管理虚拟内存区域"></a>5.3 内核如何管理虚拟内存区域</h3><p>在上小节的介绍中，我们知道内核是通过一个 mm_struct 结构的内存描述符来表示进程的虚拟内存空间的，并通过 task_size 域来划分用户态虚拟内存空间和内核态虚拟内存空间。</p><p><img src="/wp-content/uploads/2023/12/image-53-3.jpg"></p><p>而在划分出的这些虚拟内存空间中如上图所示，里边又包含了许多特定的虚拟内存区域，比如：代码段，数据段，堆，内存映射区，栈。那么这些虚拟内存区域在内核中又是如何表示的呢？</p><p>本小节中，笔者将为大家介绍一个新的结构体 vm_area_struct，正是这个结构体描述了这些虚拟内存区域 VMA（virtual memory area）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_area_struct</span> &#123;<br><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_start;  <span class="hljs-comment">/* Our start address within vm_mm. */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_end;  <span class="hljs-comment">/* The first byte after our end address</span><br><span class="hljs-comment">        within vm_mm. */</span><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * Access permissions of this VMA.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-type">pgprot_t</span> vm_page_prot;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_flags; <br><br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">anon_vma</span> *anon_vma; <span class="hljs-comment">/* Serialized by page_table_lock */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file</span> * vm_file;  <span class="hljs-comment">/* File we map to (can be NULL). */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_pgoff;  <span class="hljs-comment">/* Offset (within vm_file) in PAGE_SIZE</span><br><span class="hljs-comment">        units */</span> <br> <span class="hljs-type">void</span> * vm_private_data;  <span class="hljs-comment">/* was vm_pte (shared mem) */</span><br> <span class="hljs-comment">/* Function pointers to deal with this struct. */</span><br> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_operations_struct</span> *vm_ops;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个 vm_area_struct 结构对应于虚拟内存空间中的唯一虚拟内存区域 VMA，vm_start 指向了这块虚拟内存区域的起始地址（最低地址），vm_start 本身包含在这块虚拟内存区域内。vm_end 指向了这块虚拟内存区域的结束地址（最高地址），而 vm_end 本身包含在这块虚拟内存区域之外，所以 vm_area_struct 结构描述的是 [vm_start，vm_end) 这样一段左闭右开的虚拟内存区域。</p><p><img src="/wp-content/uploads/2023/12/image-53-4-701x1024.jpg"></p><h3 id="5-4-定义虚拟内存区域的访问权限和行为规范"><a href="#5-4-定义虚拟内存区域的访问权限和行为规范" class="headerlink" title="5.4 定义虚拟内存区域的访问权限和行为规范"></a>5.4 定义虚拟内存区域的访问权限和行为规范</h3><p>vm_page_prot 和 vm_flags 都是用来标记 vm_area_struct 结构表示的这块虚拟内存区域的访问权限和行为规范。</p><p>上边小节中我们也提到，内核会将整块物理内存划分为一页一页大小的区域，以页为单位来管理这些物理内存，每页大小默认 4K 。而虚拟内存最终也是要和物理内存一一映射起来的，所以在虚拟内存空间中也有虚拟页的概念与之对应，虚拟内存中的虚拟页映射到物理内存中的物理页。无论是在虚拟内存空间中还是在物理内存中，内核管理内存的最小单位都是页。</p><p>vm_page_prot 偏向于定义底层内存管理架构中页这一级别的访问控制权限，它可以直接应用在底层页表中，它是一个具体的概念。</p><blockquote><p>页表用于管理虚拟内存到物理内存之间的映射关系，这部分内容笔者后续会详细讲解，这里大家有个初步的概念就行。</p></blockquote><p>虚拟内存区域 VMA 由许多的虚拟页 (page) 组成，每个虚拟页需要经过页表的转换才能找到对应的物理页面。页表中关于内存页的访问权限就是由 vm_page_prot 决定的。</p><p>vm_flags 则偏向于定于整个虚拟内存区域的访问权限以及行为规范。描述的是虚拟内存区域中的整体信息，而不是虚拟内存区域中具体的某个独立页面。它是一个抽象的概念。可以通过 <code>vma-&gt;vm_page_prot = vm_get_page_prot(vma-&gt;vm_flags)</code> 实现到具体页面访问权限 vm_page_prot 的转换。</p><p>下面笔者列举一些常用到的 vm_flags 方便大家有一个直观的感受：</p><p>vm_flags</p><p>访问权限</p><p>VM_READ</p><p>可读</p><p>VM_WRITE</p><p>可写</p><p>VM_EXEC</p><p>可执行</p><p>VM_SHARD</p><p>可多进程之间共享</p><p>VM_IO</p><p>可映射至设备 IO 空间</p><p>VM_RESERVED</p><p>内存区域不可被换出</p><p>VM_SEQ_READ</p><p>内存区域可能被顺序访问</p><p>VM_RAND_READ</p><p>内存区域可能被随机访问</p><p>VM_READ，VM_WRITE，VM_EXEC 定义了虚拟内存区域是否可以被读取，写入，执行等权限。</p><p>比如代码段这块内存区域的权限是可读，可执行，但是不可写。数据段具有可读可写的权限但是不可执行。堆则具有可读可写，可执行的权限（Java 中的字节码存储在堆中，所以需要可执行权限），栈一般是可读可写的权限，一般很少有可执行权限。而文件映射与匿名映射区存放了共享链接库，所以也需要可执行的权限。</p><p><img src="/wp-content/uploads/2023/12/image-53-5-701x1024.jpg"></p><p>VM_SHARD 用于指定这块虚拟内存区域映射的物理内存是否可以在多进程之间共享，以便完成进程间通讯。</p><blockquote><p>设置这个值即为 mmap 的共享映射，不设置的话则为私有映射。这个等后面我们讲到 mmap 的相关实现时还会再次提起。</p></blockquote><p>VM_IO 的设置表示这块虚拟内存区域可以映射至设备 IO 空间中。通常在设备驱动程序执行 mmap 进行 IO 空间映射时才会被设置。</p><p>VM_RESERVED 的设置表示在内存紧张的时候，这块虚拟内存区域非常重要，不能被换出到磁盘中。</p><p>VM_SEQ_READ 的设置用来暗示内核，应用程序对这块虚拟内存区域的读取是会采用顺序读的方式进行，内核会根据实际情况决定预读后续的内存页数，以便加快下次顺序访问速度。</p><p>VM_RAND_READ 的设置会暗示内核，应用程序会对这块虚拟内存区域进行随机读取，内核则会根据实际情况减少预读的内存页数甚至停止预读。</p><p>我们可以通过 posix_fadvise，madvise 系统调用来暗示内核是否对相关内存区域进行顺序读取或者随机读取。相关的详细内容，大家可以看下笔者上篇文章 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486623&idx=1&sn=0cafed9e89b60d678d8c88dc7689abda&chksm=ce77cad8f90043ceaaca732aaaa7cb692c1d23eeb6c07de84f0ad690ab92d758945807239cee&token=1276722624&lang=zh_CN&scene=21#wechat_redirect">《从 Linux 内核角度探秘 JDK NIO 文件读写本质》</a>中的第 9 小节文件页预读部分。</p><p>通过这一系列的介绍，我们可以看到 vm_flags 就是定义整个虚拟内存区域的访问权限以及行为规范，而内存区域中内存的最小单位为页（4K），虚拟内存区域中包含了很多这样的虚拟页，对于虚拟内存区域 VMA 设置的访问权限也会全部复制到区域中包含的内存页中。</p><h3 id="5-5-关联内存映射中的映射关系"><a href="#5-5-关联内存映射中的映射关系" class="headerlink" title="5.5 关联内存映射中的映射关系"></a>5.5 关联内存映射中的映射关系</h3><p>接下来的三个属性 anon_vma，vm_file，vm_pgoff 分别和虚拟内存映射相关，虚拟内存区域可以映射到物理内存上，也可以映射到文件中，映射到物理内存上我们称之为匿名映射，映射到文件中我们称之为文件映射。</p><p>那么这个映射关系在内核中该如何表示呢？这就用到了 vm_area_struct 结构体中的上述三个属性。</p><p><img src="/wp-content/uploads/2023/12/image-53-6-1024x433.jpg"></p><p>当我们调用 malloc 申请内存时，如果申请的是小块内存（低于 128K）则会使用 do_brk() 系统调用通过调整堆中的 brk 指针大小来增加或者回收堆内存。</p><p>如果申请的是比较大块的内存（超过 128K）时，则会调用 mmap 在上图虚拟内存空间中的文件映射与匿名映射区创建出一块 VMA 内存区域（这里是匿名映射）。这块匿名映射区域就用 struct anon_vma 结构表示。</p><p>当调用 mmap 进行文件映射时，vm_file 属性就用来关联被映射的文件。这样一来虚拟内存区域就与映射文件关联了起来。vm_pgoff 则表示映射进虚拟内存中的文件内容，在文件中的偏移。</p><blockquote><p>当然在匿名映射中，vm_area_struct 结构中的 vm_file 就为 null，vm_pgoff 也就没有了意义。</p></blockquote><p>vm_private_data 则用于存储 VMA 中的私有数据。具体的存储内容和内存映射的类型有关，我们暂不展开论述。</p><h3 id="5-6-针对虚拟内存区域的相关操作"><a href="#5-6-针对虚拟内存区域的相关操作" class="headerlink" title="5.6 针对虚拟内存区域的相关操作"></a>5.6 针对虚拟内存区域的相关操作</h3><p>struct vm_area_struct 结构中还有一个 vm_ops 用来指向针对虚拟内存区域 VMA 的相关操作的函数指针。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">vm_operations_struct</span> &#123;<br> <span class="hljs-built_in">void</span> (*<span class="hljs-keyword">open</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-type">vm_area_struct</span> * area);<br> <span class="hljs-built_in">void</span> (*<span class="hljs-built_in">close</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-type">vm_area_struct</span> * area);<br>    <span class="hljs-built_in">vm_fault_t</span> (*fault)(<span class="hljs-keyword">struct</span> <span class="hljs-type">vm_fault</span> *vmf);<br>    <span class="hljs-built_in">vm_fault_t</span> (*page_mkwrite)(<span class="hljs-keyword">struct</span> <span class="hljs-type">vm_fault</span> *vmf);<br><br>    ..... 省略 .......<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当指定的虚拟内存区域被加入到进程虚拟内存空间中时，open 函数会被调用</li><li>当虚拟内存区域 VMA 从进程虚拟内存空间中被删除时，close 函数会被调用</li><li>当进程访问虚拟内存时，访问的页面不在物理内存中，可能是未分配物理内存也可能是被置换到磁盘中，这时就会产生缺页异常，fault 函数就会被调用。</li><li>当一个只读的页面将要变为可写时，page_mkwrite 函数会被调用。</li></ul><p>struct vm_operations_struct 结构中定义的都是对虚拟内存区域 VMA 的相关操作函数指针。</p><p>内核中这种类似的用法其实有很多，在内核中每个特定领域的描述符都会定义相关的操作。比如在前边的文章 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486623&idx=1&sn=0cafed9e89b60d678d8c88dc7689abda&chksm=ce77cad8f90043ceaaca732aaaa7cb692c1d23eeb6c07de84f0ad690ab92d758945807239cee&token=1276722624&lang=zh_CN&scene=21#wechat_redirect">《从 Linux 内核角度探秘 JDK NIO 文件读写本质》</a> 中我们介绍到内核中的文件描述符 struct file 中定义的 struct file_operations  *f_op。里面定义了内核针对文件操作的函数指针，具体的实现根据不同的文件类型有所不同。</p><p>针对 Socket 文件类型，这里的 file_operations 指向的是 socket_file_ops。</p><p><img src="/wp-content/uploads/2023/12/image-53-7-1024x498.jpg"></p><p>在 ext4 文件系统中管理的文件对应的 file_operations 指向 ext4_file_operations，专门用于操作 ext4 文件系统中的文件。还有针对 page cache 页高速缓存相关操作定义的 address_space_operations 。</p><p><img src="/wp-content/uploads/2023/12/image-53-8-1024x620.jpg"></p><p>还有我们在 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247483737&idx=1&sn=7ef3afbb54289c6e839eed724bb8a9d6&chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&scene=21#wechat_redirect">《从 Linux 内核角度看 IO 模型的演变》</a>一文中介绍到，socket 相关的操作接口定义在 inet_stream_ops 函数集合中，负责对上给用户提供接口。而 socket 与内核协议栈之间的操作接口定义在 struct sock 中的 sk_prot 指针上，这里指向 tcp_prot 协议操作函数集合。</p><p><img src="/wp-content/uploads/2023/12/image-53-9-1024x576.jpg"></p><p>对 socket 发起的系统 IO 调用时，在内核中首先会调用 socket 的文件结构 struct file 中的 file_operations 文件操作集合，然后调用 struct socket 中的 ops 指向的 inet_stream_opssocket 操作函数，最终调用到 struct sock 中 sk_prot 指针指向的 tcp_prot 内核协议栈操作函数接口集合。</p><h3 id="5-7-虚拟内存区域在内核中是如何被组织的"><a href="#5-7-虚拟内存区域在内核中是如何被组织的" class="headerlink" title="5.7 虚拟内存区域在内核中是如何被组织的"></a>5.7 虚拟内存区域在内核中是如何被组织的</h3><p>在上一小节中，我们介绍了内核中用来表示虚拟内存区域 VMA 的结构体 struct vm_area_struct ，并详细为大家剖析了 struct vm_area_struct 中的一些重要的关键属性。</p><p>现在我们已经熟悉了这些虚拟内存区域，那么接下来的问题就是在内核中这些虚拟内存区域是如何被组织的呢？</p><p><img src="/wp-content/uploads/2023/12/image-53-10.jpg"></p><p>我们继续来到 struct vm_area_struct 结构中，来看一下与组织结构相关的一些属性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_area_struct</span> &#123;<br><br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_area_struct</span> *vm_next, *vm_prev;<br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_node</span> vm_rb;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> anon_vma_chain; <br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *vm_mm; <span class="hljs-comment">/* The address space we belong to. */</span><br> <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_start;     <span class="hljs-comment">/* Our start address within vm_mm. */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_end;       <span class="hljs-comment">/* The first byte after our end address</span><br><span class="hljs-comment">                       within vm_mm. */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Access permissions of this VMA.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">pgprot_t</span> vm_page_prot;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_flags; <br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">anon_vma</span> *anon_vma;  <span class="hljs-comment">/* Serialized by page_table_lock */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file</span> * vm_file;      <span class="hljs-comment">/* File we map to (can be NULL). */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_pgoff;     <span class="hljs-comment">/* Offset (within vm_file) in PAGE_SIZE</span><br><span class="hljs-comment">                       units */</span> <br>    <span class="hljs-type">void</span> * vm_private_data;     <span class="hljs-comment">/* was vm_pte (shared mem) */</span><br>    <span class="hljs-comment">/* Function pointers to deal with this struct. */</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_operations_struct</span> *vm_ops;<br>&#125;<br></code></pre></td></tr></table></figure><p>在内核中其实是通过一个 struct vm_area_struct 结构的双向链表将虚拟内存空间中的这些虚拟内存区域 VMA 串联起来的。</p><p>vm_area_struct 结构中的 vm_next ，vm_prev 指针分别指向 VMA 节点所在双向链表中的后继节点和前驱节点，内核中的这个 VMA 双向链表是有顺序的，所有 VMA 节点按照低地址到高地址的增长方向排序。</p><p>双向链表中的最后一个 VMA 节点的 vm_next 指针指向 NULL，双向链表的头指针存储在内存描述符 struct mm_struct 结构中的 mmap 中，正是这个 mmap 串联起了整个虚拟内存空间中的虚拟内存区域。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">mm_struct</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">vm_area_struct</span> *mmap;  <span class="hljs-comment">/* list of VMAs */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在每个虚拟内存区域 VMA 中又通过 struct vm_area_struct 中的 vm_mm 指针指向了所属的虚拟内存空间 mm_struct。</p><p><img src="/wp-content/uploads/2023/12/image-57-5-1024x694.jpg"></p><p>我们可以通过 <code>cat /proc/pid/maps</code> 或者 <code>pmap pid</code> 查看进程的虚拟内存空间布局以及其中包含的所有内存区域。这两个命令背后的实现原理就是通过遍历内核中的这个 vm_area_struct 双向链表获取的。</p><p>内核中关于这些虚拟内存区域的操作除了遍历之外还有许多需要根据特定虚拟内存地址在虚拟内存空间中查找特定的虚拟内存区域。</p><p>尤其在进程虚拟内存空间中包含的内存区域 VMA 比较多的情况下，使用红黑树查找特定虚拟内存区域的时间复杂度是 O( logN ) ，可以显著减少查找所需的时间。</p><p>所以在内核中，同样的内存区域 vm_area_struct 会有两种组织形式，一种是双向链表用于高效的遍历，另一种就是红黑树用于高效的查找。</p><p>每个 VMA 区域都是红黑树中的一个节点，通过 struct vm_area_struct 结构中的 vm_rb 将自己连接到红黑树中。</p><p>而红黑树中的根节点存储在内存描述符 struct mm_struct 中的 mm_rb 中：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">mm_struct</span> &#123;<br>     <span class="hljs-keyword">struct</span> <span class="hljs-type">rb_root</span> mm_rb;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/12/image-53-12-1024x793.jpg"></p><h2 id="6-程序编译后的二进制文件如何映射到虚拟内存空间中"><a href="#6-程序编译后的二进制文件如何映射到虚拟内存空间中" class="headerlink" title="6. 程序编译后的二进制文件如何映射到虚拟内存空间中"></a>6. 程序编译后的二进制文件如何映射到虚拟内存空间中</h2><p>经过前边这么多小节的内容介绍，现在我们已经熟悉了进程虚拟内存空间的布局，以及内核如何管理这些虚拟内存区域，并对进程的虚拟内存空间有了一个完整全面的认识。</p><p>现在我们再来回到最初的起点，进程的虚拟内存空间 mm_struct 以及这些虚拟内存区域 vm_area_struct 是如何被创建并初始化的呢？</p><p><img src="/wp-content/uploads/2023/12/image-53-13-1024x433.jpg"></p><p>在 《3. 进程虚拟内存空间》小节中，我们介绍进程的虚拟内存空间时提到，我们写的程序代码编译之后会生成一个 ELF 格式的二进制文件，这个二进制文件中包含了程序运行时所需要的元信息，比如程序的机器码，程序中的全局变量以及静态变量等。</p><p>这个 ELF 格式的二进制文件中的布局和我们前边讲的虚拟内存空间中的布局类似，也是一段一段的，每一段包含了不同的元数据。</p><blockquote><p>磁盘文件中的段我们叫做 Section，内存中的段我们叫做 Segment，也就是内存区域。</p></blockquote><p>磁盘文件中的这些 Section 会在进程运行之前加载到内存中并映射到内存中的 Segment。通常是多个 Section 映射到一个 Segment。</p><p>比如磁盘文件中的 .text，.rodata 等一些只读的 Section，会被映射到内存的一个只读可执行的 Segment 里（代码段）。而 .data，.bss 等一些可读写的 Section，则会被映射到内存的一个具有读写权限的 Segment 里（数据段，BSS 段）。</p><p>那么这些 ELF 格式的二进制文件中的 Section 是如何加载并映射进虚拟内存空间的呢？</p><p>内核中完成这个映射过程的函数是 load_elf_binary ，这个函数的作用很大，加载内核的是它，启动第一个用户态进程 init 的是它，fork 完了以后，调用 exec 运行一个二进制程序的也是它。当 exec 运行一个二进制程序的时候，除了解析 ELF 的格式之外，另外一个重要的事情就是建立上述提到的内存映射。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs lasso">static int load_elf_binary(struct linux_binprm *bprm)<br>&#123;<br>      <span class="hljs-params">...</span><span class="hljs-params">...</span> 省略 <span class="hljs-params">...</span><span class="hljs-params">...</span>..<br>  <span class="hljs-comment">// 设置虚拟内存空间中的内存映射区域起始地址 mmap_base</span><br>  setup_new_exec(bprm);<br><br>     <span class="hljs-params">...</span><span class="hljs-params">...</span> 省略 <span class="hljs-params">...</span><span class="hljs-params">...</span>..<br>  <span class="hljs-comment">// 创建并初始化栈对应的 vm_area_struct 结构。</span><br>  <span class="hljs-comment">// 设置 mm-&gt;start_stack 就是栈的起始地址也就是栈底，并将 mm-&gt;arg_start 是指向栈底的。</span><br>  retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),<br>         executable_stack);<br><br>     <span class="hljs-params">...</span><span class="hljs-params">...</span> 省略 <span class="hljs-params">...</span><span class="hljs-params">...</span>..<br>  <span class="hljs-comment">// 将二进制文件中的代码部分映射到虚拟内存空间中</span><br>  error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,<br>        elf_prot, elf_flags, total_size);<br><br>     <span class="hljs-params">...</span><span class="hljs-params">...</span> 省略 <span class="hljs-params">...</span><span class="hljs-params">...</span>..<br> <span class="hljs-comment">// 创建并初始化堆对应的的 vm_area_struct 结构</span><br> <span class="hljs-comment">// 设置 current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk，设置堆的起始地址 start_brk，结束地址 brk。 起初两者相等表示堆是空的</span><br>  retval = set_brk(elf_bss, elf_brk, bss_prot);<br><br>     <span class="hljs-params">...</span><span class="hljs-params">...</span> 省略 <span class="hljs-params">...</span><span class="hljs-params">...</span>..<br>  <span class="hljs-comment">// 将进程依赖的动态链接库 .so 文件映射到虚拟内存空间中的内存映射区域</span><br>  elf_entry = load_elf_interp(&amp;loc-&gt;interp_elf_ex,<br>              interpreter,<br>              &amp;interp_map_addr,<br>              load_bias, interp_elf_phdata);<br><br>     <span class="hljs-params">...</span><span class="hljs-params">...</span> 省略 <span class="hljs-params">...</span><span class="hljs-params">...</span>..<br>  <span class="hljs-comment">// 初始化内存描述符 mm_struct</span><br>  current-&gt;mm-&gt;end_code = end_code;<br>  current-&gt;mm-&gt;start_code = start_code;<br>  current-&gt;mm-&gt;start_data = start_data;<br>  current-&gt;mm-&gt;end_data = end_data;<br>  current-&gt;mm-&gt;start_stack = bprm-&gt;p;<br><br>     <span class="hljs-params">...</span><span class="hljs-params">...</span> 省略 <span class="hljs-params">...</span><span class="hljs-params">...</span>..<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>setup_new_exec 设置虚拟内存空间中的内存映射区域起始地址 mmap_base</li><li>setup_arg_pages 创建并初始化栈对应的 vm_area_struct 结构。置 mm-&gt;start_stack 就是栈的起始地址也就是栈底，并将 mm-&gt;arg_start 是指向栈底的。</li><li>elf_map 将 ELF 格式的二进制文件中.text ，.data，.bss 部分映射到虚拟内存空间中的代码段，数据段，BSS 段中。</li><li>set_brk 创建并初始化堆对应的的 vm_area_struct 结构，设置 <code>current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk</code>，设置堆的起始地址 start_brk，结束地址 brk。 起初两者相等表示堆是空的。</li><li>load_elf_interp 将进程依赖的动态链接库 .so 文件映射到虚拟内存空间中的内存映射区域</li><li>初始化内存描述符 mm_struct</li></ul><h2 id="7-内核虚拟内存空间"><a href="#7-内核虚拟内存空间" class="headerlink" title="7. 内核虚拟内存空间"></a>7. 内核虚拟内存空间</h2><p>现在我们已经知道了进程虚拟内存空间在内核中的布局以及管理，那么内核态的虚拟内存空间又是什么样子的呢？本小节笔者就带大家来一层一层地拆开这个黑盒子。</p><p>之前在介绍进程虚拟内存空间的时候，笔者提到不同进程之间的虚拟内存空间是相互隔离的，彼此之间相互独立，相互感知不到其他进程的存在。使得进程以为自己拥有所有的内存资源。</p><p><img src="/wp-content/uploads/2023/12/image-53-14-1024x743.jpg"></p><p>而内核态虚拟内存空间是所有进程共享的，不同进程进入内核态之后看到的虚拟内存空间全部是一样的。</p><p>什么意思呢？比如上图中的进程 a，进程 b，进程 c 分别在各自的用户态虚拟内存空间中访问虚拟地址 x 。由于进程之间的用户态虚拟内存空间是相互隔离相互独立的，虽然在进程a，进程b，进程c 访问的都是虚拟地址 x 但是看到的内容却是不一样的（背后可能映射到不同的物理内存中）。</p><p>但是当进程 a，进程 b，进程 c 进入到内核态之后情况就不一样了，由于内核虚拟内存空间是各个进程共享的，所以它们在内核空间中看到的内容全部是一样的，比如进程 a，进程 b，进程 c 在内核态都去访问虚拟地址 y。这时它们看到的内容就是一样的了。</p><blockquote><p>这里笔者和大家澄清一个经常被误解的概念：由于内核会涉及到物理内存的管理，所以很多人会想当然地认为只要进入了内核态就开始使用物理地址了，这就大错特错了，千万不要这样理解，进程进入内核态之后使用的仍然是虚拟内存地址，只不过在内核中使用的虚拟内存地址被限制在了内核态虚拟内存空间范围中，这也是本小节笔者要为大家介绍的主题。</p></blockquote><p>在清楚了这个基本概念之后，下面笔者分别从 32 位体系 和 64 位体系下为大家介绍内核态虚拟内存空间的布局。</p><h3 id="7-1-32-位体系内核虚拟内存空间布局"><a href="#7-1-32-位体系内核虚拟内存空间布局" class="headerlink" title="7.1 32 位体系内核虚拟内存空间布局"></a>7.1 32 位体系内核虚拟内存空间布局</h3><p>在前边《5.1 内核如何划分用户态和内核态虚拟内存空间》小节中我们提到，内核在 <code>/arch/x86/include/asm/page_32_types.h</code> 文件中通过 TASK_SIZE 将进程虚拟内存空间和内核虚拟内存空间分割开来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * User space process size: 3GB (default).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_SIZE       __PAGE_OFFSET</span><br></code></pre></td></tr></table></figure><blockquote><p>__PAGE_OFFSET 的值在 32 位系统下为 0xC000 000</p></blockquote><p><img src="/wp-content/uploads/2023/12/image-53-15-1024x926.jpg"></p><p>在 32 位体系结构下进程用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000 。内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF。</p><p>本小节我们主要关注 0xC000 000 - 0xFFFF FFFF 这段虚拟内存地址区域也就是内核虚拟内存空间的布局情况。</p><h4 id="7-1-1-直接映射区"><a href="#7-1-1-直接映射区" class="headerlink" title="7.1.1 直接映射区"></a>7.1.1 直接映射区</h4><p>在总共大小 1G 的内核虚拟内存空间中，位于最前边有一块 896M 大小的区域，我们称之为直接映射区或者线性映射区，地址范围为 3G – 3G + 896m 。</p><p>之所以这块 896M 大小的区域称为直接映射区或者线性映射区，是因为这块连续的虚拟内存地址会映射到 0 - 896M 这块连续的物理内存上。</p><p>也就是说 3G – 3G + 896m 这块 896M 大小的虚拟内存会直接映射到 0 - 896M 这块 896M 大小的物理内存上，<strong>这块区域中的虚拟内存地址直接减去 0xC000 0000 (3G) 就得到了物理内存地址</strong>。所以我们称这块区域为直接映射区。</p><blockquote><p>为了方便为大家解释，我们假设现在机器上的物理内存为 4G 大小</p></blockquote><p><img src="/wp-content/uploads/2023/12/image-53-1024x536.png"></p><blockquote><p>虽然这块区域中的虚拟地址是直接映射到物理地址上，但是内核在访问这段区域的时候还是走的虚拟内存地址，内核也会为这块空间建立映射页表。关于页表的概念笔者后续会为大家详细讲解，这里大家只需要简单理解为页表保存了虚拟地址到物理地址的映射关系即可。</p></blockquote><p><strong>大家这里只需要记得内核态虚拟内存空间的前 896M 区域是直接映射到物理内存中的前 896M 区域中的，直接映射区中的映射关系是一比一映射。映射关系是固定的不会改变</strong>。</p><p>明白了这个关系之后，我们接下来就看一下这块直接映射区域在物理内存中究竟存的是什么内容~~~</p><p>在这段 896M 大小的物理内存中，前 1M 已经在系统启动的时候被系统占用，1M 之后的物理内存存放的是内核代码段，数据段，BSS 段（这些信息起初存放在 ELF格式的二进制文件中，在系统启动的时候被加载进内存）。</p><blockquote><p>我们可以通过 <code>cat /proc/iomem</code> 命令查看具体物理内存布局情况。</p></blockquote><p>当我们使用 fork 系统调用创建进程的时候，内核会创建一系列进程相关的描述符，比如之前提到的进程的核心数据结构 task_struct，进程的内存空间描述符 mm_struct，以及虚拟内存区域描述符 vm_area_struct 等。</p><p>这些进程相关的数据结构也会存放在物理内存前 896M 的这段区域中，当然也会被直接映射至内核态虚拟内存空间中的 3G – 3G + 896m 这段直接映射区域中。</p><p><img src="/wp-content/uploads/2023/12/image-54-1024x793.jpg"></p><p>当进程被创建完毕之后，在内核运行的过程中，会涉及内核栈的分配，内核会为每个进程分配一个固定大小的内核栈（一般是两个页大小，依赖具体的体系结构），每个进程的整个调用链必须放在自己的内核栈中，内核栈也是分配在直接映射区。</p><p>与进程用户空间中的栈不同的是，内核栈容量小而且是固定的，用户空间中的栈容量大而且可以动态扩展。内核栈的溢出危害非常巨大，它会直接悄无声息的覆盖相邻内存区域中的数据，破坏数据。</p><p>通过以上内容的介绍我们了解到内核虚拟内存空间最前边的这段 896M 大小的直接映射区如何与物理内存进行映射关联，并且清楚了直接映射区主要用来存放哪些内容。</p><p>写到这里，笔者觉得还是有必要再次从功能划分的角度为大家介绍下这块直接映射区域。</p><p>我们都知道内核对物理内存的管理都是以页为最小单位来管理的，每页默认 4K 大小，理想状况下任何种类的数据页都可以存放在任何页框中，没有什么限制。比如：存放内核数据，用户数据，缓冲磁盘数据等。</p><p>但是实际的计算机体系结构受到硬件方面的限制制约，间接导致限制了页框的使用方式。</p><p>比如在 X86 体系结构下，ISA 总线的 DMA （直接内存存取）控制器，只能对内存的前16M 进行寻址，这就导致了 ISA 设备不能在整个 32 位地址空间中执行 DMA，只能使用物理内存的前 16M 进行 DMA 操作。</p><p>因此直接映射区的前 16M 专门让内核用来为 DMA 分配内存，这块 16M 大小的内存区域我们称之为 ZONE_DMA。</p><blockquote><p>用于 DMA 的内存必须从 ZONE_DMA 区域中分配。</p></blockquote><p>而直接映射区中剩下的部分也就是从 16M 到 896M（不包含 896M）这段区域，我们称之为 ZONE_NORMAL。从字面意义上我们可以了解到，这块区域包含的就是正常的页框（使用没有任何限制）。</p><p>ZONE_NORMAL 由于也是属于直接映射区的一部分，对应的物理内存 16M 到 896M 这段区域也是被直接映射至内核态虚拟内存空间中的 3G + 16M 到 3G + 896M 这段虚拟内存上。</p><p><img src="/wp-content/uploads/2023/12/image-54-1-1024x522.jpg"></p><blockquote><p>注意这里的 ZONE_DMA 和 ZONE_NORMAL 是内核针对物理内存区域的划分。</p></blockquote><p>现在物理内存中的前 896M 的区域也就是前边介绍的 ZONE_DMA 和 ZONE_NORMAL 区域到内核虚拟内存空间的映射笔者就为大家介绍完了，它们都是采用直接映射的方式，一比一就行映射。</p><h4 id="7-1-2-ZONE-HIGHMEM-高端内存"><a href="#7-1-2-ZONE-HIGHMEM-高端内存" class="headerlink" title="7.1.2  ZONE_HIGHMEM 高端内存"></a>7.1.2  ZONE_HIGHMEM 高端内存</h4><p>而物理内存 896M 以上的区域被内核划分为 ZONE_HIGHMEM 区域，我们称之为高端内存。</p><p>本例中我们的物理内存假设为 4G，高端内存区域为 4G - 896M &#x3D; 3200M，那么这块 3200M 大小的 ZONE_HIGHMEM 区域该如何映射到内核虚拟内存空间中呢？</p><p>由于内核虚拟内存空间中的前 896M 虚拟内存已经被直接映射区所占用，而在 32 体系结构下内核虚拟内存空间总共也就 1G 的大小，这样一来内核剩余可用的虚拟内存空间就变为了 1G - 896M &#x3D; 128M。</p><p>显然物理内存中 3200M 大小的 ZONE_HIGHMEM 区域无法继续通过直接映射的方式映射到这 128M 大小的虚拟内存空间中。</p><p>这样一来物理内存中的 ZONE_HIGHMEM 区域就只能采用动态映射的方式映射到 128M 大小的内核虚拟内存空间中，也就是说只能动态的一部分一部分的分批映射，先映射正在使用的这部分，使用完毕解除映射，接着映射其他部分。</p><p>知道了 ZONE_HIGHMEM 区域的映射原理，我们接着往下看这 128M 大小的内核虚拟内存空间究竟是如何布局的？</p><p><img src="/wp-content/uploads/2023/12/image-54-2-1024x522.jpg"></p><p>内核虚拟内存空间中的 3G + 896M 这块地址在内核中定义为 high_memory，high_memory 往上有一段 8M 大小的内存空洞。空洞范围为：high_memory 到  VMALLOC_START 。</p><p>VMALLOC_START 定义在内核源码 <code>/arch/x86/include/asm/pgtable_32_areas.h</code> 文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> VMALLOC_OFFSET (8 * 1024 * 1024)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VMALLOC_START ((unsigned long)high_memory + VMALLOC_OFFSET)</span><br></code></pre></td></tr></table></figure><h4 id="7-1-3-vmalloc-动态映射区"><a href="#7-1-3-vmalloc-动态映射区" class="headerlink" title="7.1.3 vmalloc 动态映射区"></a>7.1.3 vmalloc 动态映射区</h4><p>接下来 VMALLOC_START 到 VMALLOC_END 之间的这块区域成为动态映射区。采用动态映射的方式映射物理内存中的高端内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIGHMEM</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMALLOC_END (PKMAP_BASE - 2 * PAGE_SIZE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMALLOC_END (LDT_BASE_ADDR - 2 * PAGE_SIZE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/12/image-54-3-1024x434.jpg"></p><p>和用户态进程使用 malloc 申请内存一样，在这块动态映射区内核是使用 vmalloc 进行内存分配。由于之前介绍的动态映射的原因，vmalloc 分配的内存在虚拟内存上是连续的，但是物理内存是不连续的。通过页表来建立物理内存与虚拟内存之间的映射关系，从而可以将不连续的物理内存映射到连续的虚拟内存上。</p><blockquote><p>由于 vmalloc 获得的物理内存页是不连续的，因此它只能将这些物理内存页一个一个地进行映射，在性能开销上会比直接映射大得多。</p></blockquote><p>关于 vmalloc 分配内存的相关实现原理，笔者会在后面的文章中为大家讲解，这里大家只需要明白它在哪块虚拟内存区域中活动即可。</p><h4 id="7-1-4-永久映射区"><a href="#7-1-4-永久映射区" class="headerlink" title="7.1.4 永久映射区"></a>7.1.4 永久映射区</h4><p><img src="/wp-content/uploads/2023/12/image-54-4-1024x434.jpg"></p><p>而在 PKMAP_BASE 到 FIXADDR_START 之间的这段空间称为永久映射区。在内核的这段虚拟地址空间中允许建立与物理高端内存的长期映射关系。比如内核通过 alloc_pages() 函数在物理内存的高端内存中申请获取到的物理内存页，这些物理内存页可以通过调用 kmap 映射到永久映射区中。</p><blockquote><p>LAST_PKMAP 表示永久映射区可以映射的页数限制。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PKMAP_BASE  \</span><br><span class="hljs-meta"> ((LDT_BASE_ADDR - PAGE_SIZE) &amp; PMD_MASK)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LAST_PKMAP 1024</span><br></code></pre></td></tr></table></figure><h4 id="7-1-5-固定映射区"><a href="#7-1-5-固定映射区" class="headerlink" title="7.1.5 固定映射区"></a>7.1.5 固定映射区</h4><p><img src="/wp-content/uploads/2023/12/image-54-5-1024x462.jpg"></p><p>内核虚拟内存空间中的下一个区域为固定映射区，区域范围为：FIXADDR_START 到 FIXADDR_TOP。</p><p>FIXADDR_START 和 FIXADDR_TOP 定义在内核源码 <code>/arch/x86/include/asm/fixmap.h</code> 文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIXADDR_START  (FIXADDR_TOP - FIXADDR_SIZE)</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __FIXADDR_TOP; <span class="hljs-comment">// 0xFFFF F000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIXADDR_TOP ((unsigned long)__FIXADDR_TOP)</span><br></code></pre></td></tr></table></figure><p>在内核虚拟内存空间的直接映射区中，直接映射区中的虚拟内存地址与物理内存前 896M 的空间的映射关系都是预设好的，一比一映射。</p><p>在固定映射区中的虚拟内存地址可以自由映射到物理内存的高端地址上，但是与动态映射区以及永久映射区不同的是，在固定映射区中虚拟地址是固定的，而被映射的物理地址是可以改变的。也就是说，有些虚拟地址在编译的时候就固定下来了，是在内核启动过程中被确定的，而这些虚拟地址对应的物理地址不是固定的。采用固定虚拟地址的好处是它相当于一个指针常量（常量的值在编译时确定），指向物理地址，如果虚拟地址不固定，则相当于一个指针变量。</p><p>那为什么会有固定映射这个概念呢 ?  比如：在内核的启动过程中，有些模块需要使用虚拟内存并映射到指定的物理地址上，而且这些模块也没有办法等待完整的内存管理模块初始化之后再进行地址映射。因此，内核固定分配了一些虚拟地址，这些地址有固定的用途，使用该地址的模块在初始化的时候，将这些固定分配的虚拟地址映射到指定的物理地址上去。</p><h4 id="7-1-6-临时映射区"><a href="#7-1-6-临时映射区" class="headerlink" title="7.1.6  临时映射区"></a>7.1.6  临时映射区</h4><p>在内核虚拟内存空间中的最后一块区域为临时映射区，那么这块临时映射区是用来干什么的呢？</p><p><img src="/wp-content/uploads/2023/12/image-54-6-1024x462.jpg"></p><p>笔者在之前文章 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486623&idx=1&sn=0cafed9e89b60d678d8c88dc7689abda&chksm=ce77cad8f90043ceaaca732aaaa7cb692c1d23eeb6c07de84f0ad690ab92d758945807239cee&token=1276722624&lang=zh_CN&scene=21#wechat_redirect">《从 Linux 内核角度探秘 JDK NIO 文件读写本质》</a> 的 “ 12.3 iov_iter_copy_from_user_atomic ” 小节中介绍在 Buffered IO 模式下进行文件写入的时候，在下图中的第四步，内核会调用 iov_iter_copy_from_user_atomic 函数将用户空间缓冲区 DirectByteBuffer 中的待写入数据拷贝到 page cache 中。</p><p><img src="/wp-content/uploads/2023/12/image-54-7-838x1024.jpg"></p><p>但是内核又不能直接进行拷贝，因为此时从 page cache 中取出的缓存页 page 是物理地址，而在内核中是不能够直接操作物理地址的，只能操作虚拟地址。</p><p>那怎么办呢？所以就需要使用 kmap_atomic 将缓存页临时映射到内核空间的一段虚拟地址上，这段虚拟地址就位于内核虚拟内存空间中的临时映射区上，然后将用户空间缓存区 DirectByteBuffer 中的待写入数据通过这段映射的虚拟地址拷贝到 page cache 中的相应缓存页中。这时文件的写入操作就已经完成了。</p><p>由于是临时映射，所以在拷贝完成之后，调用 kunmap_atomic 将这段映射再解除掉。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">iov_iter_copy_from_user_atomic</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">struct</span> iov_iter *i, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> offset, <span class="hljs-type">size_t</span> bytes)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 将缓存页临时映射到内核虚拟地址空间的临时映射区中</span><br>  <span class="hljs-type">char</span> *kaddr = <span class="hljs-built_in">kmap_atomic</span>(page), <br>  *p = kaddr + offset;<br>  <span class="hljs-comment">// 将用户缓存区 DirectByteBuffer 中的待写入数据拷贝到文件缓存页中</span><br>  <span class="hljs-built_in">iterate_all_kinds</span>(i, bytes, v,<br>    <span class="hljs-built_in">copyin</span>((p += v.iov_len) - v.iov_len, v.iov_base, v.iov_len),<br>    <span class="hljs-built_in">memcpy_from_page</span>((p += v.bv_len) - v.bv_len, v.bv_page,<br>         v.bv_offset, v.bv_len),<br>    <span class="hljs-built_in">memcpy</span>((p += v.iov_len) - v.iov_len, v.iov_base, v.iov_len)<br>  )<br>  <span class="hljs-comment">// 解除内核虚拟地址空间与缓存页之间的临时映射，这里映射只是为了临时拷贝数据用</span><br>  <span class="hljs-built_in">kunmap_atomic</span>(kaddr);<br>  <span class="hljs-keyword">return</span> bytes;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-1-7-32位体系结构下-Linux-虚拟内存空间整体布局"><a href="#7-1-7-32位体系结构下-Linux-虚拟内存空间整体布局" class="headerlink" title="7.1.7 32位体系结构下 Linux 虚拟内存空间整体布局"></a>7.1.7 32位体系结构下 Linux 虚拟内存空间整体布局</h4><p>到现在为止，整个内核虚拟内存空间在 32 位体系下的布局，笔者就为大家详细介绍完毕了，我们再次结合前边《4.1 32 位机器上进程虚拟内存空间分布》小节中介绍的进程虚拟内存空间和本小节介绍的内核虚拟内存空间来整体回顾下 32 位体系结构 Linux 的整个虚拟内存空间的布局：</p><p><img src="/wp-content/uploads/2023/12/image-54-8-923x1024.jpg"></p><h3 id="7-2-64-位体系内核虚拟内存空间布局"><a href="#7-2-64-位体系内核虚拟内存空间布局" class="headerlink" title="7.2 64 位体系内核虚拟内存空间布局"></a>7.2 64 位体系内核虚拟内存空间布局</h3><p>内核虚拟内存空间在 32 位体系下只有 1G 大小，实在太小了，因此需要精细化的管理，于是按照功能分类划分除了很多内核虚拟内存区域，这样就显得非常复杂。</p><p>到了 64 位体系下，内核虚拟内存空间的布局和管理就变得容易多了，因为进程虚拟内存空间和内核虚拟内存空间各自占用 128T 的虚拟内存，实在是太大了，我们可以在这里边随意翱翔，随意挥霍。</p><p>因此在 64 位体系下的内核虚拟内存空间与物理内存的映射就变得非常简单，由于虚拟内存空间足够的大，即便是内核要访问全部的物理内存，直接映射就可以了，不在需要用到《7.1.2 ZONE_HIGHMEM 高端内存》小节中介绍的高端内存那种动态映射方式。</p><p>在前边《5.1 内核如何划分用户态和内核态虚拟内存空间》小节中我们提到，内核在 <code>/arch/x86/include/asm/page_64_types.h</code> 文件中通过 TASK_SIZE 将进程虚拟内存空间和内核虚拟内存空间分割开来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_SIZE  (test_thread_flag(TIF_ADDR32) ? \</span><br><span class="hljs-meta">     IA32_PAGE_OFFSET : TASK_SIZE_MAX)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_SIZE_MAX  task_size_max()</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> task_size_max()  ((_AC(1,UL) &lt;&lt; __VIRTUAL_MASK_SHIFT) - PAGE_SIZE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __VIRTUAL_MASK_SHIFT 47</span><br></code></pre></td></tr></table></figure><blockquote><p>64 位系统中的 TASK_SIZE 为 0x00007FFFFFFFF000</p></blockquote><p><img src="/wp-content/uploads/2023/12/image-54-9-1024x1015.jpg"></p><p>在 64 位系统中，只使用了其中的低 48 位来表示虚拟内存地址。其中用户态虚拟内存空间为低 128 T，虚拟内存地址范围为：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF F000 。</p><p>内核态虚拟内存空间为高 128 T，虚拟内存地址范围为：0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 。</p><p>本小节我们主要关注 0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 这段内核虚拟内存空间的布局情况。</p><p><img src="/wp-content/uploads/2023/12/image-54-10-946x1024.jpg"></p><p>64 位内核虚拟内存空间从 0xFFFF 8000 0000 0000 开始到 0xFFFF 8800 0000 0000 这段地址空间是一个 8T 大小的内存空洞区域。</p><p>紧着着 8T 大小的内存空洞下一个区域就是 64T 大小的直接映射区。这个区域中的虚拟内存地址减去 PAGE_OFFSET 就直接得到了物理内存地址。</p><p>PAGE_OFFSET 变量定义在 <code>/arch/x86/include/asm/page_64_types.h</code> 文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PAGE_OFFSET_BASE      _AC(0xffff880000000000, UL)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PAGE_OFFSET           __PAGE_OFFSET_BASE</span><br></code></pre></td></tr></table></figure><p>从图中 VMALLOC_START 到 VMALLOC_END 的这段区域是 32T 大小的 vmalloc 映射区，这里类似用户空间中的堆，内核在这里使用 vmalloc 系统调用申请内存。</p><p>VMALLOC_START 和  VMALLOC_END 变量定义在 <code>/arch/x86/include/asm/pgtable_64_types.h</code> 文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __VMALLOC_BASE_L4 0xffffc90000000000UL</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VMEMMAP_START  __VMEMMAP_BASE_L4</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VMALLOC_END  (VMALLOC_START + (VMALLOC_SIZE_TB &lt;&lt; 40) - 1)</span><br></code></pre></td></tr></table></figure><p>从 VMEMMAP_START 开始是 1T 大小的虚拟内存映射区，用于存放物理页面的描述符 struct page 结构用来表示物理内存页。</p><p>VMEMMAP_START 变量定义在 <code>/arch/x86/include/asm/pgtable_64_types.h</code> 文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __VMEMMAP_BASE_L4 0xffffea0000000000UL</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMEMMAP_START  __VMEMMAP_BASE_L4</span><br></code></pre></td></tr></table></figure><p>从 __START_KERNEL_map 开始是大小为 512M 的区域用于存放内核代码段、全局变量、BSS 等。这里对应到物理内存开始的位置，减去 __START_KERNEL_map 就能得到物理内存的地址。这里和直接映射区有点像，但是不矛盾，因为直接映射区之前有 8T 的空洞区域，早就过了内核代码在物理内存中加载的位置。</p><p>__START_KERNEL_map 变量定义在 <code>/arch/x86/include/asm/page_64_types.h</code> 文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __START_KERNEL_map  _AC(0xffffffff80000000, UL)</span><br></code></pre></td></tr></table></figure><h3 id="7-2-1-64位体系结构下-Linux-虚拟内存空间整体布局"><a href="#7-2-1-64位体系结构下-Linux-虚拟内存空间整体布局" class="headerlink" title="7.2.1 64位体系结构下 Linux 虚拟内存空间整体布局"></a>7.2.1 64位体系结构下 Linux 虚拟内存空间整体布局</h3><p>到现在为止，整个内核虚拟内存空间在 64 位体系下的布局笔者就为大家详细介绍完毕了，我们再次结合前边《4.2 64 位机器上进程虚拟内存空间分布》小节介绍的进程虚拟内存空间和本小节介绍的内核虚拟内存空间来整体回顾下 64 位体系结构 Linux 的整个虚拟内存空间的布局：</p><p><img src="/wp-content/uploads/2023/12/image-54-11-929x1024.jpg"></p><h2 id="8-到底什么是物理内存地址"><a href="#8-到底什么是物理内存地址" class="headerlink" title="8. 到底什么是物理内存地址"></a>8. 到底什么是物理内存地址</h2><p>聊完了虚拟内存，我们接着聊一下物理内存，我们平时所称的内存也叫随机访问存储器（ random-access memory ）也叫 RAM 。而 RAM 分为两类：</p><ul><li>一类是静态 RAM（ <code>SRAM</code> ），这类 SRAM 用于 CPU 高速缓存 L1Cache，L2Cache，L3Cache。其特点是访问速度快，访问速度为 1 - 30 个时钟周期，但是容量小，造价高。</li></ul><p><img src="/wp-content/uploads/2023/12/image-57-3-1024x671.jpg"></p><ul><li>另一类则是动态 RAM ( <code>DRAM</code> )，这类 DRAM 用于我们常说的主存上，其特点的是访问速度慢（相对高速缓存），访问速度为 50 - 200 个时钟周期，但是容量大，造价便宜些（相对高速缓存）。</li></ul><p>内存由一个一个的存储器模块（memory module）组成，它们插在主板的扩展槽上。常见的存储器模块通常以 64 位为单位（ 8 个字节）传输数据到存储控制器上或者从存储控制器传出数据。</p><p><img src="/wp-content/uploads/2023/12/image-57-2.jpg"></p><p>如图所示内存条上黑色的元器件就是存储器模块（memory module）。多个存储器模块连接到存储控制器上，就聚合成了主存。</p><p><img src="/wp-content/uploads/2023/12/image-57-1-1024x596.jpg"></p><p>而 DRAM 芯片就包装在存储器模块中，每个存储器模块中包含 8 个 DRAM 芯片，依次编号为 0 - 7 。</p><p><img src="/wp-content/uploads/2023/12/image-57-1024x535.jpg"></p><p>而每一个 DRAM 芯片的存储结构是一个二维矩阵，二维矩阵中存储的元素我们称为超单元（supercell），每个 supercell 大小为一个字节（8 bit）。每个 supercell 都由一个坐标地址（i，j）。</p><blockquote><p>i 表示二维矩阵中的行地址，在计算机中行地址称为 RAS (row access strobe，行访问选通脉冲)。 j 表示二维矩阵中的列地址，在计算机中列地址称为 CAS (column access strobe,列访问选通脉冲)。</p></blockquote><p>下图中的 supercell 的 RAS &#x3D; 2，CAS &#x3D; 2。</p><p><img src="/wp-content/uploads/2023/12/image-56-1024x426.png"></p><p>DRAM 芯片中的信息通过引脚流入流出 DRAM 芯片。每个引脚携带 1 bit的信号。</p><p>图中 DRAM 芯片包含了两个地址引脚( <code>addr</code> )，因为我们要通过 RAS，CAS 来定位要获取的 supercell 。还有 8 个数据引脚（<code>data</code>），因为 DRAM 芯片的 IO 单位为一个字节（8 bit），所以需要 8 个 data 引脚从 DRAM 芯片传入传出数据。</p><blockquote><p>注意这里只是为了解释地址引脚和数据引脚的概念，实际硬件中的引脚数量是不一定的。</p></blockquote><h3 id="8-1-DRAM-芯片的访问"><a href="#8-1-DRAM-芯片的访问" class="headerlink" title="8.1 DRAM 芯片的访问"></a>8.1 DRAM 芯片的访问</h3><p>我们现在就以读取上图中坐标地址为（2，2）的 supercell 为例，来说明访问 DRAM 芯片的过程。</p><p><img src="/wp-content/uploads/2023/12/image-56-1024x644.jpg"></p><ol><li>首先存储控制器将行地址 RAS &#x3D; 2 通过地址引脚发送给 DRAM 芯片。</li><li>DRAM 芯片根据 RAS &#x3D; 2 将二维矩阵中的第二行的全部内容拷贝到内部行缓冲区中。</li><li>接下来存储控制器会通过地址引脚发送 CAS &#x3D; 2 到 DRAM 芯片中。</li><li>DRAM芯片从内部行缓冲区中根据 CAS &#x3D; 2 拷贝出第二列的 supercell 并通过数据引脚发送给存储控制器。</li></ol><blockquote><p>DRAM 芯片的 IO 单位为一个 supercell ，也就是一个字节(8 bit)。</p></blockquote><h3 id="8-2-CPU-如何读写主存"><a href="#8-2-CPU-如何读写主存" class="headerlink" title="8.2 CPU 如何读写主存"></a>8.2 CPU 如何读写主存</h3><p>前边我们介绍了内存的物理结构，以及如何访问内存中的 DRAM 芯片获取 supercell 中存储的数据（一个字节）。本小节我们来介绍下 CPU 是如何访问内存的：</p><p><img src="/wp-content/uploads/2023/12/image-55-1024x455.png"></p><p>CPU 与内存之间的数据交互是通过总线（bus）完成的，而数据在总线上的传送是通过一系列的步骤完成的，这些步骤称为总线事务（bus transaction）。</p><p>其中数据从内存传送到 CPU 称之为读事务（read transaction），数据从 CPU 传送到内存称之为写事务（write transaction）。</p><p>总线上传输的信号包括：地址信号，数据信号，控制信号。其中控制总线上传输的控制信号可以同步事务，并能够标识出当前正在被执行的事务信息：</p><ul><li>当前这个事务是到内存的？还是到磁盘的？或者是到其他 IO 设备的？</li><li>这个事务是读还是写？</li><li>总线上传输的地址信号（物理内存地址），还是数据信号（数据）？。</li></ul><blockquote><p><strong>这里大家需要注意总线上传输的地址均为物理内存地址</strong>。比如：在 MESI 缓存一致性协议中当 CPU core0 修改字段 a 的值时，其他 CPU 核心会在总线上嗅探字段 a 的<strong>物理内存地址</strong>，如果嗅探到总线上出现字段 a 的<strong>物理内存地址</strong>，说明有人在修改字段 a，这样其他 CPU 核心就会失效字段 a 所在的 cache line 。</p></blockquote><p>如上图所示，其中系统总线是连接 CPU 与 IO bridge 的，存储总线是来连接 IO bridge 和主存的。</p><p>IO bridge 负责将系统总线上的电子信号转换成存储总线上的电子信号。IO bridge 也会将系统总线和存储总线连接到IO总线（磁盘等IO设备）上。这里我们看到 IO bridge 其实起的作用就是转换不同总线上的电子信号。</p><h3 id="8-3-CPU-从内存读取数据过程"><a href="#8-3-CPU-从内存读取数据过程" class="headerlink" title="8.3 CPU 从内存读取数据过程"></a>8.3 CPU 从内存读取数据过程</h3><p>假设 CPU 现在需要将物理内存地址为 A 的内容加载到寄存器中进行运算。</p><blockquote><p>大家需要注意的是 CPU 只会访问虚拟内存，在操作总线之前，需要把虚拟内存地址转换为物理内存地址，总线上传输的都是物理内存地址，这里省略了虚拟内存地址到物理内存地址的转换过程，这部分内容笔者会在后续文章的相关章节详细为大家讲解，这里我们聚焦如果通过物理内存地址读取内存数据。</p></blockquote><p><img src="/wp-content/uploads/2023/12/image-55-4-1024x470.jpg"></p><p>首先 CPU 芯片中的总线接口会在总线上发起读事务（read transaction）。 该读事务分为以下步骤进行：</p><ol><li>CPU 将物理内存地址 A 放到系统总线上。随后 IO bridge 将信号传递到存储总线上。</li><li>主存感受到存储总线上的地址信号并通过存储控制器将存储总线上的物理内存地址 A 读取出来。</li><li>存储控制器通过物理内存地址 A 定位到具体的存储器模块，从 DRAM 芯片中取出物理内存地址 A 对应的数据 X。</li><li>存储控制器将读取到的数据 X 放到存储总线上，随后 IO bridge 将存储总线上的数据信号转换为系统总线上的数据信号，然后继续沿着系统总线传递。</li><li>CPU 芯片感受到系统总线上的数据信号，将数据从系统总线上读取出来并拷贝到寄存器中。</li></ol><p>以上就是 CPU 读取内存数据到寄存器中的完整过程。</p><p>但是其中还涉及到一个重要的过程，这里我们还是需要摊开来介绍一下，那就是存储控制器如何通过物理内存地址 A 从主存中读取出对应的数据 X 的？</p><p>接下来我们结合前边介绍的内存结构以及从 DRAM 芯片读取数据的过程，来总体介绍下如何从主存中读取数据。</p><h3 id="8-4-如何根据物理内存地址从主存中读取数据"><a href="#8-4-如何根据物理内存地址从主存中读取数据" class="headerlink" title="8.4 如何根据物理内存地址从主存中读取数据"></a>8.4 如何根据物理内存地址从主存中读取数据</h3><p>前边介绍到，当主存中的存储控制器感受到了存储总线上的地址信号时，会将内存地址从存储总线上读取出来。</p><p>随后会通过内存地址定位到具体的存储器模块。还记得内存结构中的存储器模块吗 ？</p><p><img src="/wp-content/uploads/2023/12/image-55-3-1024x596.jpg"></p><p>而每个存储器模块中包含了 8 个 DRAM 芯片，编号从 0 - 7 。</p><p><img src="/wp-content/uploads/2023/12/image-55-2-1024x535.jpg"></p><p>存储控制器会将<strong>物理内存地址</strong>转换为 DRAM 芯片中 supercell 在二维矩阵中的坐标地址(RAS，CAS)。并将这个坐标地址发送给对应的存储器模块。随后存储器模块会将 RAS 和 CAS 广播到存储器模块中的所有 DRAM 芯片。依次通过 (RAS，CAS) 从 DRAM0 到 DRAM7 读取到相应的 supercell 。</p><p><img src="/wp-content/uploads/2023/12/image-55-1-1024x644.jpg"></p><p>我们知道一个 supercell 存储了一个字节（ 8 bit ） 数据，这里我们从 DRAM0 到 DRAM7 依次读取到了 8 个 supercell 也就是 8 个字节，然后将这 8 个字节返回给存储控制器，由存储控制器将数据放到存储总线上。</p><p><strong>CPU 总是以 word size 为单位从内存中读取数据，在 64 位处理器中的 word size 为 8 个字节。64 位的内存每次只能吞吐 8 个字节。</strong></p><blockquote><p>CPU 每次会向内存读写一个 cache line 大小的数据（ 64 个字节），但是内存一次只能吞吐 8 个字节。</p></blockquote><p>所以在物理内存地址对应的存储器模块中，DRAM0 芯片存储第一个低位字节（ supercell ），DRAM1 芯片存储第二个字节，……依次类推 DRAM7 芯片存储最后一个高位字节。</p><p><img src="/wp-content/uploads/2023/12/image-55-1024x669.jpg"></p><p>由于存储器模块中这种由 8 个 DRAM 芯片组成的物理存储结构的限制，内存读取数据只能是按照物理内存地址，8 个字节 8 个字节地顺序读取数据。所以说内存一次读取和写入的单位是 8 个字节。</p><p><img src="/wp-content/uploads/2023/12/image-54-1024x480.png"></p><p>而且在程序员眼里连续的物理内存地址实际上在物理上是不连续的。因为这连续的 8 个字节其实是存储于不同的 DRAM 芯片上的。每个 DRAM 芯片存储一个字节（supercell）</p><h3 id="8-5-CPU-向内存写入数据过程"><a href="#8-5-CPU-向内存写入数据过程" class="headerlink" title="8.5 CPU 向内存写入数据过程"></a>8.5 CPU 向内存写入数据过程</h3><p>我们现在假设 CPU 要将寄存器中的数据 X 写到物理内存地址 A 中。同样的道理，CPU 芯片中的总线接口会向总线发起写事务（write transaction）。写事务步骤如下：</p><ol><li>CPU 将要写入的物理内存地址 A 放入系统总线上。</li><li>通过 IO bridge 的信号转换，将物理内存地址 A 传递到存储总线上。</li><li>存储控制器感受到存储总线上的地址信号，将物理内存地址 A 从存储总线上读取出来，并等待数据的到达。</li><li>CPU 将寄存器中的数据拷贝到系统总线上，通过 IO bridge 的信号转换，将数据传递到存储总线上。</li><li>存储控制器感受到存储总线上的数据信号，将数据从存储总线上读取出来。</li><li>存储控制器通过内存地址 A 定位到具体的存储器模块，最后将数据写入存储器模块中的 8 个 DRAM 芯片中。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们从虚拟内存地址开始聊起，一直到物理内存地址结束，包含的信息量还是比较大的。首先笔者通过一个进程的运行实例为大家引出了内核引入虚拟内存空间的目的及其需要解决的问题。</p><p>在我们有了虚拟内存空间的概念之后，笔者又近一步为大家介绍了内核如何划分用户态虚拟内存空间和内核态虚拟内存空间，并在次基础之上分别从 32 位体系结构和 64 位体系结构的角度详细阐述了 Linux 虚拟内存空间的整体布局分布。</p><ul><li>我们可以通过 <code>cat /proc/pid/maps</code> 或者 <code>pmap pid</code> 命令来查看进程用户态虚拟内存空间的实际分布。</li><li>还可以通过 <code>cat /proc/iomem</code> 命令来查看进程内核态虚拟内存空间的的实际分布。</li></ul><p>在我们清楚了  Linux 虚拟内存空间的整体布局分布之后，笔者又介绍了 Linux 内核如何对分布在虚拟内存空间中的各个虚拟内存区域进行管理，以及每个虚拟内存区域的作用。在这个过程中还介绍了相关的内核数据结构，近一步从内核源码实现角度加深大家对虚拟内存空间的理解。</p><p>最后笔者介绍了物理内存的结构，以及 CPU 如何通过物理内存地址来读写内存中的数据。这里笔者需要特地再次强调的是 CPU 只会访问虚拟内存地址，只不过在操作总线之前，通过一个地址转换硬件将虚拟内存地址转换为物理内存地址，然后将物理内存地址作为地址信号放在总线上传输，由于地址转换的内容和本文主旨无关，考虑到文章的篇幅以及复杂性，笔者就没有过多的介绍。</p><p>好了，本文的全部内容到这里就结束了，感谢大家的收看，我们下篇文章见~~~</p>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译生成libvirtd</title>
    <link href="/004.html"/>
    <url>/004.html</url>
    
    <content type="html"><![CDATA[<h1 id="源码下载与解压"><a href="#源码下载与解压" class="headerlink" title="源码下载与解压"></a>源码下载与解压</h1><p><img src="/uploads/2023/12/image-4-1024x185.png"></p><h1 id="配置编译选项"><a href="#配置编译选项" class="headerlink" title="配置编译选项"></a>配置编译选项</h1><p>mkdir build &amp;&amp; cd build</p><p>..&#x2F;configure –with-test-suite –enable-debug&#x3D;yes –with-qemu</p><h2 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h2><p>configure: error: You must install the gnutls &gt;&#x3D; 3.2.0 pkg-config module to compile libvirt</p><p>yum -y install gnutls-devel gnutls  </p><p>configure: error: libnl3-devel is required for macvtap support</p><p>yum -y install libnl3-devel</p><p>configure: error: Cannot find a XDR library</p><p>yum -y install libtirpc-devel</p><p>configure: error: YAJL 2 is required to build QEMU driver</p><p>yum install yajl-devel</p><p>configure: error: You must install device-mapper-devel&#x2F;libdevmapper to compile libvirt with mpath storage driver</p><p>yum install device-mapper-devel</p><h1 id="编译与安装"><a href="#编译与安装" class="headerlink" title="编译与安装"></a>编译与安装</h1><p>make &amp;&amp; make install</p><h1 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h1><p><img src="/wp-content/uploads/2023/12/image-39-1024x97.png"></p>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Armv8架构虚拟化介绍（转）</title>
    <link href="/027.html"/>
    <url>/027.html</url>
    
    <content type="html"><![CDATA[<h1 id="0-原文链接"><a href="#0-原文链接" class="headerlink" title="0 原文链接"></a>0 原文链接</h1><ul><li><a href="https://calinyara.github.io/technology/2019/11/03/armv8-virtualization.html">CALINYARA</a></li></ul><h1 id="1-综述"><a href="#1-综述" class="headerlink" title="1 综述"></a>1 综述</h1><p>本文描述了Armv8-A AArch64的虚拟化支持。包括stage 2页表转换，虚拟异常，以及陷阱。本文介绍了一些基础的硬件辅助虚拟化理论以及一些Hypervisor如何利用这些虚拟化特性的例子。文本不会讲述某一具体的Hypervisor软件是如何工作的以及如何开发一款Hypervisor软件（对具体实现感兴趣，请参考<a href="https://calinyara.github.io/technology/2023/02/25/aVisor.html">aVisor: 基于ARM架构的Hypervisor及操作系统实现</a>）。通过阅读本文，你可以学到两种类型的Hypervisor以及它们是如何映射到Arm的异常级别。你将能解释陷阱是如何工作的以及其是如何被用来进行各种模拟操作。你将能描述Hypervisor可以产生什么虚拟异常以及产生这些虚拟异常的机制。理解本文内容需要一定基础，本文假定你熟悉ARMv8体系结构的异常模型和内存管理。</p><h1 id="1-1-虚拟化简介"><a href="#1-1-虚拟化简介" class="headerlink" title="1.1 虚拟化简介"></a>1.1 虚拟化简介</h1><p>这里我们将介绍一些基础的Hypervisor和虚拟化的理论知识。如果你已经有一定的基础或是已经熟悉了这些概念，可以跳过这部分内容。我们用Hypervisor这个词来定义一种负责创建，管理以及调度虚拟机(Virtual Machines, VMs)的软件。</p><h2 id="虚拟化为什么重要"><a href="#虚拟化为什么重要" class="headerlink" title="虚拟化为什么重要"></a>虚拟化为什么重要</h2><p>虚拟化是一种在现代云计算和企业基础架构中广泛使用的技术。开发人员用虚拟机在一个硬件平台上运行多个不同的操作系统来开发和测试软件，以避免对主计算环境造成可能的破坏。虚拟化技术在服务器上非常流行，大多数面向服务器的处理器都需要支持虚拟化功能，这是因为虚拟化能给数据中心服务器带来如下一些需要的特性：</p><ul><li><strong>隔离</strong>：利用虚拟化可以对同一个物理核上运行的虚拟机进行隔离。这使得相互间不可信的的计算环境可以共享同一套硬件环境。例如，两个竞争对手可以共享同一个物理机器而又不能访问对方的数据。</li><li><strong>高可用性</strong>： 虚拟化可以在不同的物理机器之间无缝透明地迁移负载。这个技术广泛用于将负载从出错的硬件平台迁移至其他可用平台，以便维护和替换出错的硬件而不影响服务。</li><li><strong>负载均衡</strong>： 为了降低数据中心硬件和功耗成本，需要尽可能充分地利用硬件平台资源。将负载均衡地迁移到不同地物理机上，有利用充分利用物理机资源，降低功耗，同时为租户提供最佳性能。</li><li><strong>沙箱</strong>：虚拟机可以作为一个沙箱来为运行在其中的应用屏蔽其他软件的干扰，或者避免其干扰其他软件。例如在虚拟机中运行特定软件，可以避免该软件的bug或病毒导致物理机器上的其他软件损坏。</li></ul><h2 id="1-2-Hypervisor的两种类型"><a href="#1-2-Hypervisor的两种类型" class="headerlink" title="1.2 Hypervisor的两种类型"></a>1.2 Hypervisor的两种类型</h2><p>Hypervisor通常被分成两种类型，独立类型Type 1和寄生类型 Type 2。我们先看看Type 2类型的Hypervisor。对于Type 2类型的Hypervisor，其寄生的宿主操作系统拥有对硬件平台和资源（包括CPU和物理内存…）的全部控制权。下图展示了Type 2类型的Hypervisor。</p><p><img src="/wp-content/uploads/2023/12/image-36.png"></p><p>图1：Type 2 Hypervisor</p><p>宿主操作系统，指的是直接运行在硬件平台上并为Type 2类型的Hypervisor提供运行环境的操作系统。这类Hypervisor可以充分利用宿主操作系统对物理硬件的管理功能，而Hypervisor只需提供虚拟化相关功能即可。不知你是否使用过Virtual Box或是VMware Workstation, 这类软件就是Type 2类型的Hypervisor。</p><p>接下来，看看独立类型的Type 1 Hypervisor, 如图2。 这类Hypervisor没有宿主操作系统。其直接运行在物理硬件之上，直接管理各种物理资源，同时管理并运行客户机操作系统。</p><p><img src="/wp-content/uploads/2023/12/image-35.png"></p><p>图2：Type 1 Hypervisor</p><p>在开源社区常见的Hypervisor, Xen (Type 1) 和 KVM (Type 2)就分属这两种不同的类型。其他开源的或知识产权的Hypervisor，可参见 <a href="https://en.wikipedia.org/wiki/Comparison_of_platform_virtualization_software">WiKi</a>。</p><h2 id="1-3-全虚拟化和半虚拟化"><a href="#1-3-全虚拟化和半虚拟化" class="headerlink" title="1.3 全虚拟化和半虚拟化"></a>1.3 全虚拟化和半虚拟化</h2><p>关于虚拟机，经典定义是：虚拟机是一个独立的隔离的计算环境，这种计算环境让使用者看起来就像在使用真实的物理机器一样。尽管我们可以在基于ARM的硬件平台上模拟真实硬件，但这通常不是最有效的做法，因此我们常常不这么做。例如，模拟一个真实的以太网设备是非常慢的，这是因为对任何一个模拟寄存器的访问都会陷入到Hypervisor当中进行模拟。比起直接访问物理寄存器来说，这种操作的代价要昂贵得多。一个替代方案是修改客户操作系统，使之意识到自身运行在虚拟机当中，通过在Hypervisor中模拟一个虚拟设备来给客户机使用。以此来换取更好得I&#x2F;O性能。严格来说，全虚拟化需要完全模拟真实硬件，性能上会比较差。开源项目Xen推进了半虚拟化，通过修改客户机操作系统的核心部分使其更适合在虚拟环境中运行，以此来提高性能。</p><p>另一个使用半虚拟化的原因是早期的体系结构并不是为虚拟化而设计的，存在虚拟化漏洞。因为虚拟化要求所有敏感指令或访问敏感资源的指令都能被截获模拟。对于存在虚拟化漏洞的体系结构，则需要通过半虚拟化的方案来填补漏洞。而今，大多数体系机构都支持硬件辅助虚拟化，包括Arm。这使得操作系统的核心部分无需修改也能获得较好得性能。只有少数存储和网络相关的I&#x2F;O设备仍然采用半虚拟化的方案来改善性能，这类半虚拟化的方案如，virtio 和 Xen PV Bus。</p><h2 id="1-4-虚拟机（VM）和虚拟CPU-vCPU"><a href="#1-4-虚拟机（VM）和虚拟CPU-vCPU" class="headerlink" title="1.4 虚拟机（VM）和虚拟CPU (vCPU)"></a>1.4 虚拟机（VM）和虚拟CPU (vCPU)</h2><p>有必要区分虚拟机（VM）和虚拟CPU(vCPU)。这有利于理解本文的后续部分。例如，一个内存页面可以分配给一个虚拟机，因此所有属于该VM的vCPUs都可以访问它。而一个虚拟中断只是针对某个vCPU，因此只有该vCPU可以收到。虚拟机（VM）和虚拟CPU(vCPU)的关系如图3所示。</p><p><img src="/wp-content/uploads/2023/12/image-34-1024x420.png"></p><p>图3：VM vs vCPU</p><p><strong>注意</strong>：ARM体系结构定义了处理单元（Processing Element, PE）一词，现代CPU可能包含多个内核或线程，PE用来指代单一的执行单元。同样的这里的vCPU严格来说应该是vPE。</p><h1 id="2-AArch64的虚拟化"><a href="#2-AArch64的虚拟化" class="headerlink" title="2 AArch64的虚拟化"></a>2 AArch64的虚拟化</h1><p>对于ARMv8, Hypervisor运行在EL2异常级别。只有运行在EL2或更高异常级别的软件才可以访问并配置各项虚拟化功能。</p><ul><li><strong>Stage 2转换</strong></li><li><strong>EL1&#x2F;0指令和寄存器访问</strong></li><li><strong>注入虚拟异常</strong></li></ul><p>安全状态和非安全状态下的异常级别及可运行的软件如图4所示</p><p><img src="/wp-content/uploads/2023/12/image-33.png"></p><p>图4：AArch64的虚拟化</p><p><strong>注意</strong>：安全状态的EL2用灰色显示是因为，安全状态的EL2并不总是可用，这是Armv8.4-A引入的特性。</p><h2 id="2-1-Stage-2-转换"><a href="#2-1-Stage-2-转换" class="headerlink" title="2.1 Stage 2 转换"></a>2.1 Stage 2 转换</h2><h3 id="什么是Stage-2-转换"><a href="#什么是Stage-2-转换" class="headerlink" title="什么是Stage 2 转换"></a>什么是Stage 2 转换</h3><p>Stage 2 转换允许Hypervisor控制虚拟机的内存视图。具体来说，其可以控制虚拟机是否可以访问特定的某一块物理内存，以及该内存块出现在虚拟机内存空间的位置。这种能力对于虚拟机的隔离和沙箱功能来说至关重要。这使得虚拟机只能看到分配给它自己的物理内存。为了支持Stage 2 转换， 需要增加一个页表，我们称之为Stage 2页表。操作系统控制的页表转换称之为stage 1转换，负责将虚拟机视角的虚拟地址转换为虚拟机视角的物理地址。而stage 2页表由Hypervisor控制，负责将虚拟机视角的物理地址转换为真实的物理地址。虚拟机视角的物理地址在Armv8中有特定的词描述，叫中间物理地址(intermediate Physical Address, IPA)。</p><p>stage 2转换表的格式和stage 1的类似，但也有些属性的处理不太一样，例如,判断内存类型 是normal 还是 device的信息被直接编码进了表里，而不是通过查询MAIR_ELx寄存器。</p><p><img src="/wp-content/uploads/2023/12/image-32-1024x391.png"></p><p>图5：地址转换, VA to IPA to PA</p><h3 id="VMID"><a href="#VMID" class="headerlink" title="VMID"></a>VMID</h3><p>每一个虚拟机都被分配一个ID号，称之为VMID。这个ID号用于标记某个特定的TLB项属于哪一个VM。VMID使得不同的VM可以共享同一块TLB缓存。VMID存储在寄存器VTTBR_EL2中，可以是8或16比特，由VTCR_EL2.vs比特位控制，其中16比特的VMID支持是在armv8.1-A中扩展的，是可选的。需注意，EL2和EL3的地址转换不需要VMID标记，因为它们不需要stage 2转换。</p><h3 id="VMID-vs-ASID"><a href="#VMID-vs-ASID" class="headerlink" title="VMID vs ASID"></a>VMID vs ASID</h3><p>TLB项也可以用ASID(Address Space Identifier)标记，每个应用都被操作系统分配有一个ASID，所有属于同一个应用的TLB项都有相同的ASID。这使得不同应用可以共享同一块TLB缓存。每一个VM有它自己的ASID空间。例如两个不同的VMs同时使用ASID 5，但指的是不同的东西。对于虚拟机而言，通常VMID会结合ASID同时使用。</p><h3 id="属性整合和覆盖"><a href="#属性整合和覆盖" class="headerlink" title="属性整合和覆盖"></a>属性整合和覆盖</h3><p>stage 1 和 stage 2映射都包含属性，例如存储类型，访问权限等。内存管理单元（MMU）会将两个阶段的属性整合成一个最终属性，整合的原则是选择更有限制的属性。且看如下例子：</p><p><img src="/wp-content/uploads/2023/12/image-31-1024x251.png"></p><p>图6：映射属性整合</p><p>在上面的例子中，Device属性比起Normal属性更具限制性，因此最终结果是Device属性。同样的原理，如果你将顺序调换一下也不会改变最终的属性。</p><p>属性整合在大多数情况下都可以工作。但有些时候，例如在VM的早期启动阶段，Hypervisor希望改变默认的行为，则可以通过如下寄存器比特来实现。</p><ul><li>HCR_EL2.CD: 控制所有stage 1属性为Non-cacheable。</li><li>HCR_EL2.DC：强制所有stage 1属性为Normal，Write-Back Cacheable。</li><li>HCR_EL2.FWB (Armv8.4-A引入)：使用stage 2属性覆盖stage 1属性，而不是使用默认的限制性整合原则。</li></ul><h3 id="模拟MMIO"><a href="#模拟MMIO" class="headerlink" title="模拟MMIO"></a>模拟MMIO</h3><p>与物理机器的物理地址空间类似，VM的IPA地址空间包含了内存与外围设备两种区域。如下图所示</p><p><img src="/wp-content/uploads/2023/12/image-30.png"></p><p>图7：模拟MMIO</p><p>VM使用外围设备区域来访问其看到的物理外围设备，这其中包含了直通设备和虚拟外围设备。虚拟设备完全由Hypervisor模拟，如下图所示</p><p><img src="/wp-content/uploads/2023/12/image-29-1024x502.png"></p><p>图8：stage 2映射</p><p>一个直通设备被直接分配给VM并映射到IPA地址空间，这使得VM中的软件可用直接访问真实的物理硬件。一个虚拟的外围设备由Hypervisor模拟，其stage 2的转换项被标记为fault。虽然VM中的软件看来其是直接与物理设备交互，但实际上这一访问会导致stage 2转换fault，从而进入相应的异常处理程序由Hypervisor模拟。</p><p>为了模拟一个外围设备，Hypervisor需要知道哪一个外围设备被访问，外围设备的哪一个寄存器被访问，是读访问还是写访问，访问长度是多少，以及使用哪些寄存器来传送数据。</p><p>当处理stage 1 faults时，FAR_ELx寄存器包含了触发异常的虚拟地址。但虚拟地址不是给Hypervisor用的，Hypervisor通常不会知道客户操作系统如何配置虚拟地址空间的映射。对于stage 2 faults，有一个专门的寄存器HPFAR_EL2，该寄存器会报告发生错误的IPA地址。IPA地址空间由Hypervisor控制，因此可用利用此寄存器里的信息来进行必要的模拟。</p><p>ESR_ELx寄存器用于报告发生异常的相关信息。当loads或stores一个通用寄存器触发stage 2 fault时，相关异常信息由这些寄存器提供。这些信息包含了，访问的长度，访问的原地址或目的地址。Hypervisor可以以此来判断对虚拟外围设备访问的权限。下图展示了一个 <strong>陷入(trapping) – 模拟(emulating)</strong> 的访问过程。</p><p><img src="/wp-content/uploads/2023/12/image-28-1024x539.png"></p><p>图9：外围设备模拟</p><ol><li>VM里的软件尝试访问虚拟外围设备，这个例子当中是虚拟UART的接收FIFO。</li><li>该访问被stage 2转换block住，导致一个abort异常被路由到EL2。<ul><li>异常处理程序查询ESR_EL2关于异常的信息，如访问长度，目的寄存器，是load还是store操作。</li><li>异常处理程序查询HPFAR_EL2，取得发生abort的IPA地址。</li></ul></li><li>Hypervisor通过ESR_EL2和HPFAR_EL2里的相关信息对相关虚拟外围设备作模拟，模拟完成后通过ERET指令返回vCPU，并从发生异常的下一条指令继续执行。</li></ol><h3 id="系统内存管理单元-System-Memory-Management-Units-SMMUs"><a href="#系统内存管理单元-System-Memory-Management-Units-SMMUs" class="headerlink" title="系统内存管理单元(System Memory Management Units, SMMUs)"></a>系统内存管理单元(System Memory Management Units, SMMUs)</h3><p>到目前为止，我们只考虑了从处理器发起的各种访问。我们还需要考虑其他主设备如DMA控制器发起的访问。我们需要一种方法来扩展stage 2映射以保护这些主设备的地址空间。如果一个DMA控制器没有使用虚拟化，那它看起来应该如下图所示</p><p><img src="/wp-content/uploads/2023/12/image-27.png"></p><p>图10：没有虚拟化的DMA访问</p><p>DMA控制器通常由内核驱动编程控制。内核驱动会确保不违背操作系统层面的内存保护原则，即一个应用不能使用DMA访问其没有权限访问的其他应用的内存。</p><p>下面让我们考虑操作系统运行在虚拟机中的场景。</p><p><img src="/wp-content/uploads/2023/12/image-26.png"></p><p>图11：虚拟化下没有SMMU的DMA访问</p><p>在这个系统中，Hyperviosr通过stage 2映射来隔离不同VMs的地址空间。这是基于Hypervisor控制的stage 2映射表实现的。而驱动则直接与DMA控制器交互，这会产生两个问题：</p><ul><li><strong>隔离</strong>：DMA控制器访问在虚拟机之间没有了隔离，这破坏了虚拟机的沙箱功能。</li><li><strong>地址空间</strong>： 利用两级映射转换，使内核看到的PAs实际上是IPAs。但DMA控制器看到的仍然是PAs。因此DMA控制器和内核看到的是不同的地址空间，为了解决这个问题，每当VM与DMA控制器交互时就需要陷入到Hypervisor中做必要的转换。这种处理方式是极其没有效率的，且容易出错。</li></ul><p>解决的办法是将stage 2的机制推广到DMA控制器。这么做的话，这些主设备控制器也需要一个MMU，Armv8称之为SMMU（通常也称为IOMMU）。</p><p><img src="/wp-content/uploads/2023/12/image-25.png"></p><p>图12：虚拟化下通过SMMU的DMA访问</p><p>Hypervisor负责配置SMMU，以使DMA控制器看到的物理地址空间与kenrel看到的物理地址空间相同。这样就能解决上述两个问题。</p><h2 id="2-2-指令的陷入与模拟"><a href="#2-2-指令的陷入与模拟" class="headerlink" title="2.2 指令的陷入与模拟"></a>2.2 指令的陷入与模拟</h2><p>有时Hypervisor需要模拟一些操作，例如VM里运行的软件试图配置处理器的一些属性，如电源管理或是缓存一致性时。通常你不会允许VM直接配置这些属性，因为这会打破隔离性，从而影响其他VMs。这就需要通过以陷入的方式产生异常，在异常处理程序中做相应的模拟。Armv8包含一些陷入控制来帮助实现 **陷入(trapping) – 模拟(emulating)**。如果对相应操作配置了陷入，则这种操作发生时会陷入到更高的异常级别，便于Hypervisor模拟。</p><p>举个例子，执行等待中断指令<strong>WFI</strong>通过会使CPU进入低功耗状态。然而，当配置HCR_EL2.TWI&#x3D;&#x3D;1时，如果在EL0&#x2F;EL1执行<strong>WFI</strong>则会导致EL2的异常。 （<strong>注</strong>：陷入不是为虚拟化而设计的，有陷入到EL3和EL1的异常，但异常对虚拟化实现至关重要。）</p><p>对于 <strong>WFI</strong>的例子里， 操作系统通过在一个idle loop里执行 <strong>WFI</strong>指令，但虚拟机中的操作系统执行该指令时，会陷入到Hypervisor里模拟，这时Hypervisor通常会调度另一个vCPU执行。</p><p><img src="/wp-content/uploads/2023/12/image-24.png"></p><p>图13：WFI指令模拟</p><h2 id="2-3-寄存器的访问"><a href="#2-3-寄存器的访问" class="headerlink" title="2.3 寄存器的访问"></a>2.3 寄存器的访问</h2><p><strong>陷入 – 模拟</strong>的另一个用途是用来呈现虚拟寄存器的值。例如寄存器ID_AA64MMFR0_EL1是用来报告处理器内存相关特性的，操作系统可能会读取该寄存器来决定在内核中开启或关闭某些特性。Hypervisor可能会给VM呈现一个与实际物理寄存器不同的值。这是怎么实现的呢？首先Hypervisor需要开启对该寄存器读操作的陷入。然后，在陷入的异常处理中判断异常相关的信息并进行模拟。在如下例子中，就是设置一个虚拟的值，然后ERET返回。</p><p><img src="/wp-content/uploads/2023/12/image-23-1024x578.png"></p><p>图14：寄存器访问的陷入模拟</p><h3 id="避免陷入"><a href="#避免陷入" class="headerlink" title="避免陷入"></a>避免陷入</h3><p><strong>陷入 – 模拟</strong> 的开销是很大的。这种操作需要先陷入到EL2，然后由Hypervisor做相应模拟再返回客户操作系统。对于某些寄存器如 <strong>ID_AA64MMFR0_EL1</strong>，操作系统并不经常访问，<strong>陷入 – 模拟</strong>的开销还是可以接受的。但对于某些经常访问的寄存器以及性能敏感的代码，陷入太频繁会对系统性能造成很大影响。对于这些情况，我们需要尽可能地优化 <strong>陷入</strong>。</p><ul><li><strong>MIDR_EL1</strong>: 存有处理器类型信息</li><li><strong>MPIDR_EL1</strong>：亲和性配置</li></ul><p>Hypervisor可能希望在访问上述两个寄存器时不要总是陷入。对这些寄存器，Armv8提供了与其对应的不需要陷入的版本。Hypervisor可以在进入VM 时先配置好这些寄存器的值。当VM中读到 MIDR_EL1 &#x2F; MPIDR_EL1时会自动返回VPIDR_EL2 &#x2F; VMPIDR_EL2的值而不发生陷入。</p><ul><li><strong>VPIDR_EL2</strong>：读取 <strong>MIDR_EL1</strong>返回 <strong>VPIDR_EL2</strong>的值避免陷入</li><li><strong>VMPIDR_EL2</strong>：读取 <strong>MPIDR_EL1</strong>返回 <strong>VMPIDR_EL2</strong>的值避免陷入</li></ul><p>注意：VPIDR_EL2 &#x2F; VMPIDR_EL2 在硬件reset后没有初始化的值，它们必须由软件启动代码初始化一个合理的值。</p><h2 id="2-4-异常虚拟化"><a href="#2-4-异常虚拟化" class="headerlink" title="2.4 异常虚拟化"></a>2.4 异常虚拟化</h2><p>中断是硬件通知软件的机制，在一个使用虚拟化的系统中，中断处理会变得更为复杂。有些中断会由Hypervisor直接处理，有些中断被分配给了VM，需要由VM中的处理程序处理，并且还有可能在接收到这个中断时，对应的VM并没有被调度运行。这意味着我们不仅需要支持在EL2中直接处理中断，还需要一种机制能将收到的中断转发给相应VM的vCPU。Armv8提供了vIRQs, vFIQs, 和vSErrors来支持虚拟中断。这些中断的行为和物理中断（IRQs, FIQs, 和 SErrors）类似，只不过只有当系统运行在EL0&#x2F;1是才会收到，运行在EL2&#x2F;3是收不到虚拟中断的。</p><h3 id="开启虚拟中断"><a href="#开启虚拟中断" class="headerlink" title="开启虚拟中断"></a>开启虚拟中断</h3><p>虚拟中断也是根据中断类型控制的。为了发送虚拟中断到EL0&#x2F;1, Hypervisor需要设置 <strong>HCR_EL2</strong>中相应的中断路由比特位。例如，开启vIRQ，你需要设置 <strong>HCR_EL2.IMO</strong>， 这意味着物理IRQ中断将被发送到EL2，同时虚拟中断将被发送到EL1。理论上，Armv8可以配置成VM直接接收物理FIQs和虚拟IRQs。但在实际应用中，通常配置VM只接收虚拟中断。</p><h3 id="产生虚拟中断"><a href="#产生虚拟中断" class="headerlink" title="产生虚拟中断"></a>产生虚拟中断</h3><p>有两种方式产生虚拟中断</p><ol><li>配置HCR_EL2，由内部CPU核产生</li><li>使用GICv2及以上版本的外部中断控制器</li></ol><p>我们先来看第一种机制，HCR_EL2中有如下的控制比特位</p><ul><li><strong>VI</strong>: 配置vIRQ</li><li><strong>VF</strong>: 配置vFIQ</li><li><strong>VSE</strong>: 配置vSError<br>设置上述比特位等同于中断控制器向vCPU发送中断信号。和常规物理中断一样，虚拟中断受PSTATE控制。这种机制简单易用，但有个明显的缺点，需要由Hypervisor来模拟中断控制器的相关操作，一系列的 <strong>陷入 – 模拟</strong>将带来性能上的开销。</li></ul><p>第二种方式是使用Arm的通用中断控制器(Generic Interrupt Controller, GIC)来产生虚拟中断。从GICv2版本开始，GIC可以通过物理CPU interface 和 虚拟CPU interface发送物理中断和虚拟中断。见下图：</p><p><img src="/wp-content/uploads/2023/12/image-22-1024x395.png"></p><p>图15：GIC中断发送</p><p>这两个CPU interface是等同的，区别是一个发送物理中断信号，另一个发送虚拟中断信号。Hypervisor可以将虚拟CPU interface映射给VM，以便VM可以直接和GIC通信。这种方式的好处是Hypervisor只需建立映射，不需要做任何模拟，从而提升了性能。（<strong>PS：虚拟化性能提升的关键就在优化陷入，减少次数，优化流程</strong>）</p><h3 id="中断转发给vCPU的例子"><a href="#中断转发给vCPU的例子" class="headerlink" title="中断转发给vCPU的例子"></a>中断转发给vCPU的例子</h3><p>上面介绍了虚拟中断是如何开启和生产的。让我们来看一个中断转发给vCPU的例子。考虑一个物理外围设备，该设备被分配给了某个VM，如下图所示：</p><p><img src="/wp-content/uploads/2023/12/image-21-1024x449.png"></p><p>图16：虚拟中断转发的例子</p><p>具体步骤如下：</p><ol><li>物理外围设备发送中断信号给GIC。</li><li>GIC产生物理中断异常，可能是IRQ或FIQ。由于配置了HCR_EL2.IMO&#x2F;FMO，这些异常会被路由到EL2。Hyperviosr发现该设备已被分配给了某个VM，于是检查需要将该中断信号转发给哪个vCPU。</li><li>Hypervisor配置了GIC将该物理中断以虚拟中断的形式转给某个vCPU。GIC于是发送vIRQ&#x2F;vFIQ信号，如果此时还运行在EL2，这些信号会被忽略。</li><li>Hypervisor将控制权返还给vCPU。</li><li>处理器运行在EL0或EL1，来自GIC的虚拟中断被接收（受PSTATE控制）。</li></ol><p>上面的例子展示了如何将一个物理中断以虚拟中断的形式转发给VM。如果是一个没有物理中断对应的纯虚拟中断，Hypervisor可以直接注入虚拟中断。</p><h3 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h3><p>我们知道中断屏蔽比特位PSTATE.I, PSTATE.F, PSTATE.A分别对应IRQs, FIQs和SErrors。如果运行在虚拟化环境中，这些比特位的工作方式有些许不同。</p><p>例如，对于IRQs，设置HCR_EL2.IMO意味着</p><ul><li>物理IRQ路由至EL2</li><li>对EL0&#x2F;EL1开启vIRQs</li></ul><p>这同时也改变了PSTATE.I 屏蔽的含义， 当运行在EL0&#x2F;EL1是，如果 HCR_E2.IMO&#x3D;&#x3D;1, PSTATE.I针对的是虚拟的vIRQs而非物理的pIRQs。</p><h2 id="2-5-时钟虚拟化"><a href="#2-5-时钟虚拟化" class="headerlink" title="2.5 时钟虚拟化"></a>2.5 时钟虚拟化</h2><p>Arm体系结构中，每个处理器上都有一组通用时钟。通用时钟由一组比较器组成，用来与系统计数器比较。当比较器的值小于等于系统计数器时便会产生时钟中断。在下图中，我们可以看到系统中通用时钟由黄色框部分组成。</p><p><img src="/wp-content/uploads/2023/12/image-20-1024x189.png"></p><p>图17：通用时钟比较器与系统计数模块</p><p>下图展示了虚拟化系统中运行两个vCPU的时序。</p><p><img src="/wp-content/uploads/2023/12/image-19-1024x289.png"></p><p>图18：Hypervisor运行有两个vCPU的时序</p><p>物理世界的时间（墙上时间）4ms里，每个vCPU各运行了2ms。如果我们设置vCPU0的比较器在T&#x3D;0之后的3ms产生一个中断，那么你希望实际在哪个墙上时间点产生中断呢？是vCPU0的虚拟时间的2ms，也就是墙上时间3ms那个点还是 vCPU0虚拟时间3ms的那个点？</p><p>实际上，Arm体系结构同时支持上述两种设置，这取决于你使用何种虚拟化方案。让我们看看这是如何实现的。</p><p>运行在vCPU上的软件可以访问如下两种时钟</p><ul><li>EL1物理时钟</li><li>EL1虚拟时钟</li></ul><p>EL1物理时钟会与系统计数器模块直接比较，使用的是绝对的墙上时间。而EL1虚拟时钟与虚拟计数器比较。虚拟计数器是在物理计数器的基础上减去一个偏移。Hypervisor负责为当前调度运行的vCPU指定对应的偏移寄存器。这种方式使得虚拟时间只会覆盖vCPU实际运行的那部分时间。</p><p><img src="/wp-content/uploads/2023/12/image-18.png"></p><p>图19：虚拟计数器的计算</p><p>下图展示了虚拟时间运作的原理</p><p><img src="/wp-content/uploads/2023/12/image-17-1024x440.png"></p><p>图20：虚拟时间原理</p><p>在一个6ms的时段里，每个vCPU分别运行了3ms。Hypervisor可以使用偏移寄存器来将vCPU的时间调整为其实际运行的时间。</p><h2 id="2-6-虚拟化主机扩展（Virtualization-Host-Extensions-VHE"><a href="#2-6-虚拟化主机扩展（Virtualization-Host-Extensions-VHE" class="headerlink" title="2.6 虚拟化主机扩展（Virtualization Host Extensions, VHE)"></a>2.6 虚拟化主机扩展（Virtualization Host Extensions, VHE)</h2><p>图21显示了一个Type 1类型的虚拟化系统的软件栈与异常级别的对应关系，Hypervisor部分运行在EL2，VMs运行在EL0&#x2F;1。</p><p><img src="/wp-content/uploads/2023/12/image-16.png"></p><p>图21：Type 1虚拟化系统软件栈与异常级别</p><p>然而，对于一个Type 2类型的系统，其软件栈与异常级别的对应关系可能如图22所示</p><p><img src="/wp-content/uploads/2023/12/image-15-1024x787.png"></p><p>图22：VHE之前的Type 2虚拟化系统软件栈与异常级别</p><p>通常，寄主操作系统的内核部分运行在EL1，控制虚拟化的部分运行在EL2。然而，这种设计有一个明显的问题。VHE之前的Hypervisor通常需要设计成high-visor和low-visor两部分，前者运行在EL1，后者运行在EL2。分层设计在系统运行时会造成很多不必要的上下文切换，带来不少设计上的复杂性和性能开销。为了解决这个问题，虚拟化主机扩展 （Virtualization Host Extensions, VHE）应运而生。该特性由Armv8.1-A引入，可以让寄主操作系统的内核部分直接运行在EL2上。</p><h3 id="将主机操作系统运行在EL2"><a href="#将主机操作系统运行在EL2" class="headerlink" title="将主机操作系统运行在EL2"></a>将主机操作系统运行在EL2</h3><p>VHE由系统寄存器 <strong>HCR_EL2</strong>中的两个比特位控制</p><ul><li><strong>E2H</strong>：VHE使能位</li><li><strong>TGE</strong>：当VHE使能时，控制EL0是Guest还是Host</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">         Running in         E2H  TGE </span><br><span class="hljs-section">-------------------------------------</span><br>Guest kernel (EL1)           1    0  <br>Guest application (EL0)      1    0   <br>Host kernel (EL2)            1    1* <br>Host application (EL0)       1    1  <br></code></pre></td></tr></table></figure><p><strong>*</strong> 当发生异常从VM退出到Hypervisor时，TGE将会初始化为0，软件需要先设置这一比特，再继续运行host kernel的主代码</p><p>一个典型的配置如下图</p><p><img src="/wp-content/uploads/2023/12/image-14-1024x646.png"></p><p>图23：E2H与TGE配置</p><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>在VHE引入之前，EL0&#x2F;1的虚拟地址空间看起来如下。EL0&#x2F;1分两块区域，上面是内核空间，下面是用户空间。EL2只有一个空间，Hypervisor通常不需要运行应用，因此没有必要划分内核与用户空间。同理，EL0&#x2F;1虚拟地址空间支持ASID，但EL2不需要支持。</p><p><img src="/wp-content/uploads/2023/12/image-13-1024x509.png"></p><p>图24：VHE之前的虚拟地址空间</p><p>当VHE引入之后，EL2可以直接运行操作系统代码。因此需要将地址空间划分和ASID的支持添加进来。同样，通过设置 <strong>HCR_EL2.E2H</strong>来解决。</p><p><img src="/wp-content/uploads/2023/12/image-12-954x1024.png"></p><p>图25：开启E2H时的EL2虚拟地址空间</p><p>当运行在EL0时，HCR_EL2.TGE控制使用EL1还是EL2空间，当应用运行在Guest OS (TGE&#x3D;&#x3D;0)为前者，运行在Host OS（TGE&#x3D;&#x3D;1）为后者。</p><h3 id="重定向寄存器访问"><a href="#重定向寄存器访问" class="headerlink" title="重定向寄存器访问"></a>重定向寄存器访问</h3><p>除了会使用不同的地址空间映射，VHE还有一个问题需要解决，那就寄存器访问。运行在EL2的内核仍然会尝试访问*_EL1的寄存器。为了运行无需修改的内核，我们需要将EL1的寄存器重定向到EL2。当你设置E2H后，这一切就会由硬件实现。</p><p><img src="/wp-content/uploads/2023/12/image-11-1024x158.png"></p><p>图26：E2H对系统寄存器访问的影响</p><p>但是，重定向又会带来一个新的问题，那就是Hypervisor完全可能在某些情况下，例如当执行任务切换时， 访问真正EL1的寄存器。为了解决这个问题，Arm架构引入了一种新的别名机制，以_EL12或_EL02结尾。如下例，就可以在ECH&#x3D;&#x3D;1的EL2访问TTBR0_EL1。</p><p><img src="/wp-content/uploads/2023/12/image-10-1024x61.png"></p><p>图27：从EL2访问EL1寄存器</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>通常系统寄存器 <strong>HCR_EL2.IMO&#x2F;FMO&#x2F;AMO</strong>的这几个比特位可以用来控制物理异常被路由至EL1或EL2。当运行在EL0且TGE&#x3D;&#x3D;1时，HCR_EL2路由比特将会被忽略，所有物理异常（除了那些由SCR_EL3控制的会被路由至EL3）全部路由到EL2。这是因为Host OS里运行的应用是Host OS的一部分，而Host OS运行在EL2。</p><h2 id="2-7-嵌套虚拟化"><a href="#2-7-嵌套虚拟化" class="headerlink" title="2.7 嵌套虚拟化"></a>2.7 嵌套虚拟化</h2><p>Hypervisor可以运行在VM中，这称之为嵌套虚拟化。</p><p><img src="/wp-content/uploads/2023/12/image-9-1024x549.png"></p><p>图28：嵌套虚拟化</p><p>我们将第一个Hypervisor称为Host Hypervisor，VM中运行的Hypervisor称为Guest Hypervisor。</p><p>在Armv8.3-A之前，Guest Hypervisor可以运行在EL0。但这种设计需要大量软件模拟，不仅软件开发困难，性能也很差。Armv8.3-A增加了一些新的特性，可以让Guest Hypervisor运行在EL1。而Armv8.4-A引入的一些新特性，使得这一过程更有效率，虽然仍然需要Host Hypervisor参与做一些额外的工作。</p><h3 id="Guest-Hypervisor访问虚拟化控制接口"><a href="#Guest-Hypervisor访问虚拟化控制接口" class="headerlink" title="Guest Hypervisor访问虚拟化控制接口"></a>Guest Hypervisor访问虚拟化控制接口</h3><p>我们并不希望Guest Hypervisor能直接访问虚拟化控制接口，因为这么做会破坏VM的沙箱机制，使得虚拟机能够看到Host平台的信息。当Guest Hypervisor运行在EL1，并访问虚拟化控制接口时，<strong>HCR_EL2</strong>中新的控制比特位可以使这些操作陷入到Host Hypervisor(EL2)以便模拟。</p><ul><li><strong>HCR_EL2.NV</strong>：开启硬件辅助嵌套虚拟化</li><li><strong>HCR_EL2.NV1</strong>：开启额外需要陷入的操作</li><li><strong>HCR_EL2.NV2</strong>：开启重定向到内存</li><li><strong>VNCR_EL2</strong>：当NV2&#x3D;&#x3D;1时，指向一个内存中的结构体</li></ul><p>Armv8.3-A添加了NV和NV1控制比特。在此之前，从EL1访问*_EL2寄存器时的行为是未定义的，通常是会产生一个EL1的异常。而控制比特NV和NV1使得这种访问可以被陷入到EL2。这就使得Guest Hypervisor可以运行在EL1，同时由运行在EL2的Host Hypervisor来模拟这些操作。NV还会导致EL1运行ERET陷入到EL2。</p><p>下图展示了Guest Hypervisor如何创建并启动虚拟机</p><p><img src="/wp-content/uploads/2023/12/image-8-1024x589.png"></p><p>图29：Guest Hypervisor创建并启动虚拟机</p><ol><li>从EL1访问*_EL2寄存器将导致Guest Hypervisor陷入到EL2。Host Hypervisor记录Guest Hypervisor创建的相关配置。</li><li>Guest Hypervisor尝试进入其创建的虚拟机，此时ERET指令会陷入到EL2。</li><li>Host Hypervisor根据Guest Hypervisor的配置，设置相关寄存器以便启动VM，清理掉NV比特位，最后进入Guest Hypervisor创建的Guest运行。</li></ol><p>按上述的方法， 在Guest Hypervisor访问任何一个*_EL2寄存器时都会发生陷入。切换操作如 任务切换，vCPU切换，VMs切换都会访问大量寄存器，每次陷入都会导致异常的进入与返回，从而带来严重的 <strong>陷入 – 模拟</strong>性能问题。（回忆前面的内容， <strong>虚拟化性能提升的关键就在优化陷入，减少次数，优化流程</strong>）。Armv8.4-A提供了一个更好的方案，当NV2被设置时，从EL1访问*_EL2寄存器将会被重定向到一块内存区域。Guest Hypervisor可以多次读写这块寄存器区域而不发生陷入。只有当最后运行ERET时，才会陷入到EL2。而后，Host Hypervisor可以从该内存区域中提取相关配置并代Guest Hypervisor执行相关操作。</p><p><img src="/wp-content/uploads/2023/12/image-7-1024x446.png"></p><p>图30：Guest Hypervisor创建并启动虚拟机优化</p><ol><li>从EL1访问*_EL2寄存器将会被重定向到一块内存区域，该内存区域的地址由Host Hypervisor在 <strong>VNCR_EL2</strong>中指定。</li><li>Guest Hypervisor尝试进入其创建的虚拟机，此时ERET指令会陷入到EL2</li><li>Host Hypervisor从内存中提取配置信息，设置相关寄存器，以便启动VM，清理掉NV比特位，最后进入Guest Hypervisor创建的Guest运行。</li></ol><p>这个改进方法相比之前的方法会减少陷入到Host Hypervisor的次数，从而提升了性能。</p><h2 id="2-8-安全世界虚拟化"><a href="#2-8-安全世界虚拟化" class="headerlink" title="2.8 安全世界虚拟化"></a>2.8 安全世界虚拟化</h2><p>虚拟化扩展最早是在Armv7-A引入的。在Armv7-A中的Hyp模式等同于AArch32中的EL2，仅仅在非安全世界才存在。作为一个可选特性，Armv8.4-A增加了安全世界下EL2的支持。支持安全世界EL2的处理器，需配置EL3下的SCR_EL3.EEL2比特位来开启这一特性。设置了这一比特位，才允许使用安全状态下的虚拟化功能。</p><p>在安全世界虚拟化之前，EL3通常用于运行安全状态切换软件和平台固件。然而从设计上来说，我们希望EL3中运行的软件越少越好，因为越简单才会更安全。安全状态虚拟化使得我们可以将平台固件移到EL1中运行，由虚拟化来隔离平台固件和可信操作系统内核。下图展示了这一理念</p><p><img src="/wp-content/uploads/2023/12/image-6-1024x671.png"></p><p>图31：安全世界的虚拟化</p><h3 id="安全EL2与两个IPA空间"><a href="#安全EL2与两个IPA空间" class="headerlink" title="安全EL2与两个IPA空间"></a>安全EL2与两个IPA空间</h3><p>Arm体系结构定义了安全世界和非安全世界两个物理地址空间。在非安全状态下，stage 1转换的的输出总是非安全的，因此只需要一个IPA空间来给stage 2使用。然而，对于安全世界，stage 1的输出可能是安全的也能是非安全的。Stage 1转换表中的NS比特位控制使用安全地址还是非安全地址。这意味着在安全世界，需要两个IPA地址空间。</p><p><img src="/wp-content/uploads/2023/12/image-5-1024x454.png"></p><p>图32：安全世界的IPA地址空间</p><p>与stage 1表不同，stage 2转换表中没有NS比特位。因为对于一个特定的IPA空间，要么全都是安全地址，要么全都是非安全的，因此只需要由一个寄存器比特位来确定IPA空间。通常来说，非安全地址经过stage 2转换仍然是非安全地址，安全地址经过stage 2转换仍然是安全地址。</p><h1 id="3-虚拟化的损耗"><a href="#3-虚拟化的损耗" class="headerlink" title="3 虚拟化的损耗"></a>3 虚拟化的损耗</h1><p>虚拟化的损耗主要在于虚拟机和Hypervisor切换需要保存和恢复寄存器。Armv8系统中，最少需要对如下寄存器做处理</p><ul><li>31 x 64-bit通用寄存器(x0…x30)</li><li>32 x 128-bit浮点&#x2F;SIMD寄存器(V0…V31)</li><li>两个栈寄存器(SP_EL0, SP_EL1)</li></ul><p>使用LDP和STP指令，Hypervisor需要运行33条指令来存储和恢复这些寄存器。虚拟化最终的损耗不仅取决于硬件还取决于Hypervisor的设计。</p>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内核编译错误：BTF: .tmp_vmlinux.btf: pahole (pahole) is not available</title>
    <link href="/021.html"/>
    <url>/021.html</url>
    
    <content type="html"><![CDATA[<p><img src="/wp-content/uploads/2023/12/image.png"></p><p><img src="/wp-content/uploads/2023/12/image-1.png"></p>]]></content>
    
    
    <categories>
      
      <category>内核开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于QCOW2镜像的相关操作</title>
    <link href="/009.html"/>
    <url>/009.html</url>
    
    <content type="html"><![CDATA[<hr><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">关于QCOW2镜像的操作，现在主要掌握为以下：<br>+ 镜像的创建：qemu-<span class="hljs-selector-tag">img</span> create -f qcow2 xxx<span class="hljs-selector-class">.qcow2</span> \&lt;size\&gt;;<br>+ 镜像的扩容 ：qemu-<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">resize</span> xxx<span class="hljs-selector-class">.qcow2</span> \&lt;size\&gt;;<br></code></pre></td></tr></table></figure><hr><h1 id="1-QCOW2镜像快照实验"><a href="#1-QCOW2镜像快照实验" class="headerlink" title="1 QCOW2镜像快照实验"></a>1 QCOW2镜像快照实验</h1><h2 id="1-1-创建快照"><a href="#1-1-创建快照" class="headerlink" title="1.1 创建快照"></a>1.1 创建快照</h2><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/20231130195243.png"></p><h2 id="1-2-文件修改"><a href="#1-2-文件修改" class="headerlink" title="1.2 文件修改"></a>1.2 文件修改</h2><p>创建了一个文件如下：</p><p><img src="/wp-content/uploads/2023/12/image-37.png"></p><hr><h2 id="1-3-快照回退"><a href="#1-3-快照回退" class="headerlink" title="1.3 快照回退"></a>1.3 快照回退</h2><p>在虚拟机启动命令加入：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attr">--loadvm</span> openEuler_test_bak1130<span class="hljs-selector-class">.qcow2</span><span class="hljs-selector-class">.snap</span> <span class="hljs-comment">//参数为快照名</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/20231130204115.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/20231130204403.png"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">从上述我们可以推断：大概对于镜像或者说磁盘所作镜像应该是无法直接针对于虚拟机这个实体进行回退，应当还是从磁盘入手<br></code></pre></td></tr></table></figure><hr><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//该命令用于回退磁盘openEuler_test_bak1130.qcow2到openEuler_test_bak1130.qcow2.snap镜像</span><br>qemu-<span class="hljs-selector-tag">img</span> snapshot -<span class="hljs-selector-tag">a</span> openEuler_test_bak1130<span class="hljs-selector-class">.qcow2</span><span class="hljs-selector-class">.snap</span> openEuler_test_bak1130.qcow2<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/20231130211211.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/20231130211150.png"></p><p>可以看到，虚拟机正常启动。且之前创建的测试文件已经消失，回退成功；但是这种快照方法仅仅支持虚拟机关机然后对于磁盘镜像文件快照，无法在虚拟机运行时刻快照，应该其另有命令</p><hr><h2 id="1-4-删除快照"><a href="#1-4-删除快照" class="headerlink" title="1.4 删除快照"></a>1.4 删除快照</h2><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/20231130211842.png"></p>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于解决创建虚拟机时GTK初始化失败与vscode一直显示打开远程</title>
    <link href="/006.html"/>
    <url>/006.html</url>
    
    <content type="html"><![CDATA[<h1 id="宿主机安装桌面"><a href="#宿主机安装桌面" class="headerlink" title="宿主机安装桌面"></a>宿主机安装桌面</h1><p><a href="https://docs.openeuler.org/zh/docs/22.03_LTS_SP2/docs/desktop/%E5%AE%89%E8%A3%85UKUI.html">安装UKUI</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">yum -y install ukui<br><span class="hljs-comment">//安装后重启</span><br><span class="hljs-keyword">init</span> <span class="hljs-number">5</span> <span class="hljs-comment">//切换到图形界面</span><br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/12/image-41.png"></p><hr><h2 id="打开X11转发"><a href="#打开X11转发" class="headerlink" title="打开X11转发"></a>打开X11转发</h2><p>修改文件 &#x2F;etc&#x2F;ssh&#x2F;sshd_config ，作如下修改</p><p><img src="/wp-content/uploads/2023/12/image-43.png"></p><p>那么在使用MobaXterm连接会显示 ：</p><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/20231130115620.png"></p><p><img src="/wp-content/uploads/2023/12/image-42.png"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">该操作主要是解决gtk初始化失败<span class="hljs-comment">;也可以解决vscode远程一直显示：打开远程</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于EFI文件加载与运行探究</title>
    <link href="/008.html"/>
    <url>/008.html</url>
    
    <content type="html"><![CDATA[<hr><p>在上个实验中，我们着手编辑了一个我们自己的.efi应用程序，并且成功地在UEFI shell中运行，具体可参照：[[Linux启动管理&#x2F;UEFI&#x2F;02 UEFI实验&#x2F;ArmVirtQemu平台下实现一个简单.efi程序ArmVirtQemu平台下实现一个简单.efi程序]]</p><p>接下来，我们来简单地探索一下该HongHai.efi文件是如何因其符合UEFI的种种规范以至于其能够正确地运行</p><hr><h1 id="1-efi文件的编译过程"><a href="#1-efi文件的编译过程" class="headerlink" title="1 .efi文件的编译过程"></a>1 .efi文件的编译过程</h1><p><img src="/wp-content/uploads/2023/12/image-38-1024x114.png"></p><p>上述过程是由uefi-tools工具自动完成，需要注意的有两点：</p><ul><li>c文件编译成为目标文件以及obj目标文件经过链接成为dll文件，其中的配置选项在 <code>test.inf</code> 工程文件中，该文件类似于Makefile文件</li><li>GenFw工具是一个用于生成UEFI固件文件的工具，它是EDK II开发环境中的一部分。GenFw工具将UEFI模块和相关资源打包成一个可执行的固件文件</li></ul><hr><h1 id="2-efi文件加载与运行"><a href="#2-efi文件加载与运行" class="headerlink" title="2 efi文件加载与运行"></a>2 efi文件加载与运行</h1><p>下面的函数的作用是加载与执行efi文件的内存映像;</p><p>！！！下列的函数实现的寻找以LoadImage为例，其他函数思路一致！！！</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//internal worker function to load and run an image via device path.</span><br><span class="hljs-comment">///root/edk2/ShellPkg/Application/Shell/ShellProtocol.c</span><br>EFI_STATUS<br>InternalShellExecuteDevicePath (<br>  <span class="hljs-keyword">IN</span> <span class="hljs-keyword">CONST</span> EFI_HANDLE                *ParentImageHandle,<br>  <span class="hljs-keyword">IN</span> <span class="hljs-keyword">CONST</span> EFI_DEVICE_PATH_PROTOCOL  *DevicePath,<br>  <span class="hljs-keyword">IN</span> <span class="hljs-keyword">CONST</span> CHAR16                    *CommandLine OPTIONAL,<br>  <span class="hljs-keyword">IN</span> <span class="hljs-keyword">CONST</span> CHAR16                    **Environment OPTIONAL,<br>  <span class="hljs-keyword">OUT</span> EFI_STATUS                     *StartImageStatus OPTIONAL<br>  )<br>&#123;<br><span class="hljs-comment">//……</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="2-1-efi加载入内存"><a href="#2-1-efi加载入内存" class="headerlink" title="2.1 .efi加载入内存"></a>2.1 .efi加载入内存</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">//......</span><br><span class="hljs-comment">// Load the image with:</span><br>  <span class="hljs-comment">// FALSE - not from boot manager and NULL, 0 being not already in memory</span><br>  <span class="hljs-comment">//1. 将 UefiMain.efi文件加载到内存，生成工mage 对象，NewHandle是这个对象的句柄</span><br>  S<span class="hljs-attr">tatus</span> <span class="hljs-operator">=</span> gBS-&gt;LoadImage (<br>                  FALSE,<br>                  *ParentImageHandle,<br>                  (EFI_DEVICE_PATH_PROTOCOL *)DevicePath,<br>                  NULL,<br>                  <span class="hljs-number">0</span>,<br>                  <span class="hljs-variable">&amp;</span>NewHandle<br>                  )<span class="hljs-punctuation">;</span><br><span class="hljs-comment">//2. 取得命令行参数，并将命令行参数交给UefiMain.efi的 Image 对象，即NewHanale</span><br><span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span>S<span class="hljs-attr">tatus</span> <span class="hljs-operator">=</span> gBS-&gt;OpenProtocol (<br><span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> NewHandle,<br><span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;</span>gEfiLoadedImageProtocolGuid,<br><span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> (VOID **)<span class="hljs-variable">&amp;</span>LoadedImage,<br><span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> gImageHandle,<br><span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> NULL,<br><span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> EFI_OPEN_PROTOCOL_GET_PROTOCOL<br><span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> <span class="hljs-variable">&amp;nbsp</span><span class="hljs-punctuation">;</span> )<span class="hljs-punctuation">;</span><br><span class="hljs-comment">//启动所加载的Image</span><br><span class="hljs-comment">//StartImage 的主要作用是找出可执行程序映像（Image）的人口函数并执行</span><br><span class="hljs-comment">//找到的人口函数。gBS-&gt;Startrmage 是个函数指针，它实际指向CoreStartImage 函数。</span><br>if (!EFI_ERROR (Status)) <span class="hljs-punctuation">&#123;</span><br>      StartS<span class="hljs-attr">tatus</span> <span class="hljs-operator">=</span> gBS-&gt;StartImage (<br>                           NewHandle,<br>                           <span class="hljs-number">0</span>,<br>                           NULL<br>                           )<span class="hljs-punctuation">;</span><br>      if (StartImageStatus != NULL) <span class="hljs-punctuation">&#123;</span><br>        *StartImageS<span class="hljs-attr">tatus</span> <span class="hljs-operator">=</span> StartS<span class="hljs-attr">tatus</span><span class="hljs-punctuation">;</span><br>      <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>其中gBS是UEFI提供的系统表的BootService服务实例，用户可以通过该变量访问系统表中提供的Protocol，其定义在文件：“&#x2F;root&#x2F;edk2&#x2F;MdePkg&#x2F;Library&#x2F;UefiBootServicesTableLib&#x2F;UefiBootServicesTableLib.c”</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">EFI_HANDLE         gImageHandle = <span class="hljs-keyword">NULL</span>;<br>EFI_SYSTEM_TABLE   <span class="hljs-comment">*gST         = NULL;</span><br>//实例化的系统表中BOOT_SERVVICES服务，用户可以通过该变量访问提供的Protocol<br>EFI_BOOT_SERVICES <span class="hljs-variable">&amp;nbsp</span>;<span class="hljs-comment">*gBS &amp;nbsp;</span> <span class="hljs-variable">&amp;nbsp</span>; <span class="hljs-variable">&amp;nbsp</span>; <span class="hljs-variable">&amp;nbsp</span>; = <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><p>在启动服务中存在以下服务：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//</span><br>type struct&#123;<br><span class="hljs-comment">//其中元素均为函数指针</span><br><span class="hljs-comment">// Image Services</span><br>  <span class="hljs-comment">//镜像服务-&gt;efi文件加载到内存的image服务</span><br>  <span class="hljs-comment">//这也就意味着grub.efi被加载到内存时也是该Protocol提供支持</span><br>  <span class="hljs-comment">//......</span><br>  EFI_IMAGE_LOAD                                LoadImage;<br>  EFI_IMAGE_START                               StartImage;<br>  EFI_EXIT                                      Exit;<br>  EFI_IMAGE_UNLOAD                              UnloadImage;<br>  EFI_EXIT_BOOT_SERVICES                        ExitBootServices;<br>  <span class="hljs-comment">//......</span><br>&#125;EFI_BOOT_SERVICES;<br><span class="hljs-comment">//***********************************************************************</span><br><span class="hljs-comment">///root/edk2/MdePkg/Include/Uefi/UefiSpec.h</span><br><span class="hljs-comment">/*下面是该LoadImage函数的原型定义</span><br><span class="hljs-comment">*可以看出，上面的映像加载函数是其调用</span><br><span class="hljs-comment">*/</span><br>typedef<br><span class="hljs-title function_ invoke__">EFI_STATUS</span><br>(EFIAPI *EFI_IMAGE_LOAD)(<br>  IN  BOOLEAN                      BootPolicy,<br>  IN  EFI_HANDLE                   ParentImageHandle,<br>  IN  EFI_DEVICE_PATH_PROTOCOL     *DevicePath,<br>  IN  VOID                         *SourceBuffer OPTIONAL,<br>  IN  UINTN                        SourceSize,<br>  OUT EFI_HANDLE                   *ImageHandle<br>  );<br><span class="hljs-comment">//***********************************************************************</span><br><span class="hljs-comment">//EFI_BOOTSERVICES初始化</span><br><span class="hljs-comment">///root/edk2/MdeModulePkg/Core/Dxe/DxeMain/DxeMain.c</span><br>EFI_BOOT_SERVICES &amp;nbsp;mBootServices =&#123;<br><span class="hljs-comment">//.......</span><br>(EFI_IMAGE_START)CoreStartImage,<br>(EFI_IMAGE_LOAD)CoreLoadImage,<span class="hljs-comment">//原型在文件/root/edk2/MdeModulePkg/Core/Dxe/Image/Image.c中</span><br>&#125;<br><span class="hljs-comment">//*****************************************************************************</span><br><span class="hljs-comment">///root/edk2/MdeModulePkg/Core/Dxe/Image/Image.c</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  Loads an EFI image into memory and returns a handle to the image.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  <span class="hljs-doctag">@param</span>  BootPolicy              If TRUE, indicates that the request originates</span><br><span class="hljs-comment">                                  from the boot manager, and that the boot</span><br><span class="hljs-comment">                                  manager is attempting to load FilePath as a</span><br><span class="hljs-comment">                                  boot selection.</span><br><span class="hljs-comment">  <span class="hljs-doctag">@param</span>  ParentImageHandle       The caller&#x27;s image handle.</span><br><span class="hljs-comment">  <span class="hljs-doctag">@param</span>  FilePath                The specific file path from which the image is</span><br><span class="hljs-comment">                                  loaded.</span><br><span class="hljs-comment">  <span class="hljs-doctag">@param</span>  SourceBuffer            If not NULL, a pointer to the memory location</span><br><span class="hljs-comment">                                  containing a copy of the image to be loaded.</span><br><span class="hljs-comment">  <span class="hljs-doctag">@param</span>  SourceSize              The size in bytes of SourceBuffer.</span><br><span class="hljs-comment">  <span class="hljs-doctag">@param</span>  ImageHandle             Pointer to the returned image handle that is</span><br><span class="hljs-comment">                                  created when the image is successfully loaded.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  <span class="hljs-doctag">@retval</span> EFI_SUCCESS             The image was loaded into memory.</span><br><span class="hljs-comment">  <span class="hljs-doctag">@retval</span> EFI_NOT_FOUND           The FilePath was not found.</span><br><span class="hljs-comment">  <span class="hljs-doctag">@retval</span> EFI_INVALID_PARAMETER   One of the parameters has an invalid value.</span><br><span class="hljs-comment">  <span class="hljs-doctag">@retval</span> EFI_UNSUPPORTED         The image type is not supported, or the device</span><br><span class="hljs-comment">                                  path cannot be parsed to locate the proper</span><br><span class="hljs-comment">                                  protocol for loading the file.</span><br><span class="hljs-comment">  <span class="hljs-doctag">@retval</span> EFI_OUT_OF_RESOURCES    Image was not loaded due to insufficient</span><br><span class="hljs-comment">                                  resources.</span><br><span class="hljs-comment">  <span class="hljs-doctag">@retval</span> EFI_LOAD_ERROR          Image was not loaded because the image format was corrupt or not</span><br><span class="hljs-comment">                                  understood.</span><br><span class="hljs-comment">  <span class="hljs-doctag">@retval</span> EFI_DEVICE_ERROR        Image was not loaded because the device returned a read error.</span><br><span class="hljs-comment">  <span class="hljs-doctag">@retval</span> EFI_ACCESS_DENIED       Image was not loaded because the platform policy prohibits the</span><br><span class="hljs-comment">                                  image from being loaded. NULL is returned in *ImageHandle.</span><br><span class="hljs-comment">  <span class="hljs-doctag">@retval</span> EFI_SECURITY_VIOLATION  Image was loaded and an ImageHandle was created with a</span><br><span class="hljs-comment">                                  valid EFI_LOADED_IMAGE_PROTOCOL. However, the current</span><br><span class="hljs-comment">                                  platform policy specifies that the image should not be started.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">**/</span><br>EFI_STATUS<br>EFIAPI<br><span class="hljs-title function_ invoke__">CoreLoadImage</span> (<br>  IN BOOLEAN                   BootPolicy,<br>  IN EFI_HANDLE                ParentImageHandle,<br>  IN EFI_DEVICE_PATH_PROTOCOL  *FilePath,<br>  IN VOID                      *SourceBuffer   OPTIONAL,<br>  IN UINTN                     SourceSize,<br>  OUT EFI_HANDLE               *ImageHandle<br>  )<br>&#123;<br>  EFI_STATUS  Status;<br>  EFI_HANDLE  Handle;<br><br>  <span class="hljs-title function_ invoke__">PERF_LOAD_IMAGE_BEGIN</span> (<span class="hljs-literal">NULL</span>);<br><br>  Status = <span class="hljs-title function_ invoke__">CoreLoadImageCommon</span> (<br>             BootPolicy,<br>             ParentImageHandle,<br>             FilePath,<br>             SourceBuffer,<br>             SourceSize,<br>             (EFI_PHYSICAL_ADDRESS)(UINTN)<span class="hljs-literal">NULL</span>,<br>             <span class="hljs-literal">NULL</span>,<br>             ImageHandle,<br>             <span class="hljs-literal">NULL</span>,<br>             EFI_LOAD_PE_IMAGE_ATTRIBUTE_RUNTIME_REGISTRATION  EFI_LOAD_PE_IMAGE_ATTRIBUTE_DEBUG_IMAGE_INFO_TABLE_REGISTRATION<br>             );<br><br>  Handle = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">EFI_ERROR</span> (Status)) &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// ImageHandle will be valid only Status is success.</span><br>    <span class="hljs-comment">//</span><br>    Handle = *ImageHandle;<br>  &#125;<br><br>  <span class="hljs-title function_ invoke__">PERF_LOAD_IMAGE_END</span> (Handle);<br><br>  <span class="hljs-keyword">return</span> Status;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="2-2-进入映像入口函数"><a href="#2-2-进入映像入口函数" class="headerlink" title="2.2 进入映像入口函数"></a>2.2 进入映像入口函数</h2><p>CorStartImage 的主要作用是调用映像的人口函数。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">///root/edk2/MdeModulePkg/Core/Dxe/Image/Image.c</span><br>EFI_STATUS<br>EFIAPI<br>CoreStartImage (<br>  IN EFI_HANDLE  ImageHandle,<br>  OUT UINTN      *ExitDataSize,<br>  OUT CHAR16     **ExitData  OPTIONAL<br>  )<br>&#123;<br>  EFI_STATUS                 Status;<br>  LOADED_IMAGE_PRIVATE_DATA  *Image;<br>  LOADED_IMAGE_PRIVATE_DATA  *LastImage;<br>  UINT64                     HandleDatabaseKey;<br>  UINTN                      SetJumpFlag;<br>  EFI_HANDLE                 Handle;<br><br>  Handle = ImageHandle;<br>  <span class="hljs-comment">//......</span><br>  <span class="hljs-comment">// Call the image&#x27;s entry point</span><br>  <span class="hljs-comment">//</span><br>  I<span class="hljs-function"><span class="hljs-title">mage</span>-&gt;</span>Started = TRUE;<br>  <span class="hljs-comment">//调用Image的入口函数</span><br>  I<span class="hljs-function"><span class="hljs-title">mage</span>-&gt;</span>S<span class="hljs-function"><span class="hljs-title">tatus</span>  = Image-&gt;</span>E<span class="hljs-function"><span class="hljs-title">ntryPoint</span> (ImageHandle, Image-&gt;</span>Info.SystemTable);<br>  &#125;<br></code></pre></td></tr></table></figure><p>gBS-&gt;StartImage 的核心是Image-&gt;EntryPoint(…)，它就是程序映像的人口函数，对应用程序来说，就是_ModuleEntryPoint 函数。进人_ModuleEntryPoint 后，控制权才转交给应用程序（此处就是我们的HongHai.efi）</p><p><img src="/wp-content/uploads/2023/12/image-40.png"></p><hr><h3 id="2-2-1-ModuleEntryPoint"><a href="#2-2-1-ModuleEntryPoint" class="headerlink" title="2.2.1 _ModuleEntryPoint"></a>2.2.1 _ModuleEntryPoint</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">///root/edk2/MdePkg/Library/UefiApplicationEntryPoint/ApplicationEntryPoint.c</span><br>EFI_STATUS<br>EFIAPI<br>_ModuleEntryPoint (<br>  <span class="hljs-keyword">IN</span> EFI_HANDLE        ImageHandle,<br>  <span class="hljs-keyword">IN</span> EFI_SYSTEM_TABLE  *SystemTable<br>  )<br>&#123;<br>  EFI_STATUS  Status;<br>  <span class="hljs-params">...</span><span class="hljs-params">...</span><br>  <span class="hljs-comment">// Call constructor for all libraries.</span><br>  <span class="hljs-comment">//调用所有被使用库的构造函数,构造函数是一种特殊的成员函数，用于在创建对象时进行初始化操作</span><br>  ProcessLibraryConstructorList (ImageHandle, SystemTable);<br>  <span class="hljs-comment">// Call the module&#x27;s entry point</span><br>  <span class="hljs-comment">//调用Image 的入口函数</span><br>  <span class="hljs-comment">//</span><br>  Status = ProcessModuleEntryPointList (ImageHandle, SystemTable);<br>  <span class="hljs-comment">// Process destructor for all libraries.</span><br>  <span class="hljs-comment">//析构函数是一种特殊的成员函数，用于在对象被销毁时执行清理和释放资源的操作</span><br>  ProcessLibraryDestructorList (ImageHandle, SystemTable);<br>&#125;<br></code></pre></td></tr></table></figure><p>在命令行执行 build 命令的时候，build 命令会解析模块的工程文件（即.inf文件)，然后生成AutoGen.h 和AutoGen.c，这三个函数便是AutoGen.c中的一部分。一般而言，在.inf文件的[LibraryClasses]段声明了某个库后，如<br>果这个库有构造函数，AutoGen 便会在ProcessLibraryConstructorList 中加入这个库的构造函数。另外，ProcesLibraryConstructorList 还会加入启动服务和运行时服务的构造函数。</p><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/20231124114135.png"></p>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArmVirtQemu平台下实现一个简单.efi程序</title>
    <link href="/028.html"/>
    <url>/028.html</url>
    
    <content type="html"><![CDATA[<hr><h1 id="1-源码文件"><a href="#1-源码文件" class="headerlink" title="1 源码文件"></a>1 源码文件</h1><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pf">///root/edk2/TestPkg/TestMain.c<br><span class="hljs-comment">#include &lt;Uefi.h&gt;</span><br>//<span class="hljs-variable">&lt;Uefi.h&gt;</span>头文件UEFI的基本数据类型与核心数据结构，基本上所有的UEFI文件均包含该头文件<br>//返回值类型为EFI_STATUS，其为无符号长整数，几乎所有的UEFI代码返回值为该类型<br>//入口参数EFI_HANDLE与EFI_SYSTEM_TABLE<br>//前者为Image对象（.efi文件加载到内存中生成的对象称为Image）的句柄，其作为模块的入口参数：表示模块自身到内存中的Image<br>//SystemTable是程序与外界交互的桥梁，其是一个UEFI内核的全局结构体，通过它可以获得UEFI提供的各种服务<br>EFI_STATUS UefiMain(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SyatemTable)<br>    &#123;<br>        SyatemTable-&gt;C<span class="hljs-keyword">on</span>Out-&gt;OutputString(SyatemTable-&gt;C<span class="hljs-keyword">on</span>Out,L<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>        EFI_STATUS <span class="hljs-keyword">state</span> = EFI_SUCCESS;<br>        return <span class="hljs-keyword">state</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h1 id="2-编译配置-inf文件"><a href="#2-编译配置-inf文件" class="headerlink" title="2 编译配置.inf文件"></a>2 编译配置.inf文件</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">///root/edk2/TestPkg/test.inf</span><br><br><span class="hljs-selector-attr">[Defines]</span><br>    INF_VERSION = <span class="hljs-number">0</span>X00010006<br>    BASE_NAME = HongHai<span class="hljs-comment">//指定编译出来的应用名</span><br>    FILE_GUID = <span class="hljs-number">12345678</span>-<span class="hljs-number">1234</span>-<span class="hljs-number">1234</span>-<span class="hljs-number">1234</span>-<span class="hljs-number">1234567890</span>AB<br>    MODULE_TYPE = UEFI_APPLICATION<span class="hljs-comment">//指定为UEFI应用</span><br>    VERSION_STRING = <span class="hljs-number">1.0</span><br>    ENTRY_POINT = UefiMain<span class="hljs-comment">//指定主函数入口</span><br><br><span class="hljs-selector-attr">[Sources]</span><br>    TestMain.c<span class="hljs-comment">//源文件合集，根目录为EDK2</span><br><br><span class="hljs-selector-attr">[Packages]</span><br>    MdePkg/MdePkg<span class="hljs-selector-class">.dec</span><br><br><span class="hljs-selector-attr">[LibraryClasses]</span><br>    UefiApplicationEntryPoint<br></code></pre></td></tr></table></figure><hr><h1 id="3-平台描述文件-dsc"><a href="#3-平台描述文件-dsc" class="headerlink" title="3 平台描述文件.dsc"></a>3 平台描述文件.dsc</h1><p>因为我们的目标平台为ArmVirtQemu下，所以在文件：“&#x2F;root&#x2F;edk2&#x2F;ArmVirtPkg&#x2F;ArmVirtQemu.dsc”中的[Componets.common]加入：</p><p>TestPkg&#x2F;test.inf</p><hr><h1 id="4-编译"><a href="#4-编译" class="headerlink" title="4 编译"></a>4 编译</h1><p>UEFI编译请参考本站：<a href="897.html">OpenEuler-源码编译UEFI运行ARM虚拟机</a></p><p>qemu-system-aarch64编译也请参考本站 <a href="895.html">blog.landery.cn&#x2F;895.html</a></p><p>编译完成后在目录：&#x2F;root&#x2F;uefi-tools&#x2F;Build&#x2F;ArmVirtQemu-AARCH64&#x2F;DEBUG_GCC5&#x2F;AARCH64下可以查看到文件：</p><p><img src="/wp-content/uploads/2023/11/image-1.png"></p><p>以及在目录：&#x2F;root&#x2F;uefi-tools&#x2F;Build&#x2F;ArmVirtQemu-AARCH64&#x2F;DEBUG_GCC5&#x2F;FV下文件：</p><p><img src="/wp-content/uploads/2023/11/image-3.png"></p><p>另外ARM下虚拟机使用UEFI启动需要64M大小的启动设备，解决方法也请参考上述博客；</p><h2 id="4-1-驱动挂载"><a href="#4-1-驱动挂载" class="headerlink" title="4.1 驱动挂载"></a>4.1 驱动挂载</h2><p>QEMU提供了将目录挂载为虚拟FAT驱动器的功能，以便在模拟的环境中访问和操作目录中的文件</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">qemu-<span class="hljs-keyword">system</span>-aarch64 -drive <span class="hljs-built_in">format</span>=raw,<span class="hljs-built_in">file</span>=fat:rw:&lt;<span class="hljs-built_in">directory</span>&gt;<br></code></pre></td></tr></table></figure><p>此处我们将该目录替换成在QEMU_EFI-pflash.raw磁盘所在目录下新建和test目录，并且将HongHai.efi文件拷贝到该目录下，这样在qemu模拟器挂载其为驱动时便可以运行该.efi文件</p><hr><h1 id="5-模拟"><a href="#5-模拟" class="headerlink" title="5 模拟"></a>5 模拟</h1><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">/root/qemu/<span class="hljs-keyword">build</span>/qemu-<span class="hljs-keyword">system</span>-aarch64 -pflash QEMU_EFI-pflash.<span class="hljs-keyword">raw</span> -cpu cortex-a57 -m <span class="hljs-number">2048</span> -smp <span class="hljs-number">1</span> -machine virt -drive format=<span class="hljs-keyword">raw</span>,file=fat:rw:test,<span class="hljs-keyword">index</span>=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="5-1-效果"><a href="#5-1-效果" class="headerlink" title="5.1 效果"></a>5.1 效果</h2><p><img src="/wp-content/uploads/2023/11/image-4.png"></p><p>上图可见，驱动是成功挂载了</p><p><img src="/wp-content/uploads/2023/11/image-2.png"></p><p>执行该文件：键入该文件名后回车</p><p><img src="/wp-content/uploads/2023/11/image.png"></p>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
      <category>UEFI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>直接对字符串hash和对仅包含这个字符串的文件做hash得到的结果不同</title>
    <link href="/0013.html"/>
    <url>/0013.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@controller</span> ~]<span class="hljs-meta"># echo -n <span class="hljs-string">&quot;Hello, SM3中文&quot;</span>  openssl sm3</span><br>(stdin)= <span class="hljs-number">0762</span>db018b4cbe230bf620651eccbdb14a77239abd9995960881aedd203b181d<br>[root<span class="hljs-symbol">@controller</span> ~]<span class="hljs-meta"># vim 1.txt</span><br>[root<span class="hljs-symbol">@controller</span> ~]<span class="hljs-meta"># openssl dgst -SM3 1.txt</span><br>SM3(<span class="hljs-number">1.</span>txt)= b86eb26d2914526649609c2b27da6d9df523ad2090b2df384247fb8d87298534<br>[root<span class="hljs-symbol">@controller</span> ~]<span class="hljs-meta"># cat 1.txt</span><br>Hello, SM3中文<br></code></pre></td></tr></table></figure><p>可以看到对一个字符串直接做hash和对包含这个字符串的文件做hash得到的结果不同。为什么呢？</p><p>以下是chatGPT的回答，这里不深究了，有空看一下源码。</p><ol><li><strong>包含额外信息：</strong> 如果对文件进行哈希，文件可能包含一些额外的元信息，例如文件名、路径、时间戳等。这些额外的信息会影响哈希结果。</li><li><strong>文件编码：</strong> 如果文件是文本文件，其编码方式可能影响哈希结果。不同的编码方式导致的二进制表示不同，因此哈希结果也会不同。</li><li><strong>文件结尾符：</strong> 文本文件的行结尾符在不同的操作系统上可能不同。例如，Windows 使用回车符和换行符（\r\n），而类 Unix 系统使用换行符（\n）。这可能导致对于相同的文本内容，在不同系统上计算的哈希结果不同。</li><li><strong>空白字符：</strong> 文件中的空白字符（例如空格、制表符等）可能在字符串哈希和文件哈希中的处理方式不同，从而导致不同的哈希结果。</li><li><strong>文件元数据：</strong> 文件哈希通常会包括文件的元数据，如权限、所有者等。这些信息在字符串哈希中是不存在的，可能导致哈希结果不同。</li></ol>]]></content>
    
    
    <categories>
      
      <category>密码算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sm3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qemu虚拟机实现ssh访问-端口映射</title>
    <link href="/0036.html"/>
    <url>/0036.html</url>
    
    <content type="html"><![CDATA[<p>添加如下命令行参数：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">-<span class="hljs-built_in">net</span> user,hostfwd=::<span class="hljs-number">2222</span>-:<span class="hljs-number">22</span>  -<span class="hljs-built_in">net</span> nic<br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">[root@controller ~]<span class="hljs-comment"># netstat -ano  grep 2222</span><br>tcp        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">2222</span>            <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:*               LISTEN      <span class="hljs-literal">off</span> (<span class="hljs-number">0.00</span>/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>libvirt修改XML配置添加qemu命令行参数</title>
    <link href="/0032.html"/>
    <url>/0032.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.libvirt.org/kbase/qemu-passthrough-security.html">libvirt: QEMU command-line passthrough</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">domain</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;kvm&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>QEMUGuest1<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">uuid</span>&gt;</span>c7a5fdbd-edaf-9455-926a-d65c16db1809<span class="hljs-tag">&lt;/<span class="hljs-name">uuid</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">commandline</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://libvirt.org/schemas/domain/qemu/1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#x27;-newarg&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#x27;parameter&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">env</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;ID&#x27;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#x27;wibble&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">env</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;BAR&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">commandline</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">domain</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核内存管理概述</title>
    <link href="/037.html"/>
    <url>/037.html</url>
    
    <content type="html"><![CDATA[<hr><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">通常在计算机系统中，虚拟页被称为页，物理页被称为页帧或页框。虚拟页是进程或程序地址空间的抽象，它们被映射到物理页帧或页框上。虚拟页的使用可以让进程或程序使用比实际物理内存更大的地址空间，从而提高计算机系统的性能和效率。<br></code></pre></td></tr></table></figure><p>内存的管理是以内存页面为单位进行的，一个内存页面是指连续的4KB物理内存</p><p>在_Intel 80x86_ CPU中，程序在寻址过程中使用的是由段+偏移值构成的地址，该地址不能直接用于直接寻早物理地址因此又被称之为虚拟地址。</p><p>而将虚拟机地址变换为物理地址的这种地址变换机制为内存管理的主要功能之一，另一个主要功能为：内存寻址保护机制</p><p><img src="/wp-content/uploads/2023/10/image-29.png"></p><hr><h1 id="1-内存分页管理"><a href="#1-内存分页管理" class="headerlink" title="1. 内存分页管理"></a>1. 内存分页管理</h1><p>分页管理的目的是：将某一物理地址页面映射到某一线性地址</p><p>在 x86系统中，内存分页管理是通过页目录表以及内存页表的二级表组成 ，其中页目录表与页表的结构相同，表项结构也相同</p><p>页目录表中的每一个表项（4B）用来寻址一个页表，而每个页表的表项（4B）用来寻址一个物理内存页.即是当唯一指定一个页表目录项与页表项我们就可以唯一地对应一个物理内存页</p><p>一个系统中可以同时存在多个页目录表，而在某一时刻只有一个页目录表可用，其由CR3寄存器保存物理内存地址</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">页目录表占一页内存（4KB），则最多可以寻址（4KB/<span class="hljs-attribute">4B</span>=1024）个页表，页表亦如此。所以一个页目录表所寻址的所有页表共可以寻址 1024\<span class="hljs-number">*1024</span>\<span class="hljs-number">*4096B</span>=4GB内存空间<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/%E9%A1%B5%E8%A1%A8%E7%9B%AE%E5%BD%95%E5%92%8C%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE" alt="页表目录及页表结构示意"></p><hr><h2 id="1-1-页目录与页表项结构"><a href="#1-1-页目录与页表项结构" class="headerlink" title="1.1. 页目录与页表项结构"></a>1.1. 页目录与页表项结构</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">由于内存页的大小是<span class="hljs-number">4</span><span class="hljs-variable">KB</span>，也就是<span class="hljs-number">2</span>的<span class="hljs-number">12</span>次方字节，因此内存页的地址必须是<span class="hljs-number">4</span><span class="hljs-variable">KB</span>的倍数，即低<span class="hljs-number">12</span>位总是<span class="hljs-number">0</span>。这是因为在二进制中，<span class="hljs-number">2</span>的<span class="hljs-number">12</span>次方等于<span class="hljs-number">4096</span>，即<span class="hljs-number">1000000000000</span>，低<span class="hljs-number">12</span>位全是<span class="hljs-number">0</span>。因此，内存页的起始地址总是位于<span class="hljs-number">4</span><span class="hljs-built_in">K</span>边界上，其低<span class="hljs-number">12</span>位总是<span class="hljs-number">0</span>。<br><br>因此页表项的低<span class="hljs-number">12</span>位可做他用<br><br>这种对齐方式可以提高内存管理的效率和性能，因为如果内存页不对齐，那么将会出现跨页的情况，导致内存访问效率下降，甚至产生错误。通过将内存页对齐到<span class="hljs-number">4</span><span class="hljs-built_in">K</span>边界上，可以最大限度地利用内存空间，同时提高内存访问的效率和性能。<br></code></pre></td></tr></table></figure><ul><li>在一个页目录表中，其页帧地址指向页表的起始地址；而在二级页表中，页帧地址指向期望内存操作的物理内存页地址</li><li>存在位（PRENSENT—P）确定一个页表是否可以用作地址转换过程</li></ul><blockquote><p>当CPU试图将一个页表项进行地址转换时，如果P&#x3D;0，则会抛出页异常信号。此时缺页中断就将所请求的页加入到物理内存中，并且导致异常的指令将会重新执行</p><ul><li>读写位（READ&#x2F;WRITE—R&#x2F;W）与用户&#x2F;超级用户（USER&#x2F;SUPERVISOR—U&#x2F;S）用于分页级别的保护机制</li><li>已访问位（ACCESS—A）和已修改（DIRTY—D）用来提供有关页的使用信息（页目录项没有D位，页表项有D位）</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/%E9%A1%B5%E7%9B%AE%E5%BD%95%E5%8F%8A%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%BB%93%E6%9E%84"></p><hr><h2 id="1-2-线性地址变换"><a href="#1-2-线性地址变换" class="headerlink" title="1.2. 线性地址变换"></a>1.2. 线性地址变换</h2><p>对于内核或者应用进程，在申请内存时使用的是线性地址</p><p>为了使用分页机制，一个32位的线性地址被分为3部分：页目录项、页表项、对应物理内存页的偏移地址（在进行内存分页时，页内偏移地址是存放在虚拟地址的低位部分，用于在地址变换过程中确定所访问的页内具体位置）</p><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E7%A4%BA%E6%84%8F%E5%9B%BE" alt="线性地址变换示意图"></p><p><img src="/wp-content/uploads/2023/10/image-28.png"></p><hr><h1 id="2-linux中的物理内存管理与分配"><a href="#2-linux中的物理内存管理与分配" class="headerlink" title="2. linux中的物理内存管理与分配"></a>2. linux中的物理内存管理与分配</h1><p>其中，主内存区即为程序进行分配管理内存区域</p><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"></p><p>每个进程在地址中都是从nr*64MB地址起始，nr是任务号，占用逻辑地址64MB；bss为未初始化的数据段；环境参数数据块最长128KB，其左面为起始堆栈指针</p><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/%E8%BF%9B%E7%A8%8B%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%9C%A8%E9%80%BB%E8%BE%91%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E5%B8%83"></p><hr><h2 id="2-1-页面出错异常处理"><a href="#2-1-页面出错异常处理" class="headerlink" title="2.1. 页面出错异常处理"></a>2.1. 页面出错异常处理</h2><p>在开启了分页机制（标志寄存器中PG&#x3D;1）的情况下，存在以下两种情况使得引起页出错异常中断 INT 14</p><blockquote><ol><li>页目录项或者页表项存在位P&#x3D;0&#x2F;&#x2F;缺页中断</li><li>当前执行程序权限不够访问该页面&#x2F;&#x2F;写保护中断</li></ol></blockquote><p>此时CPU将会提供以下信息：</p><blockquote><ol><li>栈中的出错码（error code）</li></ol><blockquote><p>其格式位32位，但仅最低三位有用，分别指P、R&#x2F;W、U&#x2F;S位；详见P745\</p><ol start="2"><li>控制寄存器CR2将保存引起异常的线性地址。页出错处理程序可使用其定位相关页目录项与页表项</li></ol></blockquote></blockquote><hr><h2 id="2-2-写时复制"><a href="#2-2-写时复制" class="headerlink" title="2.2. 写时复制"></a>2.2. 写时复制</h2><p>当进程A调用fork()函数创建进程B时，两个进程实际上是共享A的物理页面；fork会让子进程以只读方式共享父进程A页面，同时将A进程对于该物理页面的访问也设置为只读模式</p><p>当其中一方进行写操作时将会触发页面异常中断，此时 CPU将会执行 <code>do_wp_page()</code> 来解决该异常：① 取消该页面的共享；② 为写进程复制一个新的物理页面；③ 重新执行导致页面异常的写入操作</p><hr><h2 id="2-3-需求加载机制"><a href="#2-3-需求加载机制" class="headerlink" title="2.3. 需求加载机制"></a>2.3. 需求加载机制</h2><p>需求加载（Demand Loading）是指仅当程序需要时才将程序代码和数据从磁盘加载到内存中，而不是在程序启动时将所有代码和数据都加载到内存中。这种机制可以减少内存使用，提高系统性能和效率。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 程序启动时，操作系统会将程序的可执行文件加载到进程的地址空间中，但是只有程序的代码和一些必要的数据被加载到内存中，而其他数据则被标记为未加载状态，只有在需要时才会被加载到内存中。<br><span class="hljs-bullet">2.</span> 当程序需要访问未加载到内存中的数据时，操作系统会触发一个页错误（Page Fault）异常，告诉操作系统需要将该数据加载到内存中。操作系统会检查该页是否在磁盘交换区中，如果在，则将该页从磁盘交换区中读入内存，并更新页表中的映射关系。<br><span class="hljs-bullet">3.</span> 加载完数据后，程序继续执行，直到下一次访问未加载到内存中的数据，再次触发页错误异常，从而触发新一轮的需求加载过程。<br></code></pre></td></tr></table></figure><p>此种技术要求被执行的文件目标格式为ZMAGIC——需求分页格式的目标文件格式（程序的代码段与数据段都从页面边界开始存放），以契合内核以页面为单位读取代码或者数据</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>内核开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存页面追踪实验</title>
    <link href="/020.html"/>
    <url>/020.html</url>
    
    <content type="html"><![CDATA[<ol><li>任务描述</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">当使用qemu模拟了虚拟机运行（仅仅启动内核）；此时虚拟机作为一个qemu进程，查看其在宿主机上所占用的内存页面与页面的属性<br></code></pre></td></tr></table></figure><hr><h1 id="2-实验记录"><a href="#2-实验记录" class="headerlink" title="2. 实验记录"></a>2. 实验记录</h1><h2 id="2-1-qmap"><a href="#2-1-qmap" class="headerlink" title="2.1. qmap"></a>2.1. qmap</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">内存的分配方式主要有两种：<br><br><span class="hljs-bullet">1.</span> 直接分配。这是由进程直接分配内存的方式。在创建进程时，会为它分配一个或多个内存区域，这些区域的大小和位置由操作系统决定。这种方式的优点是简单直接，可以满足进程对内存的基本需求。但缺点是效率较低，因为每次分配都需要在操作系统的管理下进行，而且分配的内存不一定能够得到充分的利用。<br><span class="hljs-bullet">2.</span> 通过文件映射。这是另一种内存分配方式，主要应用在虚拟内存中。虚拟内存是一种将硬盘空间作为内存使用的技术，通过这种方式，进程可以使用比实际物理内存更多的内存。当进程需要使用内存时，操作系统会将一个文件映射到进程的地址空间中，这样，进程就可以像访问物理内存一样访问这个文件。这种方式的优点是可以提高效率，因为操作系统可以统一管理内存的分配和释放，而且可以将暂时不用的内存数据换出到硬盘中，从而节省物理内存的空间。但缺点是操作相对复杂，需要一定的系统资源<br></code></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">pmap -x <span class="hljs-number">52369</span> <span class="hljs-comment">//该命令可以查看某进程的内存映像信息；选项 -d 可以获取更详细信息</span><br><span class="hljs-comment">//各列信息如下：</span><br>- Address: 进程的内存地址。<br>- Kbytes: 进程在该地址上占用的内存大小（以KB为单位）。<br>- RSS: 进程在该地址上的驻留集大小（Resident <span class="hljs-built_in">Set</span> <span class="hljs-built_in">Size</span>），也就是进程当前在物理内存中占用的大小。<br>- Dirty: 进程在该地址上的<span class="hljs-string">&quot;Dirty&quot;</span>大小。<span class="hljs-string">&quot;Dirty&quot;</span>指的是内存中已经被进程修改，但还没有被写回到磁盘的部分。<br>- Mode: 进程在该地址上的内存访问模式，例如<span class="hljs-string">&#x27;r&#x27;</span>代表可读，<span class="hljs-string">&#x27;w&#x27;</span>代表可写，<span class="hljs-string">&#x27;x&#x27;</span>代表可执行。<br>- Mapping: 进程在该地址上的内存映射详情。在这里，所有的映射都是匿名映射（anon），这表示这些内存是由进程直接分配的，而不是通过文件映射的。*/<br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/10/image-26.png"></p><hr><h2 id="2-2-GDB"><a href="#2-2-GDB" class="headerlink" title="2.2. GDB"></a>2.2. GDB</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">gdb</span> -p <span class="hljs-number">52369</span><br>&lt;gdb&gt; <span class="hljs-meta">info</span> <span class="hljs-meta">proc</span> mappings <span class="hljs-comment">//获取进程内存映射信息；经验证其与pmap获取一致</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3. 小结"></a>2.3. 小结</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">以上两种方法其实都是通过读取所属进程的/<span class="hljs-meta">proc</span>/pid/maps文件来获取进程的内存映射信息，进行了一些格式处理<br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">下一步应当弄清楚/<span class="hljs-meta">proc</span>/pid/maps文件是由谁什么时候如何组织的<br></code></pre></td></tr></table></figure><hr><h1 id="3-内核模块编写获取进程内存信息"><a href="#3-内核模块编写获取进程内存信息" class="headerlink" title="3. 内核模块编写获取进程内存信息"></a>3. 内核模块编写获取进程内存信息</h1><h2 id="3-1-前置知识"><a href="#3-1-前置知识" class="headerlink" title="3.1. 前置知识"></a>3.1. 前置知识</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 默认读者已经掌握内存页面转换知识；<br><span class="hljs-bullet">2.</span> 默认读者掌握PCB的结构体知识——task<span class="hljs-emphasis">_struc;</span><br><span class="hljs-emphasis">3. 默认读者掌握页表项与页目录项的结构以及内存在内核中的结构体表示mm_</span>struct<br></code></pre></td></tr></table></figure><hr><h2 id="3-2-实验思路"><a href="#3-2-实验思路" class="headerlink" title="3.2. 实验思路"></a>3.2. 实验思路</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span>.通过pid号确定对应的task_struct<span class="hljs-comment">;</span><br><span class="hljs-number">2</span>.通过task_struct中的内存字段进行遍历的操作完成该进程内存页面的地址的读取与标志获取<br></code></pre></td></tr></table></figure><hr><h2 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3. 代码"></a>3.3. 代码</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><br><br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-built_in">MODULE_VERSION</span>(<span class="hljs-string">&quot;1.0.1&quot;</span>);<br><span class="hljs-built_in">MODULE_AUTHOR</span>(<span class="hljs-string">&quot;CHH&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">get_process_mappings</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *task)</span> </span>&#123;<br>    <span class="hljs-comment">//内核中用于内存管理的数据结构</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *mm;<br>    <span class="hljs-comment">//mm_struct中指向内存映射链表的头指针</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_area_struct</span> *vma;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start, end;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mf_flags;<br>    <span class="hljs-comment">//mm字段是在进程控制块task_struct中的内存管理的数据结构</span><br>    mm = task-&gt;mm;<br>    <span class="hljs-keyword">if</span> (!mm) &#123;<br>        <span class="hljs-built_in">printk</span>(KERN_INFO <span class="hljs-string">&quot;No memory mapping available.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printk</span>(KERN_INFO <span class="hljs-string">&quot;Process mappings for PID %d:\n&quot;</span>, task-&gt;pid);<br>    <span class="hljs-comment">//以下字段均可以通过查看linux内核源码获得</span><br>    <span class="hljs-comment">//简单的链表的指针实现遍历</span><br>    <span class="hljs-keyword">for</span> (vma = mm-&gt;mmap; vma; vma = vma-&gt;vm_next) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        *获得页面起始地址与页表项的标志</span><br><span class="hljs-comment">        */</span><br>        start = vma-&gt;vm_start;<br>        end = vma-&gt;vm_end;<br>        mf_flags = vma-&gt;vm_flags;<span class="hljs-comment">//页面标志</span><br>        <span class="hljs-built_in">printk</span>(KERN_INFO <span class="hljs-string">&quot;Start: 0x%lx, End: 0x%lx, Flags: 0x%lx\n&quot;</span>, start, end, mf_flags);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">mm_module_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 在这里编写获取内存映射页面的代码</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> *task;<br>    <span class="hljs-type">pid_t</span> pid = <span class="hljs-number">197496</span>;  <span class="hljs-comment">// 替换为你要获取内存映射页面的进程ID,目前的pid为一个qemu进程</span><br>    <span class="hljs-comment">//pid_task系统调用，通过pid返回一个task_struct结构体的指针</span><br>    task = <span class="hljs-built_in">pid_task</span>(<span class="hljs-built_in">find_vpid</span>(pid), PIDTYPE_PID);<br>    <span class="hljs-keyword">if</span> (!task) &#123;<br>        <span class="hljs-built_in">printk</span>(KERN_INFO <span class="hljs-string">&quot;Invalid process ID.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">get_process_mappings</span>(task);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">mm_module_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>        <span class="hljs-built_in">printk</span>(KERN_INFO <span class="hljs-string">&quot;Module unload\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">//内核模块地注册</span><br><span class="hljs-built_in">module_init</span>(mm_module_init);<br><span class="hljs-built_in">module_exit</span>(mm_module_exit);<br></code></pre></td></tr></table></figure><hr><h2 id="3-4-内核模块编译与添加"><a href="#3-4-内核模块编译与添加" class="headerlink" title="3.4. 内核模块编译与添加"></a>3.4. 内核模块编译与添加</h2><h3 id="3-4-1-Makefile文件编写"><a href="#3-4-1-Makefile文件编写" class="headerlink" title="3.4.1. Makefile文件编写"></a>3.4.1. Makefile文件编写</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">obj-m += mm_tracing.o<br><br>KERNELDIR ?= /lib/modules/<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -r)</span>/build<br>PWD := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><br><br><span class="hljs-section">default:</span><br>        <span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNELDIR)</span> M=<span class="hljs-variable">$(PWD)</span> modules<br><br><span class="hljs-section">clean:</span><br>        <span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNELDIR)</span> M=<span class="hljs-variable">$(PWD)</span> clean<br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/394856708">全网最牛Linux内核Makefile文件详解 - 知乎 (zhihu.com)</a></p><h3 id="3-4-2-编译"><a href="#3-4-2-编译" class="headerlink" title="3.4.2. 编译"></a>3.4.2. 编译</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//在源码目录下</span><br><span class="hljs-built_in">make</span><br></code></pre></td></tr></table></figure><h3 id="3-4-3-查看编译结果"><a href="#3-4-3-查看编译结果" class="headerlink" title="3.4.3. 查看编译结果"></a>3.4.3. 查看编译结果</h3><p><img src="/wp-content/uploads/2023/10/image-24.png"></p><h3 id="3-4-4-插入内核模块并且查看模块插入信息"><a href="#3-4-4-插入内核模块并且查看模块插入信息" class="headerlink" title="3.4.4. 插入内核模块并且查看模块插入信息"></a>3.4.4. 插入内核模块并且查看模块插入信息</h3><p><img src="/wp-content/uploads/2023/10/image-25.png"></p><p><img src="/wp-content/uploads/2023/10/image-27.png"></p><hr><h2 id="3-5-实验结果分析"><a href="#3-5-实验结果分析" class="headerlink" title="3.5. 实验结果分析"></a>3.5. 实验结果分析</h2><h3 id="3-5-1-起始地址"><a href="#3-5-1-起始地址" class="headerlink" title="3.5.1. 起始地址"></a>3.5.1. 起始地址</h3><p><img src="/wp-content/uploads/2023/10/image-22.png"></p><p><img src="/wp-content/uploads/2023/10/image-23.png"></p><p>通过对比可以发现其地址获取成功</p><h3 id="3-5-2-标志位分析"><a href="#3-5-2-标志位分析" class="headerlink" title="3.5.2. 标志位分析"></a>3.5.2. 标志位分析</h3><p>以下是页表项与页目录项</p><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/%E9%A1%B5%E7%9B%AE%E5%BD%95%E5%8F%8A%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%BB%93%E6%9E%84"></p><p>通过对比&#x2F;proc&#x2F;\<pid>&#x2F;maps中的模式字段与将Flags值解析为二进制再按照上面的页表结构进行对比可以得出：页面控制信息也成功获取</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>内核开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenEuler-源码编译UEFI运行ARM虚拟机</title>
    <link href="/040.html"/>
    <url>/040.html</url>
    
    <content type="html"><![CDATA[<h2 id="编译UEFI，替换yum安装的edk2"><a href="#编译UEFI，替换yum安装的edk2" class="headerlink" title="编译UEFI，替换yum安装的edk2"></a>编译UEFI，替换yum安装的edk2</h2><p>由于在ARM平台上使用KVM虚拟化，只能支持UEFI的启动方式启动虚拟机，我们也有修改UEFI的需求，因此需要自行编译替换UEFI固件，这里记录一下ARM64架构下的UEFI编译过程，以及虚拟机启动过程。</p><h3 id="UEFI编译，edk2"><a href="#UEFI编译，edk2" class="headerlink" title="UEFI编译，edk2"></a>UEFI编译，edk2</h3><p>下载edk2源， EDK2 是一个开源的、用于开发 UEFI 固件的工具和框架。它是 UEFI 规范的一个实现，提供了一个用于构建 UEFI 固件的开发环境。 </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/tianocore/edk2.git<br> git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/tianocore/edk2-platforms.git<br> git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/tianocore/edk2-libc.git<br> git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/tianocore/edk2-non-osi.git<br> git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://git.linaro.org/uefi/uefi-tools.git<br></code></pre></td></tr></table></figure><p>先进入edk2，切换到我们想要编译的版本 </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cd edk2<br> git tags -<span class="hljs-selector-tag">a</span><br> git checkout -<span class="hljs-selector-tag">b</span> <span class="hljs-number">202208</span> edk2-stable202208 <span class="hljs-comment">//拉取远程的edk标签到本地</span><br> ​<br> git submodule update <span class="hljs-attr">--init</span> <span class="hljs-comment">//更新子模块</span><br></code></pre></td></tr></table></figure><p>然后，我们主要利用uefi-tools.git，直接一键构建即可。需要配置该文件 vim uefi-tools&#x2F;edk2-build.sh</p><p><img src="/wp-content/uploads/2023/10/image-17.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"> <span class="hljs-comment"># armvirtqemu64是platforms名字</span><br> .<span class="hljs-regexp">/uefi-tools/</span>edk2-build.sh armvirtqemu64  -b DEBUG<br></code></pre></td></tr></table></figure><p>使用<code>--help</code>可以查看对应的平台，我们需要ARM64因此为armvirtqemu64。 </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">[root@haiweieuler UEFI]<span class="hljs-comment"># ./uefi-tools/edk2-build.sh --help</span><br><span class="hljs-symbol"> usage:</span><br> uefi-<span class="hljs-keyword">build.sh </span>[-<span class="hljs-keyword">b </span><span class="hljs-built_in">DEBUG</span>  RELEASE] [ all  <span class="hljs-keyword">juno </span> fvp  tc2  overdrive  overdrive1000  cello  hikey  hikey960  d03  d05  d06  armada7<span class="hljs-number">0x0</span>  armada8<span class="hljs-number">0x0</span>  mcbin  chaoskey  <span class="hljs-keyword">beagle </span> sni-<span class="hljs-keyword">box </span> capsuleapp  <span class="hljs-keyword">androidboot </span> <span class="hljs-keyword">androidfastboot </span> armvirtqemu  armvirtqemu64  helloworld  sgi575  ovmfx64  ovmfia32  rpi3 ]<br>      all       <span class="hljs-keyword">build </span>all supported platforms<br>    <span class="hljs-keyword">juno </span>      <span class="hljs-keyword">build </span>aarch64 <span class="hljs-keyword">Juno</span><br><span class="hljs-keyword"></span>      fvp       <span class="hljs-keyword">build </span>aarch64 FVP RTSM<br>      tc2       <span class="hljs-keyword">build </span>Versatile Express TC2<br>  sni-<span class="hljs-keyword">box </span>      <span class="hljs-keyword">build </span>Socionext SynQuacer development <span class="hljs-keyword">box</span><br><span class="hljs-keyword"></span> capsuleapp     <span class="hljs-keyword">build </span>EDK2 Capsule Update application<br> <span class="hljs-keyword">androidboot </span>    <span class="hljs-keyword">build </span><span class="hljs-keyword">Android </span><span class="hljs-keyword">Boot </span>app<br> <span class="hljs-keyword">androidfastboot </span><span class="hljs-keyword">build </span><span class="hljs-keyword">Android </span>FastBoot app<br> armvirtqemu     <span class="hljs-keyword">build </span>ArmVirtPkg QEMU<br> armvirtqemu64   <span class="hljs-keyword">build </span>ArmVirtPkg QEMU<br> helloworld     <span class="hljs-keyword">build </span>EDK2 Hello World Example<br>  sgi575       <span class="hljs-keyword">build </span>ARM SGI575 FVP<br>  ovmfx64       <span class="hljs-keyword">build </span>OVMF X64<br> ovmfia32       <span class="hljs-keyword">build </span>OVMF IA32<br>    rpi3       <span class="hljs-keyword">build </span>Raspberry Pi <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>编译完成后，可在该目录下看到Build目录，目录下包含生成EFI固件（QEMU_EFI.fd）和对应的虚拟机的 NVRAM（非易失性随机存取存储器）数据QEMU_VARS.fd。</p><p><img src="/wp-content/uploads/2023/10/image-18.png"></p><p>现在我们需要制作flash，对的如果直接使用EFI.fd和VARS.fd可能会出现如下错误。</p><h4 id="错误-1-Could-not-open-‘-data-lyy-vm-FV-QEMU-EFI-fd’-Permission-denied"><a href="#错误-1-Could-not-open-‘-data-lyy-vm-FV-QEMU-EFI-fd’-Permission-denied" class="headerlink" title="错误 1 Could not open ‘&#x2F;data&#x2F;lyy&#x2F;vm&#x2F;FV&#x2F;QEMU_EFI.fd’: Permission denied"></a>错误 1 Could not open ‘&#x2F;data&#x2F;lyy&#x2F;vm&#x2F;FV&#x2F;QEMU_EFI.fd’: Permission denied</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"> Oct <span class="hljs-number">13</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">50</span> haiweieuler libvirtd[<span class="hljs-number">698131</span>]: <span class="hljs-type">internal</span> error: process exited <span class="hljs-keyword">while</span> connecting <span class="hljs-keyword">to</span> monitor: qemu-kvm: -chardev socket,id=charmonitor,fd=<span class="hljs-number">34</span>,<span class="hljs-keyword">server</span>,<span class="hljs-keyword">nowait</span>: <span class="hljs-built_in">warning</span>: short-form <span class="hljs-type">boolean</span> <span class="hljs-keyword">option</span> <span class="hljs-string">&#x27;server&#x27;</span> deprecated#<span class="hljs-number">012</span>Please use <span class="hljs-keyword">server</span>=<span class="hljs-keyword">on</span> <span class="hljs-keyword">instead</span>#<span class="hljs-number">012</span>qemu-kvm: -chardev socket,id=charmonitor,fd=<span class="hljs-number">34</span>,<span class="hljs-keyword">server</span>,<span class="hljs-keyword">nowait</span>: <span class="hljs-built_in">warning</span>: short-form <span class="hljs-type">boolean</span> <span class="hljs-keyword">option</span> <span class="hljs-string">&#x27;nowait&#x27;</span> deprecated#<span class="hljs-number">012</span>Please use wait=<span class="hljs-keyword">off</span> <span class="hljs-keyword">instead</span>#<span class="hljs-number">012</span>qemu-kvm: -vnc <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">0</span>,<span class="hljs-keyword">password</span>: <span class="hljs-built_in">warning</span>: short-form <span class="hljs-type">boolean</span> <span class="hljs-keyword">option</span> <span class="hljs-string">&#x27;password&#x27;</span> deprecated#<span class="hljs-number">012</span>Please use <span class="hljs-keyword">password</span>=<span class="hljs-keyword">on</span> <span class="hljs-keyword">instead</span>#<span class="hljs-number">0122023</span><span class="hljs-number">-10</span><span class="hljs-number">-13</span>T09:<span class="hljs-number">30</span>:<span class="hljs-number">50.686764</span>Z qemu-kvm: -blockdev &#123;&quot;driver&quot;:&quot;file&quot;,&quot;filename&quot;:&quot;/data/lyy/vm/FV/QEMU_EFI.fd&quot;,&quot;node-name&quot;:&quot;libvirt-pflash0-storage&quot;,&quot;auto-read-only&quot;:<span class="hljs-keyword">true</span>,&quot;discard&quot;:&quot;unmap&quot;&#125;: Could <span class="hljs-keyword">not</span> <span class="hljs-keyword">open</span> <span class="hljs-string">&#x27;/data/lyy/vm/FV/QEMU_EFI.fd&#x27;</span>: Permission denied<br></code></pre></td></tr></table></figure><p>解决办法：查看日志&#x2F;var&#x2F;log&#x2F;message</p><p><img src="/wp-content/uploads/2023/10/image-19-1024x132.png"></p><p>感觉是Selinux的问题，因此我们直接关闭Selinux </p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@haiweieuler</span> FV]<span class="hljs-meta"># getenforce</span><br> Enforcing<br> [root<span class="hljs-symbol">@haiweieuler</span> FV]<span class="hljs-meta"># setenforce 0</span><br> [root<span class="hljs-symbol">@haiweieuler</span> FV]<span class="hljs-meta"># getenforce</span><br> Permissive<br></code></pre></td></tr></table></figure><h4 id="错误2-qemu-kvm-device-requires-67108864-bytes-block-backend-provides-2097152-bytes"><a href="#错误2-qemu-kvm-device-requires-67108864-bytes-block-backend-provides-2097152-bytes" class="headerlink" title="错误2 qemu-kvm: device requires 67108864 bytes, block backend provides 2097152 bytes"></a>错误2 qemu-kvm: device requires 67108864 bytes, block backend provides 2097152 bytes</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"> virsh <span class="hljs-keyword">start</span> ubuntu2204<br> error: Failed <span class="hljs-keyword">to</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">domain</span> ubuntu2204<br> error: <span class="hljs-type">internal</span> error: process exited <span class="hljs-keyword">while</span> connecting <span class="hljs-keyword">to</span> monitor: qemu-kvm: -chardev socket,id=charmonitor,fd=<span class="hljs-number">34</span>,<span class="hljs-keyword">server</span>,<span class="hljs-keyword">nowait</span>: <span class="hljs-built_in">warning</span>: short-form <span class="hljs-type">boolean</span> <span class="hljs-keyword">option</span> <span class="hljs-string">&#x27;server&#x27;</span> deprecated<br> Please use <span class="hljs-keyword">server</span>=<span class="hljs-keyword">on</span> <span class="hljs-keyword">instead</span><br> qemu-kvm: -chardev socket,id=charmonitor,fd=<span class="hljs-number">34</span>,<span class="hljs-keyword">server</span>,<span class="hljs-keyword">nowait</span>: <span class="hljs-built_in">warning</span>: short-form <span class="hljs-type">boolean</span> <span class="hljs-keyword">option</span> <span class="hljs-string">&#x27;nowait&#x27;</span> deprecated<br> Please use wait=<span class="hljs-keyword">off</span> <span class="hljs-keyword">instead</span><br> qemu-kvm: -vnc <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">0</span>,<span class="hljs-keyword">password</span>: <span class="hljs-built_in">warning</span>: short-form <span class="hljs-type">boolean</span> <span class="hljs-keyword">option</span> <span class="hljs-string">&#x27;password&#x27;</span> deprecated<br> Please use <span class="hljs-keyword">password</span>=<span class="hljs-keyword">on</span> <span class="hljs-keyword">instead</span><br> <span class="hljs-number">2023</span><span class="hljs-number">-10</span><span class="hljs-number">-13</span>T09:<span class="hljs-number">31</span>:<span class="hljs-number">32.743526</span>Z qemu-kvm: device requires <span class="hljs-number">67108864</span> bytes, block backend provides <span class="hljs-number">2097152</span> bytes<br></code></pre></td></tr></table></figure><p>或者 </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">error: Failed <span class="hljs-keyword">to</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">domain</span> openEuler2203<br> error: <span class="hljs-type">internal</span> error: qemu unexpectedly closed the monitor: qemu-kvm: -chardev socket,id=charmonitor,fd=<span class="hljs-number">34</span>,<span class="hljs-keyword">server</span>,<span class="hljs-keyword">nowait</span>: <span class="hljs-built_in">warning</span>: short-form <span class="hljs-type">boolean</span> <span class="hljs-keyword">option</span> <span class="hljs-string">&#x27;server&#x27;</span> deprecated<br> Please use <span class="hljs-keyword">server</span>=<span class="hljs-keyword">on</span> <span class="hljs-keyword">instead</span><br> qemu-kvm: -chardev socket,id=charmonitor,fd=<span class="hljs-number">34</span>,<span class="hljs-keyword">server</span>,<span class="hljs-keyword">nowait</span>: <span class="hljs-built_in">warning</span>: short-form <span class="hljs-type">boolean</span> <span class="hljs-keyword">option</span> <span class="hljs-string">&#x27;nowait&#x27;</span> deprecated<br> Please use wait=<span class="hljs-keyword">off</span> <span class="hljs-keyword">instead</span><br> qemu-kvm: -vnc <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">0</span>,<span class="hljs-keyword">password</span>: <span class="hljs-built_in">warning</span>: short-form <span class="hljs-type">boolean</span> <span class="hljs-keyword">option</span> <span class="hljs-string">&#x27;password&#x27;</span> deprecated<br> Please use <span class="hljs-keyword">password</span>=<span class="hljs-keyword">on</span> <span class="hljs-keyword">instead</span><br> <span class="hljs-number">2023</span><span class="hljs-number">-10</span><span class="hljs-number">-13</span>T09:<span class="hljs-number">33</span>:<span class="hljs-number">29.225102</span>Z qemu-kvm: device requires <span class="hljs-number">67108864</span> bytes, block backend provides <span class="hljs-number">786432</span> bytes<br></code></pre></td></tr></table></figure><p>原因：提示必须使用64MB的固件，因此我们使用QEMU_EFI.fd和QEMU_VARS.fd制作64MB的闪存。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=/dev/zero <span class="hljs-attribute">of</span>=QEMU_EFI-pflash.raw <span class="hljs-attribute">bs</span>=1M <span class="hljs-attribute">count</span>=64 #dd是复制，<span class="hljs-keyword">if</span>是输入，of是输出，bs是块大小，count是块数量<br> dd <span class="hljs-attribute">if</span>=QEMU_EFI.fd <span class="hljs-attribute">of</span>=QEMU_EFI-pflash.raw <span class="hljs-attribute">conv</span>=notrunc<br> dd <span class="hljs-attribute">if</span>=/dev/zero <span class="hljs-attribute">of</span>=QEMU_VARS-pflash.raw <span class="hljs-attribute">bs</span>=1M <span class="hljs-attribute">count</span>=64<br> dd <span class="hljs-attribute">if</span>=QEMU_VARS.fd <span class="hljs-attribute">of</span>=QEMU_VARS-pflash.raw <span class="hljs-attribute">conv</span>=notrunc<br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/10/image-20.png"></p><p>可以看到制作出来的文件大小已经变成64MB了。将其替换到配置文件里即可。 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">virsh shutdown ubuntu2204<br>virsh <span class="hljs-built_in">edit</span> ubuntu2204<br></code></pre></td></tr></table></figure><p>替换对应的fd为raw。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;os&gt;<br>    &lt;<span class="hljs-built_in">type</span> <span class="hljs-built_in">arch</span>=<span class="hljs-string">&#x27;aarch64&#x27;</span> machine=<span class="hljs-string">&#x27;virt-6.0&#x27;</span>&gt;hvm&lt;/type&gt;<br>    &lt;loader <span class="hljs-built_in">readonly</span>=<span class="hljs-string">&#x27;yes&#x27;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;pflash&#x27;</span>&gt;/data/lyy/vm/FV/QEMU_EFI-pflash.raw&lt;/loader&gt;<br>    &lt;nvram&gt;/data/lyy/vm/FV/QEMU_VARS-pflash.raw&lt;/nvram&gt;<br>&lt;/os&gt;<br></code></pre></td></tr></table></figure><p>启动即可。</p><p><img src="/wp-content/uploads/2023/10/image-21.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
      <tag>qemu</tag>
      
      <tag>openEuler</tag>
      
      <tag>UEFI</tag>
      
      <tag>鲲鹏920</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鲲鹏920 ARM+OpenEuler-源码编译QEMU</title>
    <link href="/019.html"/>
    <url>/019.html</url>
    
    <content type="html"><![CDATA[<h2 id="编译qemu运行"><a href="#编译qemu运行" class="headerlink" title="编译qemu运行"></a>编译qemu运行</h2><p>为了方便后期对qemu源码修改，需要讲yum安装的qemu包，自己编译替换</p><p>这里qemu我们使用6.0的</p><p>安装开发工具</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">yum</span> groupinstall <span class="hljs-string">&quot;Development Tools&quot;</span><br></code></pre></td></tr></table></figure><p>先安装ninja，需要先安装re2c，下载地址：<a href="https://link.zhihu.com/?target=http://re2c.org/index.html">http://re2c.org/index.html</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tar -xvf re2c-<span class="hljs-number">3.1</span><span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.xz</span><br>cd re2c-<span class="hljs-number">3.1</span>/<br>autoreconf -<span class="hljs-selector-tag">i</span> -W <span class="hljs-attribute">all</span><br>./configure<br>make<br>make install<br></code></pre></td></tr></table></figure><p>安装ninja，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /data<br>git <span class="hljs-built_in">clone</span> https://github.com/ninja-build/ninja.git<br><br><span class="hljs-built_in">cd</span> ninja<br>./configure.py --bootstrap <br><span class="hljs-built_in">cp</span> ./ninja  /usr/bin<br>ninja --version<br></code></pre></td></tr></table></figure><p>编译安装qemu</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/data</span><br>git clone -b  stable-6.0  https:<span class="hljs-string">//github.com/qemu/qemu.git</span><br><br><span class="hljs-keyword">cd</span> qemu<br>mkdir build <br><span class="hljs-keyword">cd</span> build <br><br><span class="hljs-string">../configure</span> <span class="hljs-params">--prefix=/usr</span>  <span class="hljs-params">--enable-virtfs</span> <span class="hljs-params">--enable-kvm</span> <span class="hljs-params">--enable-sdl</span> <span class="hljs-params">--enable-debug</span> <span class="hljs-params">--enable-tpm</span> <span class="hljs-params">--enable-vnc</span> <span class="hljs-params">--target-list=aarch64-softmmu</span>,arm-softmmu<br><br>make -j4<br>make install <span class="hljs-string">//</span>此操作会替换qemu-img等软件包，无所谓就直接执行<br></code></pre></td></tr></table></figure><p>因为我们要用virsh创建虚拟机，需要替换&#x2F;usr&#x2F;bin&#x2F;qemu-kvm和&#x2F;usr&#x2F;libexec&#x2F;qemu-kvm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf /usr/bin/qemu-kvm<br><span class="hljs-built_in">ln</span> -s /usr/bin/qemu-system-aarch64 /usr/bin/qemu-kvm<br><span class="hljs-built_in">mv</span> /usr/libexec/qemu-kvm /usr/libexec/qemu-kvm-bak <span class="hljs-comment">#备份一下</span><br><span class="hljs-built_in">ln</span> -s /usr/bin/qemu-system-aarch64 /usr/libexec/qemu-kvm<br></code></pre></td></tr></table></figure><h3 id="测试一下是否能够正常启动虚拟机"><a href="#测试一下是否能够正常启动虚拟机" class="headerlink" title="测试一下是否能够正常启动虚拟机"></a>测试一下是否能够正常启动虚拟机</h3><p>架构：鲲鹏920ARM+openEuler 22.03</p><p>虚拟机：ubuntu22.04 server ARM版</p><p>我们只能使用virsh创建虚拟机，因此下面给出对应的配置文件xml，这是<a href="https://docs.openeuler.org/zh/docs/22.03_LTS_SP2/docs/Virtualization/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE.html#xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B">虚拟机配置 (openeuler.org)</a>，官网配置，注释需要删除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">domain</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;kvm&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>ubuntu2204<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">memory</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">&#x27;GiB&#x27;</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">memory</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">vcpu</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">vcpu</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">os</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">type</span> <span class="hljs-attr">arch</span>=<span class="hljs-string">&#x27;aarch64&#x27;</span> <span class="hljs-attr">machine</span>=<span class="hljs-string">&#x27;virt&#x27;</span>&gt;</span>hvm<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">loader</span> <span class="hljs-attr">readonly</span>=<span class="hljs-string">&#x27;yes&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pflash&#x27;</span>&gt;</span>/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw<span class="hljs-tag">&lt;/<span class="hljs-name">loader</span>&gt;</span> #这里使用的是默认的UEFI固件<br>        <span class="hljs-tag">&lt;<span class="hljs-name">nvram</span>&gt;</span>/var/lib/libvirt/qemu/nvram/openEulerVM.fd<span class="hljs-tag">&lt;/<span class="hljs-name">nvram</span>&gt;</span> #UEFI变量<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">os</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">features</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">acpi</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">gic</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&#x27;3&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">features</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpu</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&#x27;host-passthrough&#x27;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">topology</span> <span class="hljs-attr">sockets</span>=<span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-attr">cores</span>=<span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-attr">threads</span>=<span class="hljs-string">&#x27;1&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">cpu</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">iothreads</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">iothreads</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">clock</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">&#x27;utc&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">on_poweroff</span>&gt;</span>destroy<span class="hljs-tag">&lt;/<span class="hljs-name">on_poweroff</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">on_reboot</span>&gt;</span>restart<span class="hljs-tag">&lt;/<span class="hljs-name">on_reboot</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">on_crash</span>&gt;</span>restart<span class="hljs-tag">&lt;/<span class="hljs-name">on_crash</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">devices</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">emulator</span>&gt;</span>/usr/libexec/qemu-kvm<span class="hljs-tag">&lt;/<span class="hljs-name">emulator</span>&gt;</span> #这里使用qemu-kvm有已经被我们替换成我们编译的了<br>        <span class="hljs-tag">&lt;<span class="hljs-name">disk</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;file&#x27;</span> <span class="hljs-attr">device</span>=<span class="hljs-string">&#x27;disk&#x27;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">driver</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;qemu&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;qcow2&#x27;</span> <span class="hljs-attr">iothread</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&#x27;/data/lyy/vm/ubuntu2204.qcow2&#x27;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">dev</span>=<span class="hljs-string">&#x27;vda&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;virtio&#x27;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">boot</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&#x27;1&#x27;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">disk</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">disk</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;file&#x27;</span> <span class="hljs-attr">device</span>=<span class="hljs-string">&#x27;cdrom&#x27;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">driver</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;qemu&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;raw&#x27;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&#x27;/data/iso/ubuntu-22.04-live-server-arm64.iso&#x27;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">readonly</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">dev</span>=<span class="hljs-string">&#x27;sdb&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;scsi&#x27;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">boot</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&#x27;2&#x27;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">disk</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">interface</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;bridge&#x27;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">bridge</span>=<span class="hljs-string">&#x27;br0&#x27;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;virtio&#x27;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">interface</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">console</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pty&#x27;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;virtio&#x27;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;scsi&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;virtio-scsi&#x27;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;usb&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;ehci&#x27;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;tablet&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;usb&#x27;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;keyboard&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;usb&#x27;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">graphics</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;vnc&#x27;</span> <span class="hljs-attr">listen</span>=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span> <span class="hljs-attr">passwd</span>=<span class="hljs-string">&#x27;123456&#x27;</span>/&gt;</span> #这里配置vnc监听端口和密码<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">devices</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">seclabel</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;dynamic&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;dac&#x27;</span> <span class="hljs-attr">relabel</span>=<span class="hljs-string">&#x27;yes&#x27;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">domain</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">virsh define ubuntu2204.<span class="hljs-keyword">xml</span><br><span class="hljs-title">virsh</span> <span class="hljs-literal">start</span> ubuntu2204<br></code></pre></td></tr></table></figure><blockquote><p>这里有可能报错：libvirtError: Unable to add bridge br0 port vnet0: Operation not supported</p><p>参考之前的文章：<a href="864.html">blog.landery.cn&#x2F;864.html</a></p></blockquote><p>define定义了虚拟机以后，虚拟机的配置文件就在&#x2F;etc&#x2F;libvirt&#x2F;qemu&#x2F;目录下</p><p>我们需要使用以下命令，实时修改虚拟机配置。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">virsh <span class="hljs-built_in">edit</span> ubuntu2204<br></code></pre></td></tr></table></figure><p>这里备份一下ubuntu2204的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">domain</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;kvm&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>ubuntu2204<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">uuid</span>&gt;</span>606763c0-eefe-4816-acca-e21be114cfff<span class="hljs-tag">&lt;/<span class="hljs-name">uuid</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">memory</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">&#x27;KiB&#x27;</span>&gt;</span>8388608<span class="hljs-tag">&lt;/<span class="hljs-name">memory</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">currentMemory</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">&#x27;KiB&#x27;</span>&gt;</span>8388608<span class="hljs-tag">&lt;/<span class="hljs-name">currentMemory</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">vcpu</span> <span class="hljs-attr">placement</span>=<span class="hljs-string">&#x27;static&#x27;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">vcpu</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">iothreads</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">iothreads</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">os</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span> <span class="hljs-attr">arch</span>=<span class="hljs-string">&#x27;aarch64&#x27;</span> <span class="hljs-attr">machine</span>=<span class="hljs-string">&#x27;virt-6.0&#x27;</span>&gt;</span>hvm<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">loader</span> <span class="hljs-attr">readonly</span>=<span class="hljs-string">&#x27;yes&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pflash&#x27;</span>&gt;</span>/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw<span class="hljs-tag">&lt;/<span class="hljs-name">loader</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">nvram</span>&gt;</span>/var/lib/libvirt/qemu/nvram/openEulerVM.fd<span class="hljs-tag">&lt;/<span class="hljs-name">nvram</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">os</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">features</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">acpi</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">gic</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&#x27;3&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">features</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cpu</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&#x27;host-passthrough&#x27;</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&#x27;none&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">topology</span> <span class="hljs-attr">sockets</span>=<span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-attr">dies</span>=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-attr">clusters</span>=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-attr">cores</span>=<span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-attr">threads</span>=<span class="hljs-string">&#x27;1&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">cpu</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">clock</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">&#x27;utc&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">on_poweroff</span>&gt;</span>destroy<span class="hljs-tag">&lt;/<span class="hljs-name">on_poweroff</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">on_reboot</span>&gt;</span>restart<span class="hljs-tag">&lt;/<span class="hljs-name">on_reboot</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">on_crash</span>&gt;</span>restart<span class="hljs-tag">&lt;/<span class="hljs-name">on_crash</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">devices</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">emulator</span>&gt;</span>/usr/libexec/qemu-kvm<span class="hljs-tag">&lt;/<span class="hljs-name">emulator</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">disk</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;file&#x27;</span> <span class="hljs-attr">device</span>=<span class="hljs-string">&#x27;disk&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">driver</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;qemu&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;qcow2&#x27;</span> <span class="hljs-attr">iothread</span>=<span class="hljs-string">&#x27;1&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&#x27;/data/lyy/vm/ubuntu2204.qcow2&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">dev</span>=<span class="hljs-string">&#x27;vda&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;virtio&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">boot</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&#x27;1&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x05&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">disk</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;scsi&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;virtio-scsi&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x03&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;usb&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;ehci&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x04&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x01&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;pcie-root&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;pcie-root-port&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;pcie-root-port&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">chassis</span>=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;0x8&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x01&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span> <span class="hljs-attr">multifunction</span>=<span class="hljs-string">&#x27;on&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;pcie-root-port&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;pcie-root-port&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">chassis</span>=<span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;0x9&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x01&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x1&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;3&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;pcie-root-port&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;pcie-root-port&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">chassis</span>=<span class="hljs-string">&#x27;3&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;0xa&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x01&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x2&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;4&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;pcie-to-pci-bridge&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;pcie-pci-bridge&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x01&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;pcie-root-port&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;pcie-root-port&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">chassis</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;0xb&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x01&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x3&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;6&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;pcie-root-port&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;pcie-root-port&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">chassis</span>=<span class="hljs-string">&#x27;6&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;0xc&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x01&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x4&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;7&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;pcie-root-port&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;pcie-root-port&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">chassis</span>=<span class="hljs-string">&#x27;7&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;0xd&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x01&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x5&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">interface</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;bridge&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">mac</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&#x27;52:54:00:4a:d1:10&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">bridge</span>=<span class="hljs-string">&#x27;br0&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">virtualport</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;openvswitch&#x27;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">parameters</span> <span class="hljs-attr">interfaceid</span>=<span class="hljs-string">&#x27;da2f33a2-2b12-4710-9199-b8e46cc39df6&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">virtualport</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;virtio&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x02&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">interface</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">serial</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pty&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;system-serial&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;0&#x27;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;pl011&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">serial</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">console</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pty&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;serial&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">console</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;tablet&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;usb&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;usb&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;1&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;keyboard&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;usb&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;usb&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;2&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">graphics</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;vnc&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;-1&#x27;</span> <span class="hljs-attr">autoport</span>=<span class="hljs-string">&#x27;yes&#x27;</span> <span class="hljs-attr">listen</span>=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span> <span class="hljs-attr">passwd</span>=<span class="hljs-string">&#x27;123456&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">listen</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;address&#x27;</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">graphics</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;virtio&#x27;</span> <span class="hljs-attr">heads</span>=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-attr">primary</span>=<span class="hljs-string">&#x27;yes&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x06&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">devices</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">seclabel</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;dynamic&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;dac&#x27;</span> <span class="hljs-attr">relabel</span>=<span class="hljs-string">&#x27;yes&#x27;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">domain</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后启动就行。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">virsh <span class="hljs-literal">start</span> ubuntu2204<br></code></pre></td></tr></table></figure><blockquote><p>注：如果修改了配置文件edit之后，需要先关机在启动，配置文件才会生效。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">virsh shudown ubuntu2204<br>virsh <span class="hljs-literal">start</span> ubuntu2204 <span class="hljs-comment">#新的配置文件生效</span><br></code></pre></td></tr></table></figure></blockquote><p>查看vnc端口</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">virsh</span> vncdisplay ubuntu2204<br></code></pre></td></tr></table></figure><p>使用vncviewer等软件连接。</p><blockquote><p>记得开放端口</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">add</span><span class="hljs-literal">-</span><span class="hljs-comment">port 5901/tcp</span> <span class="hljs-literal">--</span><span class="hljs-comment">permanent</span><br><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">reload</span><br></code></pre></td></tr></table></figure></blockquote><p><img src="/wp-content/uploads/2023/10/image-16.png"></p><p>成功进入系统。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
      <tag>qemu</tag>
      
      <tag>openEuler</tag>
      
      <tag>鲲鹏920</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于鲲鹏920CPU的硬件虚拟化</title>
    <link href="/007.html"/>
    <url>/007.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/cpu_class.png"></p><hr><h1 id="2-硬件辅助虚拟化"><a href="#2-硬件辅助虚拟化" class="headerlink" title="2. 硬件辅助虚拟化"></a>2. 硬件辅助虚拟化</h1><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/PCIE_CONFIG.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/bios_virt_on.png"></p><h2 id="2-1-实验"><a href="#2-1-实验" class="headerlink" title="2.1. 实验"></a>2.1. 实验</h2><p><img src="/wp-content/uploads/2023/10/image-14.png"></p><hr><p>SR-IOV技术相当于是一种I&#x2F;O的硬件辅助虚拟化技术；简单说，它可以将单一的 PCIe 设备虚拟为多个功能设备并分配给不同的虚拟机直接访问使用，借此有效提升每一个虚拟机获得的 I&#x2F;O 性能并降低延迟</p><p><a href="https://zhuanlan.zhihu.com/p/465123778">深入理解SR-IOV和IO虚拟化 - 知乎 (zhihu.com)</a><br><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100220443/975509a2">PCIe配置 - 华为Atlas服务器 BIOS 参数参考 (鲲鹏920处理器) 07 - 华为 (huawei.com)</a><br><a href="https://zhuanlan.zhihu.com/p/655620990">为虚拟化环境带来更强I&#x2F;O性能！SR-IOV技术简介 - 知乎 (zhihu.com)</a></p><hr><h1 id="3-下一步（2023-10-11-10-12）"><a href="#3-下一步（2023-10-11-10-12）" class="headerlink" title="3. 下一步（2023-10-11 10:12）"></a>3. 下一步（2023-10-11 10:12）</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">探究 <span class="hljs-meta">CPU</span>鲲鹏<span class="hljs-number">920</span>中是否存在关于<span class="hljs-meta">CPU</span>与内存相关的硬件辅助虚拟化以及其硬件辅助虚拟化的实现方式<br></code></pre></td></tr></table></figure><h2 id="3-1-dmesg"><a href="#3-1-dmesg" class="headerlink" title="3.1. dmesg"></a>3.1. dmesg</h2><p><img src="/wp-content/uploads/2023/10/image-15.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chen123456122/IMAGES@main/images/20231011_CPU_feat.png"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mark</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hltr-purple&quot;</span>&gt;</span>通过上述命令的执行，可以说鲲鹏920CPU支持CPU虚拟化么？<span class="hljs-tag">&lt;/<span class="hljs-name">mark</span>&gt;</span></span>如果支持，是否如同x86一样，区<span class="hljs-built_in">别root</span><span class="hljs-built_in">与not</span>-root模式，是否存在相应的类似VMCS的结构？<br><br>那么关于该型号的处理器的内存的硬件辅助虚拟化的实现技术是什么？是否与x86下的类似EPT机制，来实现GPA-&gt;HPA的转换？<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. ARM架构下QEMU+KVM</title>
    <link href="/001.html"/>
    <url>/001.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby">实验的主要目的是验证在<span class="hljs-variable constant_">ARM</span>架构下，<span class="hljs-variable constant_">QEMU</span>+<span class="hljs-variable constant_">KVM</span>的虚拟化的解决方案能否正常承担起<span class="hljs-variable constant_">VMM</span>的作用；<br>实验环境：<br>- <span class="hljs-variable constant_">HOST</span><span class="hljs-symbol">:ubuntu-</span><span class="hljs-number">22.04</span>-live-server-arm64;<br>- <span class="hljs-variable constant_">GUEST</span><span class="hljs-symbol">:ubuntu-</span><span class="hljs-number">22.04</span>-live-server-arm64<br>- <span class="hljs-variable constant_">CPU</span><span class="hljs-symbol">:</span>鲲鹏<span class="hljs-number">920</span><br></code></pre></td></tr></table></figure><hr><h1 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h1><h2 id="2-1-KVM模块"><a href="#2-1-KVM模块" class="headerlink" title="2.1. KVM模块"></a>2.1. KVM模块</h2><p><img src="/wp-content/uploads/2023/10/image-5.png"></p><p>以上信息表明：在当前环境下，使用QEMU&#x2F;KVM作为VMM的话，KVM能够发挥其加速作用</p><hr><h2 id="2-2-QEMU安装"><a href="#2-2-QEMU安装" class="headerlink" title="2.2. QEMU安装"></a>2.2. QEMU安装</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//克隆QEMU</span><br>git clone git:<span class="hljs-comment">//git.qemu-project.org/qemu.git</span><br><br><span class="hljs-comment">//安装依赖包(在configure时与make时报错如果是因为缺少依赖包请自行下载，以下不一定完整)</span><br>sudo apt -y install libglib2<span class="hljs-number">.0</span>-dev libfdt-dev libpixman<span class="hljs-number">-1</span>-dev zlib1g-dev ninja-build\<br>git-email libaio-dev libbluetooth-dev libcapstone-dev libbrlapi-dev libbz2-dev libcap-ng-dev libcurl4-gnutls-dev libgtk<span class="hljs-number">-3</span>-dev libibverbs-dev libjpeg8-dev libncurses5-dev libnuma-dev librbd-dev librdmacm-dev libsasl2-dev libsdl2-dev libseccomp-dev libsnappy-dev libssh-dev valgrind xfslibs-dev libvde-dev libvdeplug-dev libvte<span class="hljs-number">-2.91</span>-dev libxen-dev liblzo2-dev <br><br><span class="hljs-comment">//配置（注意指定目标平台为arm架构）</span><br>../configure --<span class="hljs-keyword">enable</span>-kvm --<span class="hljs-keyword">enable</span>-sdl --<span class="hljs-keyword">enable</span>-<span class="hljs-keyword">debug</span> --<span class="hljs-keyword">enable</span>-tpm --<span class="hljs-keyword">enable</span>-vnct--target-list=aarch64-softmmu,arm-softmmu<br><br><span class="hljs-comment">//编译</span><br><span class="hljs-built_in">make</span> -j$<span class="hljs-function"><span class="hljs-keyword">proc</span></span><br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/10/image-5.png"></p><hr><h1 id="3-虚拟机启动"><a href="#3-虚拟机启动" class="headerlink" title="3. 虚拟机启动"></a>3. 虚拟机启动</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">./qemu-system-aarch64 -enable-kvm  -hda /home/csri/<span class="hljs-keyword">test</span>.qcow2 -<span class="hljs-keyword">m</span> 10240 -cdrom /root/ubuntu-22.04-live-server-arm64.iso -machine virt-8.2 -cpu  host -<span class="hljs-keyword">boot</span> menu=<span class="hljs-keyword">on</span> -k <span class="hljs-keyword">en</span>-<span class="hljs-keyword">us</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*-cpu选择host以当前宿主机的cpu型号进行模拟 ;</span><br><span class="hljs-comment">*-machine的选择得确定ARRCH64的模拟程序是否支持;使用命令qemu-system-aarch64 -M ? 查看</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="3-1-出错"><a href="#3-1-出错" class="headerlink" title="3.1. 出错"></a>3.1. 出错</h2><ol><li>运行上述命令时仅仅会弹出qemu-monitor的监视器页面，并未进入操作系统安装页面。如下：</li></ol><p><img src="/wp-content/uploads/2023/10/image-8.png"></p><ol start="2"><li>使用 <code>apt install qemu-system-arm</code> 安装的模拟工具在使用命令行的方式也存在与上述相同和问题</li></ol><hr><h1 id="4-使用virt-manager测试-1"><a href="#4-使用virt-manager测试-1" class="headerlink" title="4. 使用virt-manager测试[1]"></a>4. 使用virt-manager测试<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.jianshu.com/p/1fc5d8bbeffb">[1]</span></a></sup></h1><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">在使用virt-manager 按照常规流程进行虚拟机创建，能够完成操作系统的安装与初始化，结果如下图。其证明——在<span class="hljs-meta">ARM</span>架构的宿主机上能够使用QEMU模拟（搭配KVM进行加速）<span class="hljs-meta">ARM</span>架构的主机可行<br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/10/image-7.png"></p><p>其中底层调用的命令为：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//qemu</span>版本为6.2.0<br><span class="hljs-string">//</span>使用了KVM内核模块为其加速<br><span class="hljs-string">/usr/bin/qemu-system-aarch64</span> <span class="hljs-string">...</span> -accel kvm -cpu host -m 4096 <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/10/image-9.png"></p><p><img src="/wp-content/uploads/2023/10/image-6.png"><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.jianshu.com/p/1fc5d8bbeffb">https://www.jianshu.com/p/1fc5d8bbeffb</a><br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
      <tag>linux</tag>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以StratoVirt为VMM的虚拟机启动</title>
    <link href="/024.html"/>
    <url>/024.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><a href="https://docs.openeuler.org/zh/docs/21.03/docs/StratoVirt/StratoVirt%E4%BB%8B%E7%BB%8D.html">StratoVirt介绍 (openeuler.org)</a><br><a href="https://zhuanlan.zhihu.com/p/427715818">已有Qemu了，为什么还要StratoVirt？ - 知乎 (zhihu.com)</a></p><hr><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> stratovirt<br></code></pre></td></tr></table></figure><h2 id="2-1-源码安装"><a href="#2-1-源码安装" class="headerlink" title="2.1. 源码安装"></a>2.1. 源码安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://gitee.com/openeuler/stratovirt.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> stratovirt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make build</span><br></code></pre></td></tr></table></figure><hr><h1 id="3-KVM支持"><a href="#3-KVM支持" class="headerlink" title="3. KVM支持"></a>3. KVM支持</h1><p>获取&#x2F;dev&#x2F;kvm设备的读写权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo setfacl -m u:<span class="hljs-variable">$&#123;USER&#125;</span>:rw <span class="hljs-regexp">/dev/</span>kvm<br></code></pre></td></tr></table></figure><hr><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h1><h2 id="4-1-生成rootfs"><a href="#4-1-生成rootfs" class="headerlink" title="4.1. 生成rootfs"></a>4.1. 生成rootfs</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Rootfs是操作系统的根文件系统，包含了操作系统的完整目录结构、文件和配置信息。它是操作系统的基础，提供了文件系统的框架和环境，使得操作系统能够正常启动和运行。<br><br>Rootfs通常位于存储介质（如硬盘、闪存等）上，可以是一个完整的文件系统镜像文件（如<span class="hljs-keyword">ext4、NTFS等），也可以是一个挂载的目录。Rootfs包含了操作系统所需的核心组件，如库文件、可执行文件、配置文件、设备节点等。</span><br><span class="hljs-keyword"></span><br>与Initramfs不同，Rootfs是系统正常运行时使用的持久文件系统，用于提供操作系统的完整功能和服务。它包含了用户空间程序、系统工具和应用程序，以及用户数据和配置文件。<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">dd <span class="hljs-keyword">if</span>=<span class="hljs-string">/dev/zero</span> of=<span class="hljs-string">./rootfs.ext4</span> bs=1G count=10 <span class="hljs-string">//</span>新建设备10G<br>mkfs.ext4 <span class="hljs-string">./rootfs.ext4</span> <span class="hljs-string">//</span>格式化文件系统<br>mount <span class="hljs-string">./rotfs.ext4</span> <span class="hljs-string">/mnt/rootfs</span> <span class="hljs-string">//</span>挂载到目录<br>wget http:<span class="hljs-string">//dl-cdn.alpinelinux.org/alpine/latest-stable/releases/aarch64/alpine-minirootfs-3.18.0-aarch64.tar.gz</span> <span class="hljs-string">//</span>下载最新的rootfs并解压<br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/10/image-3.png"></p><hr><h2 id="4-2-生成内核镜像"><a href="#4-2-生成内核镜像" class="headerlink" title="4.2. 生成内核镜像"></a>4.2. 生成内核镜像</h2><p>编译内核用时太长，我们现在直接使用stratovirt官方提供的一个可执行的内核压缩镜像，具体的内核编译详见：[[Linux&#x2F;Linux内核&#x2F;Linux 内核调试&#x2F;内核调试与分析工具内核调试与分析工具]]</p><p>下载地址为：<a href="https://gitee.com/link?target=https://repo.openeuler.org/openEuler-22.03-LTS/stratovirt_img/">https://repo.openeuler.org/openEuler-22.03-LTS/stratovirt_img&#x2F;</a></p><p>此地址下也有rootfs；则可以路过步骤4.1</p><hr><h2 id="4-3-启动"><a href="#4-3-启动" class="headerlink" title="4.3. 启动"></a>4.3. 启动</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript">stratovirt <span class="hljs-string">\</span><br>    -machine microvm <span class="hljs-string">\</span><br>    -smp <span class="hljs-number">4</span> <span class="hljs-string">\</span><br>    -m <span class="hljs-number">2048</span> <span class="hljs-string">\</span><br>    -kernel ./vmlinux.bin <span class="hljs-string">\</span><br>    -append <span class="hljs-string">&quot;console=ttyS0 root=/dev/vda reboot=k panic=1&quot;</span> <span class="hljs-string">\</span><br>    -drive file=./openEuler-<span class="hljs-number">22.03</span>-LTS-stratovirt-aarch64.img,id=rootfs,readonly=<span class="hljs-literal">off</span> <span class="hljs-string">\</span><br>    -device virtio-blk-device,drive=rootfs,id=rootfs <span class="hljs-string">\</span><br>    -qmp unix:/tmp/stratvirt.socket,server,nowait <span class="hljs-string">\</span><br>    -serial stdio<br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/10/image-4.png"></p><h3 id="4-3-1-连接虚拟机"><a href="#4-3-1-连接虚拟机" class="headerlink" title="4.3.1. 连接虚拟机"></a>4.3.1. 连接虚拟机</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ncat -U <span class="hljs-regexp">/tmp/</span>stratvirt.socket <span class="hljs-regexp">//</span>此soket通信使用的是QMP协议（QEMU Machine Protocol）<br></code></pre></td></tr></table></figure><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">QMP（QEMU Machine Protocol）是一种用于与QEMU（Quick Emulator）虚拟化软件交互的协议。QMP允许客户端应用程序通过发送命令和查询来与运行QEMU的虚拟机或虚拟化实例进行通信。它提供了一种机制，通过该机制，客户端可以控制虚拟机的行为、查询虚拟机的状态以及监视虚拟机的事件。<br><br>QMP基于JSON-RPC（JavaScript <span class="hljs-keyword">Object</span> Notation Remote <span class="hljs-function"><span class="hljs-keyword">Procedure</span> <span class="hljs-title">Call</span>）协议，使用<span class="hljs-title">JSON</span>格式进行数据交换。它提供了一组命令和事件，用于执行各种管理任务，例如启动和停止虚拟机、创建和删除设备、管理网络和存储等。</span><br><span class="hljs-function"></span><br><span class="hljs-function">通过<span class="hljs-title">QMP</span>，客户端可以与<span class="hljs-title">QEMU</span>实例进行实时交互，并进行复杂的配置和管理操作。它提供了与<span class="hljs-title">QEMU</span>的高级集成和自动化的能力，使得可以通过编程方式控制和管理虚拟化环境。</span><br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/10/image-2.png"></p><h1 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h1><p><a href="https://gitee.com/openeuler/stratovirt/blob/master/docs/quickstart.md#https://gitee.com/link?target=https%3A%2F%2Frepo.openeuler.org%2FopenEuler-21.03%2Fstratovirt_img%2Fx86_64%2FopenEuler-21.03-stratovirt-x86_64.img.xz">docs&#x2F;quickstart.md · openEuler&#x2F;stratovirt - Gitee.com</a><br><a href="http://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/aarch64/">Index of &#x2F;alpine&#x2F;latest-stable&#x2F;releases&#x2F;aarch64&#x2F; (alpinelinux.org)</a><br><a href="https://gitee.com/openeuler/docs/tree/master/docs/zh/docs/StratoVirt">docs&#x2F;zh&#x2F;docs&#x2F;StratoVirt · openEuler&#x2F;docs - 码云 - 开源中国 (gitee.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
      <category>stratovirt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
      <tag>VMM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenEuler+openvswitch 创建虚拟机启动报错</title>
    <link href="/041.html"/>
    <url>/041.html</url>
    
    <content type="html"><![CDATA[<p>情况说明：使用euler系统安装KVM虚拟机，参考官网使用virsh进行创建，虚拟网络使用openvswitch，已经创建了桥接网络，但是启动虚拟机报错：</p><p><img src="/wp-content/uploads/2023/10/image-1.png"></p><p>libvirtError: Unable to add bridge br0 port vnet0: Operation not supported</p><p>解决办法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">virsh <span class="hljs-built_in">edit</span> openEulerVM<br></code></pre></td></tr></table></figure><p>interface部分加上</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">&lt;virtualport <span class="hljs-keyword">type</span>=<span class="hljs-symbol">&#x27;openvswitch</span>&#x27; /&gt;<br></code></pre></td></tr></table></figure><p>也就是改动为</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;<span class="hljs-keyword">interface</span> <span class="hljs-symbol">type</span>=&#x27;<span class="hljs-symbol">bridge</span>&#x27;&gt;<br>      &lt;<span class="hljs-symbol">mac</span> <span class="hljs-symbol">address</span>=&#x27;<span class="hljs-symbol">52</span>:<span class="hljs-symbol">54</span>:<span class="hljs-symbol">00</span>:<span class="hljs-symbol">9a</span>:<span class="hljs-symbol">4e</span>:<span class="hljs-symbol">ac</span>&#x27;/&gt;<br>      &lt;<span class="hljs-symbol">source</span> <span class="hljs-symbol">bridge</span>=&#x27;<span class="hljs-symbol">brvlan1786</span>&#x27;/&gt;<br>      &lt;<span class="hljs-symbol">virtualport</span> <span class="hljs-symbol">type</span>=&#x27;<span class="hljs-symbol">openvswitch</span>&#x27; /&gt;<br>      &lt;<span class="hljs-symbol">model</span> <span class="hljs-symbol">type</span>=&#x27;<span class="hljs-symbol">virtio</span>&#x27;/&gt;<br>      &lt;<span class="hljs-symbol">address</span> <span class="hljs-symbol">type</span>=&#x27;<span class="hljs-symbol">pci</span>&#x27; <span class="hljs-symbol">domain</span>=&#x27;<span class="hljs-symbol">0x0000</span>&#x27; <span class="hljs-symbol">bus</span>=&#x27;<span class="hljs-symbol">0x00</span>&#x27; <span class="hljs-symbol">slot</span>=&#x27;<span class="hljs-symbol">0x03</span>&#x27; <span class="hljs-symbol">function</span>=&#x27;<span class="hljs-symbol">0x0</span>&#x27;/&gt;<br>&lt;/<span class="hljs-symbol">interface</span>&gt;<br></code></pre></td></tr></table></figure><p>保存后，再启动就没问题了</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
      <tag>openEuler</tag>
      
      <tag>openvswitch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenEuler+Openvswitch配置桥接网络遇到问题</title>
    <link href="/042.html"/>
    <url>/042.html</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>平台：鲲鹏920 ARM+openEuler 22.03 SP2</p><p>问题：使用openvswitch配置桥接网络之后，如果重启，之前openvswitch的配置失效，无法通过业务口继续访问。内部也无法正常访问外网。</p><p>下面是配置桥接网络的步骤：（官网上有）</p><h2 id="openvswitch配置桥接网络"><a href="#openvswitch配置桥接网络" class="headerlink" title="openvswitch配置桥接网络"></a>openvswitch配置桥接网络</h2><ul><li>新建一个外部网络桥接</li></ul><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">ovs-vsctl<span class="hljs-built_in"> add-br </span>br0<br></code></pre></td></tr></table></figure><ul><li>将外部网络桥接映射到网卡</li></ul><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">ovs-vsctl<span class="hljs-built_in"> add-port </span>br0 enp3s0f1np1<br></code></pre></td></tr></table></figure><ul><li>为网桥设置ip（这一步后可能无法访问主机了，需要通过管理口进入修改以下配置）</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">ifconfig enp3s0f1np1 <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> <span class="hljs-comment">//清空指定网卡ip</span><br>ifconfig br0 ****<span class="hljs-number">.21</span>/<span class="hljs-number">24</span> <span class="hljs-comment">//设置网桥ip</span><br>ifconfig br0 up <span class="hljs-comment">//启动网桥</span><br><br>route -n<br>route <span class="hljs-keyword">add</span> <span class="hljs-literal">default</span> gw ****<span class="hljs-number">.254</span> <span class="hljs-comment">//设置默认网关，出口，根据自己实际设定</span><br>ovs-vsctl show<br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/10/image.png"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>定义一个shell脚本，开机时，自动执行，这样就可以自动配置好网络了。将写好的脚本放到&#x2F;etc&#x2F;profile.d&#x2F;下，</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> /etc/<span class="hljs-keyword">profile</span>.d/<br><span class="hljs-keyword">vim</span> network_create.<span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 创建ovs网络桥接</span><br><span class="hljs-attribute">ifconfig</span> enp3s0f1np1 <span class="hljs-number">0.0.0.0</span><br><span class="hljs-attribute">ifconfig</span> br0 ****.<span class="hljs-number">21</span>/<span class="hljs-number">24</span><br><span class="hljs-attribute">ifconfig</span> br0 up<br><br><span class="hljs-attribute">route</span> add default gw ****.<span class="hljs-number">254</span><br></code></pre></td></tr></table></figure><p>保存，重启测试，成功配置！</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
      <tag>操作系统</tag>
      
      <tag>openEuler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核锁的类型01</title>
    <link href="/038.html"/>
    <url>/038.html</url>
    
    <content type="html"><![CDATA[<h3 id="Linux内核中锁的类型"><a href="#Linux内核中锁的类型" class="headerlink" title="Linux内核中锁的类型"></a>Linux内核中锁的类型</h3><p>当多个进程或者线程使用共享资源时，总会不可避免地发生冲突，为了控制对共享资源的访问，因此设计了锁，防止并发引起的系统问题。大概总结了如下几种锁的类型。</p><ul><li><p>原子操作：就是该操作绝不会在执行完毕前被任何其他任务或事件打断，这个需要硬件的支持使用汇编语言实现的。主要用于资源计数。</p></li><li><p>信号量</p><ul><li>内核信号量</li><li>用户态信号量</li><li>POSIX 信号量：一个正整数，</li><li>System V IPC信号量：一个或多个信号量</li><li>信号量初始化为1，代表互斥锁，如果一个调用者持有这个信号量，那么别的调用者只能挂起等待。</li></ul></li><li><p>读写信号量（rw_semaphore）：对访问者进行细分，分为读者和写者，写者是排他独占的</p><ul><li>如果一个读写信号量被写者占有，其他写者或者读者都必须挂起，直到写者释放信号量</li><li>一个读写信号量同时拥有的读者数量不受限制，可以同时拥有多个读者</li><li>适合读多写少的情况使用，在linux内核中对<strong>进程的内存映像描述结构</strong>的访问就使用了读写信号量进行保护。</li></ul></li><li><p>自旋锁（spin lock）：自旋锁不会引起调用者睡眠，如果自旋锁已经被别的单元持有，调用者循环等待，持有者释放锁，“自旋”一词，因此得名。因为自旋锁一般持有者只占有很短的时间，因此选择自选而不是睡眠，效率比互斥锁要高。<strong>自旋锁保持期间是抢占失效的，而信号量和读写信号量保持期间是可以被抢占的</strong>。在获取自旋锁前需要禁止抢占，这样为了防止被调度出去，让出CPU。</p><ul><li>读写锁（rwlock） 也是一种特殊的自旋锁，读写分明的情况</li><li>大读者锁(brlock-Big Reader Lock) 读写锁高性能版，但是只存在2.4内核中，2.6就已经没有了。读者可以非常快地获得锁，但写者获得锁的开销比较大。<strong>这种锁适合于读多写少的情况，它在这种情况下远好于读写锁。</strong></li></ul></li><li><p>大内核锁 Big Kernel Lock（<strong>BKL</strong>）（大内核锁），全局唯一，保护内核的大锁，可以递归调用，用于比米娜多个处理器上的进程同时访问同一区域。：在内核入口处安装一把‘巨大’的锁，一旦一个处理器进入内核态就立刻上锁，其它将要进入内核态的进程只能在门口等待，以此保证每次只有一个进程处于内核态运行。这把锁就是大内核锁。有了大内核锁保护的系统当然可以安全地运行在多处理器上：由于同时只有一个处理器在运行内核代码，内核的执行本质上和单处理器没有什么区别；而多个处理器同时运行于进程的用户态也是安全的，因为每个进程有自己独立的地址空间。鸡肋</p><ul><li>拥有自动释放的特性，<a href="https://developer.aliyun.com/article/8885">https://developer.aliyun.com/article/8885</a></li><li>大内核所的前世今生 <a href="https://tupelo-shen.github.io/2020/04/19/Linux%E5%86%85%E6%A0%B839-%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E5%86%85%E6%A0%B8%E9%94%81/">https://tupelo-shen.github.io/2020/04/19/Linux%E5%86%85%E6%A0%B839-%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E5%86%85%E6%A0%B8%E9%94%81/</a></li></ul></li><li><p>RCU(Read-Copy Update)，顾名思义：读-拷贝更新，它是基于原理命名的。</p><ul><li>被RCU保护的共享数据结构，读者不需要获取任何锁就可以访问，但是写者需要等待所有CPU读者退出临界区，才能将修改后的数据写回，实际上是一种改进的rwlock读写锁，虽然读者没有同步开销，但是写者存在同步开销。因为如果写比较多时，对读者的性能提高不能弥补写者导致的损失。</li><li>在<strong>绝大部分为读而只有极少部分为写</strong>的情况下，它是非常高效的，因此在路由表维护、系统调用审计、SELinux的AVC、dcache和IPC等代码部分中，使用它来取代rwlock来获得更高的性能。但是，它也有缺点，延后的删除或释放将占用一些内存，尤其是对嵌入式系统，这可能是非常昂贵的内存开销。此外，写者的开销比较大，尤其是对于那些无法容忍旧数据的情况以及不只一个写者的情况，写者需要spinlock或其他的锁机制来与其他写者同步。</li></ul></li><li><p>顺序锁（seqlock）：顺序锁也是对读写锁的一种优化，对于顺序锁，读者绝不会被写者阻塞，也就说，读者可以在写者对被顺序锁保护的共享资源进行写操作时仍然可以继续读，而不必等待写者完成写操作，写者也不需要等待所有读者完成读操作才去进行写操作。但是，写者与写者之间仍然是互斥的，即如果有写者在进行写操作，其他写者必须自旋在那里，直到写者释放了顺序锁。<strong>这种锁有一个限制，它必须要求被保护的共享资源不含有指针，因为写者可能使得指针失效，但读者如果正要访问该指针，将导致OOPs</strong>。</p><ul><li>如果读者在读操作期间，写者已经发生了写操作，那么，读者必须重新读取数据，以便确保得到的数据是完整的。 这种锁对于读写同时进行的概率比较小的情况，性能是非常好的，而且它允许读写同时进行，因而更大地提高了并发性。</li><li>因为在读写分明、且读多写少写优先的场景下，使用seqlock可以避免写操作被阻塞。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>内核开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬链接和软链接的区别</title>
    <link href="/025.html"/>
    <url>/025.html</url>
    
    <content type="html"><![CDATA[<h1 id="硬链接和软链接的区别"><a href="#硬链接和软链接的区别" class="headerlink" title="硬链接和软链接的区别"></a>硬链接和软链接的区别</h1><p>最近复习一下操作系系统文件相关知识，对这些知识又有点模糊了，复习一下加深一下记忆。</p><p>首先说怎么在Linux上创建硬链接和软链接：</p><ul><li>硬链接：<code>ln f1 f2</code></li><li>软链接：<code>ln -s f1 f3</code></li></ul><p>具体区别如下：</p><ul><li>硬链接相当于多了一份指向文件具体节点f1的一个指针f2，硬链接f2和f1是指向同一个物理文件inode的指针，修改f2&#x3D;修改f1，他们看到的东西是一样的。</li><li>软链接相当于f3指向了f1，它属于是指向指针的指针，如果删除f1，查看f3就会提示没有这个文件，但是查看f2依旧可以看到文件内容。删除f1后，通过向f3写入数据，会自动创建新的f1文件，这个文件和f2指向的文件就不再是同一个文件了。</li></ul><p>这是一个简单的示意图：</p><p><img src="/wp-content/uploads/2023/07/Pasted-1024x513.png"></p><p>下面是实验部分，也推荐大家试一下。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>先创建一个f1，内容为”real file!!”，接着创建f1的硬链接f2，软链接f3.</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># cat f1</span><br>real file!!<br>[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># ln f1 f2</span><br>[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># ln -s f1 f3 </span><br></code></pre></td></tr></table></figure><p>查看三个文件的inode：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># ls -li f1 f2 f3</span><br></code></pre></td></tr></table></figure><p>可以看到f1和f2的inode是一样的，而f3不一致。</p><p>接下来我们删除f1，分别查看f2和f3的内容：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># rm -rf f1</span><br></code></pre></td></tr></table></figure><p>可以看到，删除f1以后，并没有删除文件，因为f2依旧指向inode，并且f2内容没有改变，但是f3却无法找到文件，因为f3保存的是f1，通过f1去找的文件，f1删除后他就无法找到了。</p><p>接下来我们向f3写入文件，发现f1被自动创建了，查看效果</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># echo <span class="hljs-string">&quot;new file&quot;</span> &gt;&gt; f3</span><br></code></pre></td></tr></table></figure><p>可以看到新创建出来的f1指向的inode已经不是原来的了，是新创建的.</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU-KVM虚拟机根目录扩容</title>
    <link href="/046.html"/>
    <url>/046.html</url>
    
    <content type="html"><![CDATA[<h2 id="QEMU-KVM虚拟机根目录扩容"><a href="#QEMU-KVM虚拟机根目录扩容" class="headerlink" title="QEMU-KVM虚拟机根目录扩容"></a>QEMU-KVM虚拟机根目录扩容</h2><p>查看根目录容量：</p><p><img src="/wp-content/uploads/2023/06/image-1688021458071.png" alt="file"></p><p>可以看到根目录已经满了。</p><p>先关闭虚拟机，然后在宿主机层，对qemu-kvm虚拟机镜像扩容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">qemu-img resize /home/centos7.6_uefi.qcow2 +20G<br></code></pre></td></tr></table></figure><p>开机后，对虚拟机磁盘进行格式化：</p><p>lsblk查看是否添加上了：可以看到&#x2F;dev&#x2F;sda变成了30G</p><p><img src="/wp-content/uploads/2023/06/image-1688021466449.png" alt="file"></p><p>接下来就是分区操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">fdisk -l<br>fdisk /dev/sda<br>p #查看分区表<br>n #新建分区，一路默认<br>w #保存分区<br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/06/image-1688021474089.png" alt="file"></p><p>有警告：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.<br>The kernel still uses the old table. The new table will be used at<br>the next reboot or after you run partprobe(8) or kpartx(8)<br>Syncing disks.<br></code></pre></td></tr></table></figure><blockquote><p>如果出现这个警告可以通过fdisk -l查看是否已经成功分区，如果没有成功分区，那么</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">parted /dev/sda<br>(parted) <span class="hljs-built_in">print</span><br>它会提示报错，修复即可<br></code></pre></td></tr></table></figure></blockquote><p><img src="/wp-content/uploads/2023/06/image-1688021484391.png" alt="file"> 将&#x2F;dev&#x2F;sda4格式化为Linux LVM。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">parted /dev/sda<br>(parted) toggle X lvm #其中 `/dev/sda` 是磁盘设备名称，`X` 是分区号。<br>pvcreate /dev/sdaX #使用 pvcreate 命令将分区创建为物理卷。<br></code></pre></td></tr></table></figure><p>查看当前LVM卷组<code>vgdisplay</code></p><p><img src="/wp-content/uploads/2023/06/image-1688021515513.png" alt="file"></p><p>将&#x2F;dev&#x2F;sda4加入改卷组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vgextend centos /dev/sda4<br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/06/image-1688021543562.png" alt="file"> 查看根目录挂载的逻辑卷名<code>lvdisplay</code></p><p><img src="/wp-content/uploads/2023/06/image-1688021553330.png" alt="file"></p><p>给根目录扩容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">lvresize -L +19G /dev/mapper/centos-root<br>xfs_growfs /dev/mapper/centos-root<br></code></pre></td></tr></table></figure><p>扩容完成：</p><p><img src="/wp-content/uploads/2023/06/image-1688021560377.png" alt="file"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/qq_38522265/article/details/121396911">https://blog.csdn.net/qq_38522265&#x2F;article&#x2F;details&#x2F;121396911</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三分钟搭建随机图片api-自定义图片类型</title>
    <link href="/0024.html"/>
    <url>/0024.html</url>
    
    <content type="html"><![CDATA[<h2 id="搭建随机图片api"><a href="#搭建随机图片api" class="headerlink" title="搭建随机图片api"></a>搭建随机图片api</h2><blockquote><p>为什么要自己搭建api？ 因为网上的api要么不稳定，要么就是图片太露~了，简直是在法律的边缘疯狂试探，所以决定自己搞一个，自己把关，用自己喜欢的图片，那么就需要学习一下怎么搭建自己的随机图片api。</p></blockquote><p>在网站根目录新建api.php，代码如下：，</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 获取传递到脚本中的参数</span><br><span class="hljs-variable">$type</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;type&#x27;</span>]) ? <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;type&#x27;</span>] : <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-comment">// 定义图片文件夹</span><br><span class="hljs-variable">$img_dir</span> = <span class="hljs-string">&#x27;img&#x27;</span>;<br><br><span class="hljs-comment">// 如果有参数，选择相应的图片文件夹；否则遍历所有子目录</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$type</span>)) &#123;<br>    <span class="hljs-variable">$dir</span> = <span class="hljs-variable">$img_dir</span>.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$type</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable">$dir</span> = <span class="hljs-variable">$img_dir</span>;<br>&#125;<br><br><span class="hljs-comment">// 遍历指定的图片文件夹或所有子目录，并随机选择一张图片</span><br><span class="hljs-variable">$iterator</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RecursiveIteratorIterator</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RecursiveDirectoryIterator</span>(<span class="hljs-variable">$dir</span>));<br><span class="hljs-variable">$files</span> = <span class="hljs-keyword">array</span>();<br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$iterator</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$file</span>) &#123;<br>    <span class="hljs-comment">// 排除目录和非图片文件</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$file</span>-&gt;<span class="hljs-title function_ invoke__">isDir</span>()  !<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$file</span>-&gt;<span class="hljs-title function_ invoke__">getExtension</span>(), <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;gif&#x27;</span>, <span class="hljs-string">&#x27;jpg&#x27;</span>, <span class="hljs-string">&#x27;jpeg&#x27;</span>, <span class="hljs-string">&#x27;png&#x27;</span>, <span class="hljs-string">&#x27;webp&#x27;</span>, <span class="hljs-string">&#x27;bmp&#x27;</span>))) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-variable">$files</span>[] = <span class="hljs-variable">$file</span>-&gt;<span class="hljs-title function_ invoke__">getPathname</span>();<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">count</span>(<span class="hljs-variable">$files</span>) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;没有找到图片文件。MuaOoO ~ &#x27;</span>.<span class="hljs-variable">$dir</span>.<span class="hljs-string">&#x27; 文件夹&#x27;</span>);<br>&#125;<br><span class="hljs-variable">$random_file</span> = <span class="hljs-variable">$files</span>[<span class="hljs-title function_ invoke__">array_rand</span>(<span class="hljs-variable">$files</span>)];<br><br><span class="hljs-comment">// 输出随机选择的图片</span><br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;Content-Type: image/png&#x27;</span>);<br><span class="hljs-keyword">echo</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$random_file</span>));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>新建文件夹<code>img/</code>，给该文件夹重新赋予权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown -R www-data:www-data img/<br></code></pre></td></tr></table></figure><p>可以通过<code>https://域名/api.php</code>，获得随机图片，此外还可以传入type参数，不传入时，默认访问img目录所有子目录下的图片，并随机返回。</p><p>例如：<code>https://域名/api.php?type=yuanshen</code>，需要在img目录下新建<code>yuanshen</code>子目录，并在子目录上传图片，记得给权限。</p><p>本站api：直接访问api.php即可，类型还不确定目前就是自己用。</p>]]></content>
    
    
    <categories>
      
      <category>好用工具</category>
      
      <category>wordpress使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核开发01-编写Linux内核模块</title>
    <link href="/010.html"/>
    <url>/010.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要编写内核模块"><a href="#1-为什么要编写内核模块" class="headerlink" title="1 为什么要编写内核模块"></a>1 为什么要编写内核模块</h2><p>有很多事情在Ring3层是无法去做的，很多系统相关的数据只能在内核去获取，这样就可以通过编写内核模块来获取数据。众所周知 KVM也是Linux 内核模块。</p><h2 id="2-编写代码"><a href="#2-编写代码" class="headerlink" title="2 编写代码"></a>2 编写代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /data/ko_example<br>cd /data/ko_example<br></code></pre></td></tr></table></figure><p>创建文件，内容如下：<code>vim ko_example.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;lyy&quot;</span>);<br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;A simple example Linux module.&quot;</span>);<br>MODULE_VERSION(<span class="hljs-string">&quot;1.0&quot;</span>);<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ko_example_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br> printk(KERN_INFO <span class="hljs-string">&quot;ko_example: Hello, World!\n&quot;</span>);<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">ko_example_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br> printk(KERN_INFO <span class="hljs-string">&quot;ko_example: Goodbye, World!\n&quot;</span>);<br>&#125;<br>module_init(ko_example_init);<br>module_exit(ko_example_exit);<br></code></pre></td></tr></table></figure><p>这是一个最简单的内核模块，只是在加载内核模块的时候输出语句，卸载内核模块时同样输出语句。</p><ul><li><p>MODULE_LICENSE，代表模块的许可证，可用列表查看（以下命令在CentOS7.8上运行，其余版本可能有所区别）</p><ul><li><pre><code class="hljs">grep &quot;MODULE_LICENSE&quot; -B 27 /usr/src/kernels/uname -r/include/linux/module.h<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">        </span><br><span class="hljs-bullet">*   </span>printk：不是printf， <span class="hljs-code">`KERN_INFO`</span> 是一个标志，用于声明应为该行设置的日志记录优先级，并且不带逗号。<br><span class="hljs-code">    </span><br><span class="hljs-bullet">*   </span>module\_init(ko\_example\_init); 内核模块编写的特定方法，将自定义方法注册上去，加载内核时模块执行。<br><span class="hljs-code">    </span><br><span class="hljs-bullet">*   </span>module\_exit(ko\_example\_exit);内核模块编写的特定方法，将自定义方法注册上去，卸载内核时模块执行。<br><span class="hljs-code">    </span><br><br>## 3 编译内核模块<br><br>现在已经写好了一个简单的内核模块ko.example.c，编译我们需要另外构建一个<span class="hljs-code">`Makefile`</span>文件<br><br><span class="hljs-code">```shell</span><br><span class="hljs-code">vim Makefile</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">去掉签名否则会提示错误</span><br>CONFIG_MODULE_SIG=n<br>CONFIG_MODULE_SIG_ALL=n<br><br>obj-m += ko_example.o<br>all:<br>        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules<br>clean:<br>        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean<br></code></pre></td></tr></table></figure><p>其中前两行需要，如果没有前两行，加载内核模块时，一般会校验签名，如果内核模块本身没有经过签名，或者签名值与预期值不符，这两种情况都会被认为是签名认证失败，根据策略的不同，签名认证失败可能会导致模块被拒绝加载，也可能是继续正常加载但内核会显示一条警告信息。</p><blockquote><p>如果未加上这两语句，加载模块后会提示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ 2671.174942] ko_example: loading out-of-tree module taints kernel.<br>[ 2671.175059] ko_example: module verification failed: signature and/or required key missing - tainting kernel<br></code></pre></td></tr></table></figure><p>这里我们就不细讲了内核签名有时间再关注。</p></blockquote><p>继续编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br></code></pre></td></tr></table></figure><p>这回会在目录下生成一些文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@ss ko_example]# ls<br>ko_example.c  ko_example.ko  ko_example.mod.c  ko_example.mod.o  ko_example.o  Makefile  modules.order  Module.symvers<br></code></pre></td></tr></table></figure><p>其中<code>ko_example.ko</code>就是最终的内核模块。</p><p>最后，我们清空dmesg输出，方便查看后面的结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dmesg -C<br></code></pre></td></tr></table></figure><h2 id="4-加载内核模块"><a href="#4-加载内核模块" class="headerlink" title="4 加载内核模块"></a>4 加载内核模块</h2><p>加载内核模块可以用两个命令：在这里推荐第一个，第二个操作比较麻烦。</p><ul><li><code>insmod</code>：不会检查依赖项，本例中可以直接再&#x2F;data&#x2F;ko_example目录下运行，</li><li><code>modprobe</code>：会检查并加载依赖项，并且需要放到特定目录，否则会提示找不到模块</li></ul><h3 id="insmod"><a href="#insmod" class="headerlink" title="insmod"></a>insmod</h3><p>insmod比较简单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">insmod ko_example.ko<br></code></pre></td></tr></table></figure><h3 id="modprobe"><a href="#modprobe" class="headerlink" title="modprobe"></a>modprobe</h3><p>在Linux中，modprobe命令会在以下几个路径中搜索可加载的内核模块：</p><ul><li>&#x2F;lib&#x2F;modules&#x2F;<code>uname -r</code>&#x2F;kernel（内核模块所在的默认目录）</li><li>&#x2F;lib&#x2F;modules&#x2F;<code>uname -r</code>&#x2F;extra&#x2F;（用户自行编译的内核模块所在的目录，一般不需要担心）</li><li>&#x2F;lib&#x2F;modules&#x2F;（常见的内核模块目录，一般也不需要担心）</li></ul><p>其中，<code>uname -r</code>为当前系统所使用的内核版本。</p><p>当我们使用modprobe命令加载一个内核模块时，系统首先会在以上三个路径中搜索是否存在该模块，若存在，系统会将其加载到内存中。若以上三个路径都没有找到该模块，则系统会返回“找不到该模块”的错误。</p><p>此外就算复制过去后还需要更新依赖文件，否则依旧无法找到对应的模块</p><ol><li>将编译好的模块放入&#x2F;lib&#x2F;module&#x2F;<code>uname -r</code>下，</li><li>执行命令<code>depmod</code>更新modules.dep文件(任何目录)</li><li>modprobe ko_example.ko</li></ol><h2 id="5-卸载模块"><a href="#5-卸载模块" class="headerlink" title="5 卸载模块"></a>5 卸载模块</h2><p>同样可以两种卸载方式</p><ul><li><code>rmmod ko_example</code>（在这里推荐使用这个）</li><li><code>modprobe -r ko_example</code></li></ul><h2 id="6-查看dmesg输出"><a href="#6-查看dmesg输出" class="headerlink" title="6 查看dmesg输出"></a>6 查看dmesg输出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">[root@ss ko_example]<span class="hljs-meta"># dmesg</span><br>[ <span class="hljs-number">3897.130103</span>] ko_example:Hello, World!<br>[ <span class="hljs-number">3977.961346</span>] ko_example: Goodbye, World!<br>[ <span class="hljs-number">4898.483268</span>] perf: interrupt took too <span class="hljs-title function_">long</span> <span class="hljs-params">(<span class="hljs-number">8862</span> &gt; <span class="hljs-number">8847</span>)</span>, lowering kernel.perf_event_max_sample_rate to 22000<br>[ 5622.473621] ko_example: Hello, World!<br>[ 5627.830269] ko_example: Goodbye, World!<br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/06/image-1687768599191.png" alt="file"></p><h2 id="7-查看模块信息"><a href="#7-查看模块信息" class="headerlink" title="7 查看模块信息"></a>7 查看模块信息</h2><p>可以看到作者、内核版本等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@ss ko_example]# modinfo ko_example<br>filename:       /lib/modules/3.10.0-1160.el7.x86_64/kernel/ko_example.ko<br>version:        1.0<br>description:    A simple example Linux module.<br>author:         lyy<br>license:        GPL<br>retpoline:      Y<br>rhelversion:    7.9<br>srcversion:     F710CBEBAE01EEEF51C4087<br>depends:<br>vermagic:       3.10.0-1160.el7.x86_64 SMP mod_unload modversions<br></code></pre></td></tr></table></figure><h2 id="8-参考文献"><a href="#8-参考文献" class="headerlink" title="8 参考文献"></a>8 参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/420194002">如何编写一个Linux内核模块，这次手把手教你 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/438216195">深入分析Linux kernel安全特性: 内核模块签名 - 知乎 (zhihu.com)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>内核开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OVMF-CentOS使用ovmf作为qemu的uefi启动虚拟机</title>
    <link href="/045.html"/>
    <url>/045.html</url>
    
    <content type="html"><![CDATA[<h2 id="CentOS使用ovmf作为qemu的uefi启动虚拟机"><a href="#CentOS使用ovmf作为qemu的uefi启动虚拟机" class="headerlink" title="CentOS使用ovmf作为qemu的uefi启动虚拟机"></a>CentOS使用ovmf作为qemu的uefi启动虚拟机</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>我们通常使用QEMU启动虚拟机都是使用SeaBIOS，这是一种BIOS的开源实现，UEFI作为BIOS的发展，那有没有UEFI的呢？答案是有-那就是OVMF。</p><blockquote><p>chatgpt：OVMF是一种UEFI（统一固件接口）实现，它是一个用于在虚拟环境中运行EFI（可扩展固件接口）固件的开源项目。OVMF被广泛用于虚拟机监视器（例如QEMU）中，以提供更现代和灵活的UEFI固件支持，以代替传统的BIOS。OVMF源代码托管在GitHub上，由EDK II（UEFI开发工具包）维护和开发。OVMF支持多种虚拟化平台，包括QEMU、VirtualBox、VMware和Xen等。如果您需要在虚拟环境中运行UEFI固件，可以考虑使用OVMF。</p></blockquote><p>OVMF：官方仓库：<a href="https://github.com/tianocore/edk2">https://github.com/tianocore/edk2</a></p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install make gcc uuid-devel g++ git<br>yum install libuuid-devel<br>yum install nasm -y<br>yum install acpica-tools<br></code></pre></td></tr></table></figure><p>因为我用的是CentOS7.6，默认安装的版本gcc版本是4.8.5，目前edk2仓库中最新的版本编译存在一定的问题，因此我选择了tag分支中的202008的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/tianocore/edk2.git<br>cd edk2<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看远端tag</span><br>git ls-remote --tags<br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到远端tag，并新建本地分支命名202008</span><br>git checkout tags/edk2-stable202008 -b 202008<br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地checkout</span><br>git checkout 202008<br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新子模块</span><br>git submodule update --init<br></code></pre></td></tr></table></figure><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>1、准备环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编译工具包</span><br>make -C BaseTools<br><span class="hljs-meta prompt_"># </span><span class="language-bash">edk2根目录下设置环境脚本</span><br>source ./edksetup.sh<br></code></pre></td></tr></table></figure><p>该脚本运行后，会在Conf&#x2F;目录下生成target.txt配置文件，该文件对应了要生成的UEFI的目标平台架构、构建toolschain版本。</p><p>2、修改Conf&#x2F;target.txt文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim Conf/target.txt<br></code></pre></td></tr></table></figure><p>官方举例：Example: <code>Conf/target.txt</code> values to build x64 UEFI image for OVMF using GCC5 compiler:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ACTIVE_PLATFORM       = OvmfPkg/OvmfPkgX64.dsc<br>TARGET_ARCH           = X64<br>TOOL_CHAIN_TAG        = GCC5<br></code></pre></td></tr></table></figure><p>我们的运行目标架构是x86，gcc4.8 做如下修改，文件其他内容保持不变。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ACTIVE_PLATFORM       = OvmfPkg/OvmfPkgX64.dsc<br>TARGET_ARCH           = X64<br>TOOL_CHAIN_TAG        = GCC48<br></code></pre></td></tr></table></figure><p>在Conf&#x2F;tools_def.txt里，有EdkII支持的所有toolchain的详细信息。每个toolchain由一个关键字表示，比如VS2015, GCC45, CLANG38等，TOOL_CHAIN_TAG的赋值只能是这些关键字中的一个。如果开发者需要支持一个新的toolchain，则至少需要修改BaseTools&#x2F;Conf里的build_rule.template和tools_def.template，他们会在edksetup步骤中被复制到Conf目录。</p><p>目前EdkII支持的GCC版本从4.4到5.x，对应的toolchain关键字是GCC44, GCC45, … GCC5。实例平台Ubuntu 14.04所带gcc版本为4.8，所以TOOL_CHAIN_TAG选择GCC48。</p><p>在target.txt设置好构建目标后，环境设置就完成了。</p><h3 id="构建编译"><a href="#构建编译" class="headerlink" title="构建编译"></a>构建编译</h3><p>准备好环境之后，直接在edk2根目录下，执行build命令就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">build<br></code></pre></td></tr></table></figure><p>build会去读取Conf&#x2F;target.txt文件，也可以不读取使用命令行的方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">build -t GCC48 -a X64 -p OvmfPkg/OvmfPkgX64.dsc -b <br></code></pre></td></tr></table></figure><p>编译完成以后，可以在Build&#x2F;OvmfX64&#x2F;DEBUG_GCC48&#x2F;FV&#x2F;目录下找到生成UEFI文件OVMF.fd。</p><h3 id="测试是否能通过UEFI启动虚拟机"><a href="#测试是否能通过UEFI启动虚拟机" class="headerlink" title="测试是否能通过UEFI启动虚拟机"></a>测试是否能通过UEFI启动虚拟机</h3><p>直接将原来虚拟机运行命令的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-bios seabios-tpm/out/bios.bin<br></code></pre></td></tr></table></figure><p>修改为：即可运行，不过需要操作系统支持UEFI启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">--bios Build/OvmfX64/DEBUG_GCC48/FV/OVMF.fd<br></code></pre></td></tr></table></figure><p>启动界面：</p><p><img src="/wp-content/uploads/2023/06/image-1687331088951.png" alt="file"></p><h3 id="编译时启用TPM功能"><a href="#编译时启用TPM功能" class="headerlink" title="编译时启用TPM功能"></a>编译时启用TPM功能</h3><p>添加<code>-D TPM2_ENABLE -D TPM2_CONFIG_ENABLE</code>选项即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">build -p OvmfPkg/OvmfPkgX64.dsc -a X64  -b DEBUG -t GCC5  -D TPM2_ENABLE -D TPM2_CONFIG_ENABLE<br></code></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://github.com/tianocore/tianocore.github.io/wiki/How-to-build-OVMF">https://github.com/tianocore/tianocore.github.io/wiki/How-to-build-OVMF</a></li><li><a href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF">https://github.com/tianocore/tianocore.github.io/wiki/OVMF</a></li><li><a href="https://www.cnblogs.com/zhumengke/articles/10635772.html">Linux&#x2F;GNU toolchain 环境下的UEFI开发和调试 - 逐梦客！ - 博客园 (cnblogs.com)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
      <category>SeaBIOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UEFI</tag>
      
      <tag>BIOS</tag>
      
      <tag>OVMF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本站侧栏公告-包含时间粒子特效代码</title>
    <link href="/003.html"/>
    <url>/003.html</url>
    
    <content type="html"><![CDATA[<p>直接粘贴以下代码放到-小工具-html代码中即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size: x-small;font-weight: 500;&quot;</span>&gt;</span>本站所用图片来源于网络，如有侵权或者不符合国家法律法规规定的，请联系本站站主删除（网站右下角有联系方式），<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>维护清朗网络空间，人人有责！<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>请勿在评论区发布任何违法违规内容！所有评论内容，均需审核才能发布。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size: x-small;font-weight: 500;&quot;</span>&gt;</span>此外，欢迎大家交流学习，互换友链，请到留言页😊<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-content&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:300px;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;canvas&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:100%;&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;820&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;250&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">var</span> t=<span class="hljs-number">820</span>;<span class="hljs-keyword">var</span> a=<span class="hljs-number">250</span>;<span class="hljs-keyword">var</span> r=<span class="hljs-number">7</span>;<span class="hljs-keyword">var</span> n=<span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> e=<span class="hljs-number">.65</span>;<span class="hljs-keyword">var</span> f;<span class="hljs-keyword">var</span> o=[];<span class="hljs-keyword">const</span> v=[<span class="hljs-string">&quot;#33B5E5&quot;</span>,<span class="hljs-string">&quot;#0099CC&quot;</span>,<span class="hljs-string">&quot;#AA66CC&quot;</span>,<span class="hljs-string">&quot;#9933CC&quot;</span>,<span class="hljs-string">&quot;#99CC00&quot;</span>,<span class="hljs-string">&quot;#669900&quot;</span>,<span class="hljs-string">&quot;#FFBB33&quot;</span>,<span class="hljs-string">&quot;#FF8800&quot;</span>,<span class="hljs-string">&quot;#FF4444&quot;</span>,<span class="hljs-string">&quot;#CC0000&quot;</span>];<span class="hljs-keyword">var</span> h=[];<span class="hljs-keyword">var</span> u=[[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]],[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]],[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]],[[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]],[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]],[[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]],[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]],[[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]],[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]],[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]],[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]];<span class="hljs-keyword">function</span> <span class="hljs-title function_">l</span>(<span class="hljs-params">t</span>)&#123;<span class="hljs-keyword">var</span> a=[];f.<span class="hljs-property">fillStyle</span>=<span class="hljs-string">&quot;#005EAC&quot;</span>;<span class="hljs-keyword">var</span> r=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>;<span class="hljs-keyword">var</span> e=<span class="hljs-number">70</span>,o=<span class="hljs-number">30</span>;<span class="hljs-keyword">var</span> v=r.<span class="hljs-title function_">getHours</span>();<span class="hljs-keyword">var</span> u=<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(v/<span class="hljs-number">10</span>);<span class="hljs-keyword">var</span> l=v%<span class="hljs-number">10</span>;a.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">num</span>:u&#125;);a.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">num</span>:l&#125;);a.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">num</span>:<span class="hljs-number">10</span>&#125;);<span class="hljs-keyword">var</span> c=r.<span class="hljs-title function_">getMinutes</span>();<span class="hljs-keyword">var</span> u=<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(c/<span class="hljs-number">10</span>);<span class="hljs-keyword">var</span> l=c%<span class="hljs-number">10</span>;a.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">num</span>:u&#125;);a.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">num</span>:l&#125;);a.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">num</span>:<span class="hljs-number">10</span>&#125;);<span class="hljs-keyword">var</span> M=r.<span class="hljs-title function_">getSeconds</span>();<span class="hljs-keyword">var</span> u=<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(M/<span class="hljs-number">10</span>);<span class="hljs-keyword">var</span> l=M%<span class="hljs-number">10</span>;a.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">num</span>:u&#125;);a.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">num</span>:l&#125;);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> p=<span class="hljs-number">0</span>;p&lt;a.<span class="hljs-property">length</span>;p++)&#123;a[p].<span class="hljs-property">offsetX</span>=e;e=<span class="hljs-title function_">m</span>(e,o,a[p].<span class="hljs-property">num</span>,t);<span class="hljs-keyword">if</span>(p&lt;a.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(a[p].<span class="hljs-property">num</span>!=<span class="hljs-number">10</span>&amp;&amp;a[p+<span class="hljs-number">1</span>].<span class="hljs-property">num</span>!=<span class="hljs-number">10</span>)&#123;e+=n&#125;&#125;&#125;<span class="hljs-keyword">if</span>(h.<span class="hljs-property">length</span>==<span class="hljs-number">0</span>)&#123;h=a&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> C=<span class="hljs-number">0</span>;C&lt;h.<span class="hljs-property">length</span>;C++)&#123;<span class="hljs-keyword">if</span>(h[C].<span class="hljs-property">num</span>!=a[C].<span class="hljs-property">num</span>)&#123;<span class="hljs-title function_">s</span>(a[C]);h[C].<span class="hljs-property">num</span>=a[C].<span class="hljs-property">num</span>&#125;&#125;&#125;<span class="hljs-title function_">i</span>(t);<span class="hljs-title function_">g</span>();<span class="hljs-keyword">return</span> r&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">s</span>(<span class="hljs-params">t</span>)&#123;<span class="hljs-keyword">var</span> a=t.<span class="hljs-property">num</span>;<span class="hljs-keyword">var</span> n=u[a];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> e=<span class="hljs-number">0</span>;e&lt;n.<span class="hljs-property">length</span>;e++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> f=<span class="hljs-number">0</span>;f&lt;n[e].<span class="hljs-property">length</span>;f++)&#123;<span class="hljs-keyword">if</span>(n[e][f]==<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">var</span> h=&#123;<span class="hljs-attr">offsetX</span>:t.<span class="hljs-property">offsetX</span>+r+r*<span class="hljs-number">2</span>*f,<span class="hljs-attr">offsetY</span>:<span class="hljs-number">30</span>+r+r*<span class="hljs-number">2</span>*e,<span class="hljs-attr">color</span>:v[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()*v.<span class="hljs-property">length</span>)],<span class="hljs-attr">g</span>:<span class="hljs-number">1.5</span>+<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(),<span class="hljs-attr">vx</span>:<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(-<span class="hljs-number">1</span>,<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()*<span class="hljs-number">10</span>))*<span class="hljs-number">4</span>+<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(),<span class="hljs-attr">vy</span>:-<span class="hljs-number">5</span>&#125;;o.<span class="hljs-title function_">push</span>(h)&#125;&#125;&#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">i</span>(<span class="hljs-params">t</span>)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> a=<span class="hljs-number">0</span>;a&lt;o.<span class="hljs-property">length</span>;a++)&#123;t.<span class="hljs-title function_">beginPath</span>();t.<span class="hljs-property">fillStyle</span>=o[a].<span class="hljs-property">color</span>;t.<span class="hljs-title function_">arc</span>(o[a].<span class="hljs-property">offsetX</span>,o[a].<span class="hljs-property">offsetY</span>,r,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>);t.<span class="hljs-title function_">fill</span>()&#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">var</span> n=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> f=<span class="hljs-number">0</span>;f&lt;o.<span class="hljs-property">length</span>;f++)&#123;<span class="hljs-keyword">var</span> v=o[f];v.<span class="hljs-property">offsetX</span>+=v.<span class="hljs-property">vx</span>;v.<span class="hljs-property">offsetY</span>+=v.<span class="hljs-property">vy</span>;v.<span class="hljs-property">vy</span>+=v.<span class="hljs-property">g</span>;<span class="hljs-keyword">if</span>(v.<span class="hljs-property">offsetY</span>&gt;a-r)&#123;v.<span class="hljs-property">offsetY</span>=a-r;v.<span class="hljs-property">vy</span>=-v.<span class="hljs-property">vy</span>*e&#125;<span class="hljs-keyword">if</span>(v.<span class="hljs-property">offsetX</span>&gt;r&amp;&amp;v.<span class="hljs-property">offsetX</span>&lt;t-r)&#123;o[n]=o[f];n++&#125;&#125;<span class="hljs-keyword">for</span>(;n&lt;o.<span class="hljs-property">length</span>;n++)&#123;o.<span class="hljs-title function_">pop</span>()&#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">m</span>(<span class="hljs-params">t,a,n,e</span>)&#123;<span class="hljs-keyword">var</span> f=u[n];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> o=<span class="hljs-number">0</span>;o&lt;f.<span class="hljs-property">length</span>;o++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> v=<span class="hljs-number">0</span>;v&lt;f[o].<span class="hljs-property">length</span>;v++)&#123;<span class="hljs-keyword">if</span>(f[o][v]==<span class="hljs-number">1</span>)&#123;e.<span class="hljs-title function_">beginPath</span>();e.<span class="hljs-title function_">arc</span>(t+r+r*<span class="hljs-number">2</span>*v,a+r+r*<span class="hljs-number">2</span>*o,r,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>);e.<span class="hljs-title function_">fill</span>()&#125;&#125;&#125;e.<span class="hljs-title function_">beginPath</span>();t+=f[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>*r*<span class="hljs-number">2</span>;<span class="hljs-keyword">return</span> t&#125;<span class="hljs-keyword">var</span> c=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;canvas&quot;</span>);c.<span class="hljs-property">width</span>=t;c.<span class="hljs-property">height</span>=a;f=c.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);<span class="hljs-keyword">var</span> M=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>;<span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;f.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,f.<span class="hljs-property">canvas</span>.<span class="hljs-property">width</span>,f.<span class="hljs-property">canvas</span>.<span class="hljs-property">height</span>);<span class="hljs-title function_">l</span>(f)&#125;,<span class="hljs-number">50</span>)&#125;)();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果图： <img src="/wp-content/uploads/2023/06/image-1687250646990.png" alt="file"></p><p>参考链接：<a href="https://blog.csdn.net/m0_66047725/article/details/127327213">https://blog.csdn.net/m0_66047725&#x2F;article&#x2F;details&#x2F;127327213</a></p>]]></content>
    
    
    <categories>
      
      <category>好用工具</category>
      
      <category>wordpress使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二次元随机api记录</title>
    <link href="/0023.html"/>
    <url>/0023.html</url>
    
    <content type="html"><![CDATA[<h2 id="盒子萌-主题自带"><a href="#盒子萌-主题自带" class="headerlink" title="盒子萌(主题自带)"></a>盒子萌(主题自带)</h2><ul><li><a href="https://api.boxmoe.com/random.php">https://api.boxmoe.com/random.php</a></li></ul><h2 id="LoliAPi"><a href="#LoliAPi" class="headerlink" title="LoliAPi"></a>LoliAPi</h2><ul><li>官方文档：<a href="https://docs.loliapi.com/api-shi-yong-wen-dang/sui-ji-er-ci-yuan-tu-pian/page-2">https://docs.loliapi.com/api-shi-yong-wen-dang/sui-ji-er-ci-yuan-tu-pian/page-2</a></li><li><a href="https://www.loliapi.com/bg/">https://www.loliapi.com/bg/</a></li></ul><h2 id="樱道："><a href="#樱道：" class="headerlink" title="樱道："></a>樱道：</h2><ul><li><a href="https://img.r10086.com/">https://img.r10086.com/</a></li><li><a href="https://api.r10086.com/%E6%A8%B1%E9%81%93%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87api%E6%8E%A5%E5%8F%A3.php?%E8%87%AA%E9%80%82%E5%BA%94%E5%9B%BE%E7%89%87%E7%B3%BB%E5%88%97=%E5%8E%9F%E7%A5%9E">https://api.r10086.com/樱道随机图片api接口.php?自适应图片系列=原神</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>好用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>wordpress lolimeow主题去掉阴影</title>
    <link href="/052.html"/>
    <url>/052.html</url>
    
    <content type="html"><![CDATA[<h2 id="去掉主题banner图的阴影遮罩"><a href="#去掉主题banner图的阴影遮罩" class="headerlink" title="去掉主题banner图的阴影遮罩"></a>去掉主题banner图的阴影遮罩</h2><p>可以看到现在是有的， <img src="/wp-content/uploads/2023/06/image-1686978425051.jpg" alt="file"></p><p>F12找到源码： <img src="/wp-content/uploads/2023/06/image-1686978464002.jpg" alt="file"> 发现是在&#x2F;wp-content&#x2F;themes&#x2F;lolimeow-master&#x2F;assets&#x2F;css目录下的style.css中，最简单的方式直接修改宽度和高度即可： <img src="/wp-content/uploads/2023/06/image-1686978501784.png" alt="file"></p><p>备份：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.section-shaped</span><span class="hljs-selector-pseudo">:after</span>,<span class="hljs-selector-class">.section-shaped</span><span class="hljs-selector-pseudo">:before</span> &#123;<span class="hljs-attribute">position</span>:absolute;<span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;<span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAKUlEQVQImU3IMREAIAgAwJfNkQCEsH8cijjpMf6vnXlQaIiJFx+omEBfmqIEZLe2jzcAAAAASUVORK5CYII=</span>);&#125;<br></code></pre></td></tr></table></figure><p>修改：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.section-shaped</span><span class="hljs-selector-pseudo">:after</span>,<span class="hljs-selector-class">.section-shaped</span><span class="hljs-selector-pseudo">:before</span> &#123;<span class="hljs-attribute">position</span>:absolute;<span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">10%</span>;<span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAKUlEQVQImU3IMREAIAgAwJfNkQCEsH8cijjpMf6vnXlQaIiJFx+omEBfmqIEZLe2jzcAAAAASUVORK5CYII=</span>);&#125;<br></code></pre></td></tr></table></figure><h2 id="修改版本"><a href="#修改版本" class="headerlink" title="修改版本"></a>修改版本</h2><p>修改style.css让他生效，不然怎么获取都是修改前的，改nginx，删除浏览器缓存都不管用。如下图，修改VESION版本号。 <img src="/wp-content/uploads/2023/06/image-1686981947322.png" alt="file"></p><h2 id="生效情况"><a href="#生效情况" class="headerlink" title="生效情况"></a>生效情况</h2><p><img src="/wp-content/uploads/2023/06/image-1686982146490.jpg" alt="file"> 这样就去除了，大部分的阴影部分。大功告成</p>]]></content>
    
    
    <categories>
      
      <category>wordpress使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wordpress主题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SeaBIOS调用 vTPM启动过程</title>
    <link href="/049.html"/>
    <url>/049.html</url>
    
    <content type="html"><![CDATA[<h1 id="SeaBIOS调用-vTPM启动过程"><a href="#SeaBIOS调用-vTPM启动过程" class="headerlink" title="SeaBIOS调用 vTPM启动过程"></a>SeaBIOS调用 vTPM启动过程</h1><p>要了解可信启动的过程，不能单单在“边启动，边度量”，都说CRTM是信任源头，但是它又是BIOS的一部分，那么他们之间是怎么度量的呢？度量哪儿呢？度量日志放在哪儿呢？ 首先是POST阶段的mianinit函数-&gt;platform_hardware_setup-&gt;tpm_setup()</p><h2 id="tpm-setup"><a href="#tpm-setup" class="headerlink" title="tpm_setup"></a>tpm_setup</h2><p>对于tpm_setup，用于初始化可信计算模块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">tpm_setup</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!CONFIG_TCGBIOS)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">//探测tpm2设备</span><br>    <span class="hljs-type">int</span> ret = tpm_tpm2_probe();<br>    <span class="hljs-keyword">if</span> (ret) &#123;<br>        <span class="hljs-comment">//探测tpm1.2设备</span><br>        ret = tpm_tcpa_probe();<br>        <span class="hljs-keyword">if</span> (ret)<br>            <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//获取TPM版本 u8 TPM_version 并且调用相应驱动的init方法，tis_init或者crb_init</span><br>    TPM_version = tpmhw_probe();<br>    <span class="hljs-keyword">if</span> (TPM_version == TPM_VERSION_NONE)<br>        <span class="hljs-keyword">return</span>;<br><br>    dprintf(DEBUG_tcg,<br>            <span class="hljs-string">&quot;TCGBIOS: Detected a TPM %s.\n&quot;</span>,<br>             (TPM_version == TPM_VERSION_1_2) ? <span class="hljs-string">&quot;1.2&quot;</span> : <span class="hljs-string">&quot;2&quot;</span>);<br><br>    TPM_working = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (runningOnXen())<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">//初始化TPM</span><br>    ret = tpm_startup();<br>    <span class="hljs-keyword">if</span> (ret)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">//度量smbios</span><br>    tpm_smbios_measure();<br>    <span class="hljs-comment">//度量EV_ACTION事件，扩展进入PCR 2寄存器</span><br>    tpm_add_action(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Start Option ROM Scan&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，他先获取了平台上的TPM版本，然后在进行TPM初始化，接着度量smbios添加度量日志。我们看一下细节，它是怎样获取到TPM版本的？以TPM2为例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">tpm_tpm2_probe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//从acpi表中获取标识符</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpm2_descriptor_rev2</span> *<span class="hljs-title">tpm2</span> =</span> find_acpi_table(TPM2_SIGNATURE);<br>    <span class="hljs-keyword">if</span> (!tpm2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (tpm2-&gt;length &lt; <span class="hljs-number">76</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    dprintf(DEBUG_tcg, <span class="hljs-string">&quot;TCGBIOS: TPM2: LASA = %p, LAML = %u\n&quot;</span>,<br>            (u8 *)(<span class="hljs-type">long</span>)tpm2-&gt;log_area_start_address,<br>            tpm2-&gt;log_area_minimum_length);<br><br>    <span class="hljs-comment">//设置日志区域</span><br>    <span class="hljs-keyword">return</span> tpm_set_log_area((u8*)(<span class="hljs-type">long</span>)tpm2-&gt;log_area_start_address,<br>                            tpm2-&gt;log_area_minimum_length);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，从acpi表中获取TPM2_SIGNATURE标识的TPM2描述符，找到之后就判断长度是否符合要求，然后就调用<code>tpm_set_log_area</code>函数，该函数将设置TPM的日志区域并返回0以表示成功。</p><h2 id="tpmhw-probe"><a href="#tpmhw-probe" class="headerlink" title="tpmhw_probe"></a>tpmhw_probe</h2><p>该函数获取TPM版本 TPM_version 并且调用相应驱动的init方法，tis_init或者crb_init。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">TPMVersion<br><span class="hljs-title function_">tpmhw_probe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; TPM_NUM_DRIVERS; i++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpm_driver</span> *<span class="hljs-title">td</span> =</span> &amp;tpm_drivers[i];<br>        <span class="hljs-comment">//调用相应的probe方法</span><br>        <span class="hljs-keyword">if</span> (td-&gt;probe() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//调用相应的tis_init或者crb_init方法</span><br>            td-&gt;init();<br>            TPMHW_driver_to_use = i;<br>            <span class="hljs-keyword">return</span> td-&gt;get_tpm_version();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TPM_VERSION_NONE;<br>&#125;<br></code></pre></td></tr></table></figure><p>在qemu-tpm-2.12中，所有的与driver相关的代码，在seaBIOS中的<code>src/hw/tpm_drivers.c</code>之中。给出tpm_drivers的定义，可以看到tpm驱动分为tis和crb，crb只支持2.0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpm_driver</span> <span class="hljs-title">tpm_drivers</span>[<span class="hljs-title">TPM_NUM_DRIVERS</span>] =</span> &#123;<br>    [TIS_DRIVER_IDX] =<br>        &#123;<br>            .timeouts      = <span class="hljs-literal">NULL</span>,<br>            .durations     = <span class="hljs-literal">NULL</span>,<br>            .set_timeouts  = set_timeouts,<br>            .probe         = tis_probe,<br>            .get_tpm_version = tis_get_tpm_version,<br>            .init          = tis_init,<br>            .activate      = tis_activate,<br>            .ready         = tis_ready,<br>            .senddata      = tis_senddata,<br>            .readresp      = tis_readresp,<br>            .waitdatavalid = tis_waitdatavalid,<br>            .waitrespready = tis_waitrespready,<br>        &#125;,<br>    [CRB_DRIVER_IDX] =<br>        &#123;<br>            .timeouts      = <span class="hljs-literal">NULL</span>,<br>            .durations     = <span class="hljs-literal">NULL</span>,<br>            .set_timeouts  = set_timeouts,<br>            .probe         = crb_probe,<br>            .get_tpm_version = crb_get_tpm_version,<br>            .init          = crb_init,<br>            .activate      = crb_activate,<br>            .ready         = crb_ready,<br>            .senddata      = crb_senddata,<br>            .readresp      = crb_readresp,<br>            .waitdatavalid = crb_waitdatavalid,<br>            .waitrespready = crb_waitrespready,<br>        &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="tpm-startup"><a href="#tpm-startup" class="headerlink" title="tpm_startup"></a>tpm_startup</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">tpm_startup</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">switch</span> (TPM_version) &#123;<br>    <span class="hljs-keyword">case</span> TPM_VERSION_1_2:<br>        <span class="hljs-keyword">return</span> tpm12_startup();<br>    <span class="hljs-keyword">case</span> TPM_VERSION_2:<br>        <span class="hljs-keyword">return</span> tpm20_startup();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们都以TPM2.0为例，在确认TPM版本之后，初始化TPM。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">tpm20_startup</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//设置超时时间</span><br>    tpm20_set_timeouts();<br><br>    <span class="hljs-comment">//发送TPM2_CC_Startup命令，以清除TPM设备并返回一个结果，该结果存储在ret变量中</span><br>    <span class="hljs-type">int</span> ret = tpm_simple_cmd(<span class="hljs-number">0</span>, TPM2_CC_Startup,<br>                             <span class="hljs-number">2</span>, TPM2_SU_CLEAR, TPM_DURATION_TYPE_SHORT);<br><br>    dprintf(DEBUG_tcg, <span class="hljs-string">&quot;TCGBIOS: Return value from sending TPM2_CC_Startup(SU_CLEAR) = 0x%08x\n&quot;</span>,<br>            ret);<br><br>    <span class="hljs-comment">//在coreboot已经启用的情况下，但是我们没有使用这里不用看</span><br>    <span class="hljs-keyword">if</span> (CONFIG_COREBOOT &amp;&amp; ret == TPM2_RC_INITIALIZE)<br>        <span class="hljs-comment">/* with other firmware on the system the TPM may already have been</span><br><span class="hljs-comment">         * initialized</span><br><span class="hljs-comment">         */</span><br>        ret = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (ret)<br>        <span class="hljs-keyword">goto</span> err_exit;<br><br>    <span class="hljs-comment">//发送TPM自检命令</span><br>    ret = tpm_simple_cmd(<span class="hljs-number">0</span>, TPM2_CC_SelfTest,<br>                         <span class="hljs-number">1</span>, TPM2_YES, TPM_DURATION_TYPE_LONG);<br><br>    dprintf(DEBUG_tcg, <span class="hljs-string">&quot;TCGBIOS: Return value from sending TPM2_CC_SelfTest = 0x%08x\n&quot;</span>,<br>            ret);<br><br>    <span class="hljs-keyword">if</span> (ret)<br>        <span class="hljs-keyword">goto</span> err_exit;<br><br>    <span class="hljs-comment">//获取相应的pcrbanks</span><br>    ret = tpm20_get_pcrbanks();<br>    <span class="hljs-keyword">if</span> (ret)<br>        <span class="hljs-keyword">goto</span> err_exit;<br><br>    <span class="hljs-comment">//写入相应的efi事件结构</span><br>    ret = tpm20_write_EfiSpecIdEventStruct();<br>    <span class="hljs-keyword">if</span> (ret)<br>        <span class="hljs-keyword">goto</span> err_exit;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//失败处理    </span><br>err_exit:<br>    dprintf(DEBUG_tcg, <span class="hljs-string">&quot;TCGBIOS: TPM malfunctioning (line %d).\n&quot;</span>, __LINE__);<br><br>    tpm_set_failure();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tpm-simple-cmd"><a href="#tpm-simple-cmd" class="headerlink" title="tpm_simple_cmd"></a>tpm_simple_cmd</h3><p>发送简单的TPM命令，如果使用swtpm作为TPM那么会通过qemu后端驱动发送出去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">tpm_simple_cmd</span><span class="hljs-params">(u8 locty, u32 ordinal</span><br><span class="hljs-params">               , <span class="hljs-type">int</span> param_size, u16 param, <span class="hljs-keyword">enum</span> tpmDurationType <span class="hljs-type">to_t</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpm_req_header</span> <span class="hljs-title">trqh</span>;</span><br>        u16 param;<br>    &#125; PACKED req = &#123;<br>        .trqh.totlen = cpu_to_be32(<span class="hljs-keyword">sizeof</span>(req.trqh) + param_size),<br>        .trqh.ordinal = cpu_to_be32(ordinal),<br>        .param = param_size == <span class="hljs-number">2</span> ? cpu_to_be16(param) : param,<br>    &#125;;<br>    <span class="hljs-keyword">switch</span> (TPM_version) &#123;<br>    <span class="hljs-keyword">case</span> TPM_VERSION_1_2:<br>        req.trqh.tag = cpu_to_be16(TPM_TAG_RQU_CMD);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TPM_VERSION_2:<br>        req.trqh.tag = cpu_to_be16(TPM2_ST_NO_SESSIONS);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    u8 obuffer[<span class="hljs-number">64</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpm_rsp_header</span> *<span class="hljs-title">trsh</span> =</span> (<span class="hljs-type">void</span>*)obuffer;<br>    u32 obuffer_len = <span class="hljs-keyword">sizeof</span>(obuffer);<br>    <span class="hljs-built_in">memset</span>(obuffer, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(obuffer));<br><br>    <span class="hljs-comment">//组装好请求后，发送请求。</span><br>    <span class="hljs-type">int</span> ret = tpmhw_transmit(locty, &amp;req.trqh, obuffer, &amp;obuffer_len, <span class="hljs-type">to_t</span>);<br>    ret = ret ? <span class="hljs-number">-1</span> : be32_to_cpu(trsh-&gt;errcode);<br>    dprintf(DEBUG_tcg, <span class="hljs-string">&quot;Return from tpm_simple_cmd(%x, %x) = %x\n&quot;</span>,<br>            ordinal, param, ret);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>可看到tpmhw_transmit方法才是发送命令的关键。</p><h4 id="tpmhw-transmit"><a href="#tpmhw-transmit" class="headerlink" title="tpmhw_transmit"></a>tpmhw_transmit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">tpmhw_transmit</span><span class="hljs-params">(u8 locty, <span class="hljs-keyword">struct</span> tpm_req_header *req,</span><br><span class="hljs-params">               <span class="hljs-type">void</span> *respbuffer, u32 *respbufferlen,</span><br><span class="hljs-params">               <span class="hljs-keyword">enum</span> tpmDurationType <span class="hljs-type">to_t</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (TPMHW_driver_to_use == TPM_INVALID_DRIVER)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpm_driver</span> *<span class="hljs-title">td</span> =</span> &amp;tpm_drivers[TPMHW_driver_to_use];<br><br>    <span class="hljs-comment">//函数用于激活TPM设备的TIS接口，请求并等待访问权限，如果访问权限已被获取，则该函数返回0，否则返回非零结果表示激活失败。</span><br>    u32 irc = td-&gt;activate(locty);<br>    <span class="hljs-keyword">if</span> (irc != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/* tpm could not be activated */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//发送数据</span><br>    irc = td-&gt;senddata((<span class="hljs-type">void</span>*)req, be32_to_cpu(req-&gt;totlen));<br>    <span class="hljs-keyword">if</span> (irc != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">//在超时时间内等待状态寄存器值被设置，等待返回数据</span><br>    irc = td-&gt;waitdatavalid();<br>    <span class="hljs-keyword">if</span> (irc != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">//在超时时间内等待数据寄存器值被设置，可以读取数据</span><br>    irc = td-&gt;waitrespready(<span class="hljs-type">to_t</span>);<br>    <span class="hljs-keyword">if</span> (irc != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">//读取返回响应数据</span><br>    irc = td-&gt;readresp(respbuffer, respbufferlen);<br>    <span class="hljs-keyword">if</span> (irc != <span class="hljs-number">0</span> <br>        *respbufferlen &lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> tpm_rsp_header))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    td-&gt;ready();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到发送命令分为6个主要函数,activate、senddata、waitdatavalid、waitrespready、readresp以及ready。</p><h5 id="tis-activate"><a href="#tis-activate" class="headerlink" title="tis_activate"></a>tis_activate</h5><blockquote><p>TPM（Trusted Platform Module）是一个专门的安全硬件模块，它用于在计算设备中提供硬件级别的安全功能，例如密钥生成、加密、解密和数字签名。TPM通常用于确保计算平台的完整性和认证。</p><p>TPM的Localities是一种访问控制机制，用于在TPM内部区分不同安全级别的访问权限。Localities的概念是为了支持多种安全执行环境（例如BIOS、操作系统、虚拟化平台等）共享TPM资源，同时确保这些环境之间的隔离和安全性。</p><p>TPM中有五个不同的Localities，编号为0到4。它们的安全级别是递增的，即Localities 0具有最低的安全级别，而Localities 4具有最高的安全级别。这些不同的Localities可以用于控制对TPM资源的访问。例如，某些敏感操作可能只允许在具有较高Localities级别的环境中执行。</p><p>总结一下，TPM的Localities是一种区分不同安全级别访问权限的机制，用于支持多种安全执行环境共享TPM资源，同时保证环境之间的隔离和安全性。</p></blockquote><p>主要作用就是激活对应的locality</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//u8类型的locty，表示要激活的locality编号（0到4之间的整数）</span><br><span class="hljs-type">static</span> u32 <span class="hljs-title function_">tis_activate</span><span class="hljs-params">(u8 locty)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!CONFIG_TCGBIOS)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    u32 rc = <span class="hljs-number">0</span>;<br>    u8 acc;<br>    <span class="hljs-type">int</span> l;<br>    u32 timeout_a = tpm_drivers[TIS_DRIVER_IDX].timeouts[TIS_TIMEOUT_TYPE_A];<br><br>    <span class="hljs-comment">//函数检查当前locality（locty）是否已被激活。如果没有被激活，它将释放所有正在使用的locality（从4到0），以便将当前locality设置为活动状态。</span><br>    <span class="hljs-keyword">if</span> (!(readb(TIS_REG(locty, TIS_REG_ACCESS)) &amp;<br>          TIS_ACCESS_ACTIVE_LOCALITY)) &#123;<br>        <span class="hljs-comment">/* release locality in use top-downwards */</span><br>        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">4</span>; l &gt;= <span class="hljs-number">0</span>; l--)<br>            writeb(TIS_REG(l, TIS_REG_ACCESS),<br>                   TIS_ACCESS_ACTIVE_LOCALITY);<br>    &#125;<br><br>    <span class="hljs-comment">/* request access to locality */</span><br>    <span class="hljs-comment">//请求访问指定的locality（locty），通过向TIS_REG_ACCESS寄存器写入TIS_ACCESS_REQUEST_USE值</span><br>    writeb(TIS_REG(locty, TIS_REG_ACCESS), TIS_ACCESS_REQUEST_USE);<br><br>    <span class="hljs-comment">//函数读取TIS_REG_ACCESS寄存器的值，检查已请求的locality是否已激活。</span><br>    <span class="hljs-comment">//如果成功激活，函数将TIS_REG_STS寄存器设置为TIS_STS_COMMAND_READY，并调用tis_wait_sts函数等待状态寄存器的状态变为TIS_STS_COMMAND_READY。</span><br>    acc = readb(TIS_REG(locty, TIS_REG_ACCESS));<br>    <span class="hljs-keyword">if</span> ((acc &amp; TIS_ACCESS_ACTIVE_LOCALITY)) &#123;<br>        writeb(TIS_REG(locty, TIS_REG_STS), TIS_STS_COMMAND_READY);<br>        rc = tis_wait_sts(locty, timeout_a,<br>                          TIS_STS_COMMAND_READY, TIS_STS_COMMAND_READY);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> rc;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="tis-senddata"><a href="#tis-senddata" class="headerlink" title="tis-senddata"></a>tis-senddata</h5><p>tis驱动的主要发送函数，我们看一下是如何实现的？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u32 <span class="hljs-title function_">tis_senddata</span><span class="hljs-params">(<span class="hljs-type">const</span> u8 *<span class="hljs-type">const</span> data, u32 len)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!CONFIG_TCGBIOS)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    u32 rc = <span class="hljs-number">0</span>;<br>    u32 offset = <span class="hljs-number">0</span>;<br>    u32 end_loop = <span class="hljs-number">0</span>;<br>    u16 burst = <span class="hljs-number">0</span>;<br>    u8 locty = tis_find_active_locality();<br>    u32 timeout_d = tpm_drivers[TIS_DRIVER_IDX].timeouts[TIS_TIMEOUT_TYPE_D];<br>    u32 end = timer_calc_usec(timeout_d);<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">while</span> (burst == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//循环从TIS_REG_STS读取要发送的字节数</span><br>               burst = readl(TIS_REG(locty, TIS_REG_STS)) &gt;&gt; <span class="hljs-number">8</span>;<br>            <span class="hljs-keyword">if</span> (burst == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (timer_check(end)) &#123;<br>                    warn_timeout();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                yield();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (burst == <span class="hljs-number">0</span>) &#123;<br>            rc = TCG_RESPONSE_TIMEOUT;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//循环向TIS_REG_DATA_FIFO中写入数据相应的数据</span><br>            writeb(TIS_REG(locty, TIS_REG_DATA_FIFO), data[offset++]);<br>            burst--;<br><br>            <span class="hljs-keyword">if</span> (burst == <span class="hljs-number">0</span>  offset == len)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (offset == len)<br>            end_loop = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">while</span> (end_loop == <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> rc;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：就是从TIS_REG_STS中获取要发送的字节数，然后将数据写入TIS_REG_DATA_FIFO之中。</p><h5 id="tis-waitdatavalid"><a href="#tis-waitdatavalid" class="headerlink" title="tis_waitdatavalid"></a>tis_waitdatavalid</h5><p>这个函数在超时时间内，等待返回数据，如果状态为没有被重新设置就会返回错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u32 <span class="hljs-title function_">tis_waitdatavalid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!CONFIG_TCGBIOS)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    u32 rc = <span class="hljs-number">0</span>;<br>    u8 locty = tis_find_active_locality();<br>    u32 timeout_c = tpm_drivers[TIS_DRIVER_IDX].timeouts[TIS_TIMEOUT_TYPE_C];<br><br>    <span class="hljs-comment">//tis_wait_sts() 函数等待 TPM 状态寄存器中指定的状态位（在本例中为 TIS_STS_VALID）被设置为可用，在指定的超时期限内设置状态位时返回 0。</span><br>    <span class="hljs-keyword">if</span> (tis_wait_sts(locty, timeout_c, TIS_STS_VALID, TIS_STS_VALID) != <span class="hljs-number">0</span>)<br>        rc = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> rc;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="tis-waitrespready"><a href="#tis-waitrespready" class="headerlink" title="tis_waitrespready"></a>tis_waitrespready</h5><p>在TIS_REG_STS被设置可用之后，将其设置为TIS_STS_TPM_GO，在超时期限内，<code>tis_wait_sts()</code> 函数等待 TPM 状态寄存器中指定的状态位（在本例中为 <code>TIS_STS_DATA_AVAILABLE</code>）被设置，在指定的超时期限内设置状态位时返回 0。如果在超时期限内状态位未被设置，则 <code>tis_wait_sts()</code> 返回非零的错误代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u32 <span class="hljs-title function_">tis_waitrespready</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> tpmDurationType <span class="hljs-type">to_t</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!CONFIG_TCGBIOS)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    u32 rc = <span class="hljs-number">0</span>;<br>    u8 locty = tis_find_active_locality();<br>    u32 timeout = tpm_drivers[TIS_DRIVER_IDX].durations[<span class="hljs-type">to_t</span>];<br><br>    writeb(TIS_REG(locty ,TIS_REG_STS), TIS_STS_TPM_GO);<br><br>    <span class="hljs-comment">//超时期限内等待TIS_STS_DATA_AVAILABLE为数据可用</span><br>    <span class="hljs-keyword">if</span> (tis_wait_sts(locty, timeout,<br>                     TIS_STS_DATA_AVAILABLE, TIS_STS_DATA_AVAILABLE) != <span class="hljs-number">0</span>)<br>        rc = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> rc;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="tis-readresp"><a href="#tis-readresp" class="headerlink" title="tis_readresp"></a>tis_readresp</h5><p>就是从TIS_REG_DATA_FIFO中读取数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> u32 <span class="hljs-title function_">tis_readresp</span><span class="hljs-params">(u8 *buffer, u32 *len)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!CONFIG_TCGBIOS)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    u32 rc = <span class="hljs-number">0</span>;<br>    u32 offset = <span class="hljs-number">0</span>;<br>    u32 sts;<br>    u8 locty = tis_find_active_locality();<br><br>    <span class="hljs-keyword">while</span> (offset &lt; *len) &#123;<br>        <span class="hljs-comment">//读取数据TIS_REG_DATA_FIFO</span><br>        buffer[offset] = readb(TIS_REG(locty, TIS_REG_DATA_FIFO));<br>        offset++;<br>        sts = readb(TIS_REG(locty, TIS_REG_STS));<br>        <span class="hljs-comment">/* data left ? */</span><br>        <span class="hljs-keyword">if</span> ((sts &amp; TIS_STS_DATA_AVAILABLE) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    *len = offset;<br><br>    <span class="hljs-keyword">return</span> rc;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="tis-ready"><a href="#tis-ready" class="headerlink" title="tis_ready"></a>tis_ready</h5><p>将locty设置为activate之后的状态。这样就不用下次继续activate了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u32 <span class="hljs-title function_">tis_ready</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!CONFIG_TCGBIOS)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    u32 rc = <span class="hljs-number">0</span>;<br>    u8 locty = tis_find_active_locality();<br>    u32 timeout_b = tpm_drivers[TIS_DRIVER_IDX].timeouts[TIS_TIMEOUT_TYPE_B];<br><br>    <span class="hljs-comment">//恢复TIS_REG_STS寄存器值为TIS_STS_COMMAND_READY，代表命令准备好了</span><br>    writeb(TIS_REG(locty, TIS_REG_STS), TIS_STS_COMMAND_READY);<br>    rc = tis_wait_sts(locty, timeout_b,<br>                      TIS_STS_COMMAND_READY, TIS_STS_COMMAND_READY);<br><br>    <span class="hljs-keyword">return</span> rc;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tpm20-get-pcrbanks"><a href="#tpm20-get-pcrbanks" class="headerlink" title="tpm20_get_pcrbanks"></a>tpm20_get_pcrbanks</h3><p>该函数定义了一个名为<code>buffer</code>的<code>u8</code>类型数组，长度为128，用于存储从TPM获取到的数据。其次调用tpm20_getcapability获取PCR信息，TCG官方解释如下：</p><blockquote><p><code>TPM_CAP_PCRS</code>是TPM（Trusted Platform Module，可信平台模块）的一种Capability（能力），用于返回当前分配给PCR（Platform Configuration Registers）的信息。该命令的参数<code>property</code>应为零。当TPM收到此命令时，它将始终返回完整的PCR分配，并将<code>moreData</code>设置为<code>NO</code>。</p><p>返回的信息是一个<code>TPML_PCR_SELECTION</code>结构体，其中包含了每个PCR bank中已分配的PCR的信息。对于每个已实现的PCR bank，该结果中必须包含一个<code>TPMS_PCR_SELECTION</code>结构体。对于每个已实现的哈希算法，该结果中也可以包含一个<code>TPMS_PCR_SELECTION</code>结构体。</p><p>通过使用<code>TPM_CAP_PCRS</code>命令，可以查询当前的PCR分配情况，以便在系统中进行更有效的安全策略实施。</p></blockquote><p><img src="/wp-content/uploads/2023/06/image-1686642236974.png" alt="file"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpm2_res_getcapability</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpm_rsp_header</span> <span class="hljs-title">hdr</span>;</span><br>    u8 moreData;<br>    u32 capability;<br>    u8 data[<span class="hljs-number">0</span>]; <span class="hljs-comment">/* capability dependent data */</span><br>&#125; PACKED;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpms_pcr_selection</span> &#123;</span><br>    u16 hashAlg;<br>    u8 sizeOfSelect;<br>    u8 pcrSelect[<span class="hljs-number">0</span>];<br>&#125; PACKED;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpml_pcr_selection</span> &#123;</span><br>    u32 count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpms_pcr_selection</span> <span class="hljs-title">selections</span>[0];</span><br>&#125; PACKED;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">tpm20_get_pcrbanks</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//用于存储从TPM获取到的数据</span><br>    u8 buffer[<span class="hljs-number">128</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpm2_res_getcapability</span> *<span class="hljs-title">trg</span> =</span><br>      (<span class="hljs-keyword">struct</span> tpm2_res_getcapability *)&amp;buffer;<br><br>    <span class="hljs-comment">//获取PCR，参数property应为零，TPM收到此命令时，它将始终返回完整的PCR分配，并将moreData设置为NO</span><br>    <span class="hljs-type">int</span> ret = tpm20_getcapability(TPM2_CAP_PCRS, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, &amp;trg-&gt;hdr,<br>                                  <span class="hljs-keyword">sizeof</span>(buffer));<br>    <span class="hljs-keyword">if</span> (ret)<br>        <span class="hljs-keyword">return</span> ret;<br><br>    <span class="hljs-comment">/* defend against (broken) TPM sending packets that are too short */</span><br>    u32 resplen = be32_to_cpu(trg-&gt;hdr.totlen);<br>    <span class="hljs-keyword">if</span> (resplen &lt;= offsetof(<span class="hljs-keyword">struct</span> tpm2_res_getcapability, data))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    u32 size = resplen - offsetof(<span class="hljs-keyword">struct</span> tpm2_res_getcapability, data);<br>    <span class="hljs-comment">/* we need a valid tpml_pcr_selection up to and including sizeOfSelect */</span><br>    <span class="hljs-keyword">if</span> (size &lt; offsetof(<span class="hljs-keyword">struct</span> tpml_pcr_selection, selections) +<br>               offsetof(<span class="hljs-keyword">struct</span> tpms_pcr_selection, pcrSelect))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">//全局变量，存放PCR bank</span><br>    tpm20_pcr_selection = malloc_high(size);<br>    <span class="hljs-keyword">if</span> (tpm20_pcr_selection) &#123;<br>        <span class="hljs-comment">//返回TPML_PCR_SELECTION结构体</span><br>        <span class="hljs-built_in">memcpy</span>(tpm20_pcr_selection, &amp;trg-&gt;data, size);<br>        tpm20_pcr_selection_size = size;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        warn_noalloc();<br>        ret = <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="tpm20-getcapability"><a href="#tpm20-getcapability" class="headerlink" title="tpm20_getcapability"></a>tpm20_getcapability</h4><p>向TPM发送TPM2_CC_GetCapability请求，返回当前TPM的能力描述信息。上面调用的就是返回对应的PCR属性以及对应的数量。下图时TCG规范中的可以使用TPM2_CC_GetCapability获取信息的命令。</p><p><img src="/wp-content/uploads/2023/06/image-1686642248131.png" alt="file"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">tpm20_getcapability</span><span class="hljs-params">(u32 capability, u32 property, u32 count,</span><br><span class="hljs-params">                    <span class="hljs-keyword">struct</span> tpm_rsp_header *rsp, u32 rsize)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpm2_req_getcapability</span> <span class="hljs-title">trg</span> =</span> &#123;<br>        .hdr.tag = cpu_to_be16(TPM2_ST_NO_SESSIONS),<br>        .hdr.totlen = cpu_to_be32(<span class="hljs-keyword">sizeof</span>(trg)),<br>        .hdr.ordinal = cpu_to_be32(TPM2_CC_GetCapability),<br>        .capability = cpu_to_be32(capability),<br>        .property = cpu_to_be32(property),<br>        .propertycount = cpu_to_be32(count),<br>    &#125;;<br><br>    u32 resp_size = rsize;<br>    <span class="hljs-type">int</span> ret = tpmhw_transmit(<span class="hljs-number">0</span>, &amp;trg.hdr, rsp, &amp;resp_size,<br>                             TPM_DURATION_TYPE_SHORT);<br>    ret = (ret <br>           rsize &lt; be32_to_cpu(rsp-&gt;totlen)) ? <span class="hljs-number">-1</span> : be32_to_cpu(rsp-&gt;errcode);<br><br>    dprintf(DEBUG_tcg, <span class="hljs-string">&quot;TCGBIOS: Return value from sending TPM2_CC_GetCapability = 0x%08x\n&quot;</span>,<br>            ret);<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tpm20-write-EfiSpecIdEventStruct"><a href="#tpm20-write-EfiSpecIdEventStruct" class="headerlink" title="tpm20_write_EfiSpecIdEventStruct"></a>tpm20_write_EfiSpecIdEventStruct</h3><p>该函数用于添加在描述摘要格式的日志开头添加一条，该日志添加到了ACPI日志中，这个事件包含了TPM所支持的所有hash算法的列表,以及每个hash算法对应的hash大小。</p><ol><li>检查tpm20_pcr_selection,这是TPM返回的PCR选择结构,包含了所选PCR及对应的hash算法信息。如果这个结构不存在或格式错误,函数返回失败。</li><li>填充EfiSpecIdEventStruct事件结构。这个结构包含hash算法列表和大小信息。</li><li>计算EfiSpecIdEventStruct事件结构的总大小,包括大小字段本身和 DigestSizes数组。</li><li>创建一个tpm_log_event结构,设置事件类型为EV_NO_ACTION。</li><li>调用tpm_log_event函数,将EfiSpecIdEventStruct事件记录到ACPI日志中。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">tpm20_write_EfiSpecIdEventStruct</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!tpm20_pcr_selection)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpms_pcr_selection</span> *<span class="hljs-title">sel</span> =</span> tpm20_pcr_selection-&gt;selections;<br>    <span class="hljs-type">void</span> *nsel, *end = (<span class="hljs-type">void</span>*)tpm20_pcr_selection + tpm20_pcr_selection_size;<br><br>    u32 count;<br>    <span class="hljs-keyword">for</span> (count = <span class="hljs-number">0</span>; count &lt; be32_to_cpu(tpm20_pcr_selection-&gt;count); count++) &#123;<br>        u8 sizeOfSelect = sel-&gt;sizeOfSelect;<br><br>        nsel = (<span class="hljs-type">void</span>*)sel + <span class="hljs-keyword">sizeof</span>(*sel) + sizeOfSelect;<br>        <span class="hljs-keyword">if</span> (nsel &gt; end)<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-type">int</span> hsize = tpm20_get_hash_buffersize(be16_to_cpu(sel-&gt;hashAlg));<br>        <span class="hljs-keyword">if</span> (hsize &lt; <span class="hljs-number">0</span>) &#123;<br>            dprintf(DEBUG_tcg, <span class="hljs-string">&quot;TPM is using an unsupported hash: %d\n&quot;</span>,<br>                    be16_to_cpu(sel-&gt;hashAlg));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        event.hdr.digestSizes[count].algorithmId = be16_to_cpu(sel-&gt;hashAlg);<br>        event.hdr.digestSizes[count].digestSize = hsize;<br><br>        sel = nsel;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sel != end) &#123;<br>        dprintf(DEBUG_tcg, <span class="hljs-string">&quot;Malformed pcr selection structure fron TPM\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    event.hdr.numberOfAlgorithms = count;<br>    <span class="hljs-type">int</span> event_size = offsetof(<span class="hljs-keyword">struct</span> TCG_EfiSpecIdEventStruct<br>                              , digestSizes[count]);<br>    u32 *vendorInfoSize = (<span class="hljs-type">void</span>*)&amp;event + event_size;<br>    *vendorInfoSize = <span class="hljs-number">0</span>;<br>    event_size += <span class="hljs-keyword">sizeof</span>(*vendorInfoSize);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpm_log_entry</span> <span class="hljs-title">le</span> =</span> &#123;<br>        .hdr.eventtype = EV_NO_ACTION,<br>    &#125;;<br>    <span class="hljs-keyword">return</span> tpm_log_event(&amp;le.hdr, SHA1_BUFSIZE, &amp;event, event_size);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tpm-smbios-measure"><a href="#tpm-smbios-measure" class="headerlink" title="tpm_smbios_measure"></a>tpm_smbios_measure</h2><p>这个函数的目的是度量SMBIOS表，并记录相应的日志信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">tpm_smbios_measure</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//使用SHA1作为默认Hash算法</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcctes</span> <span class="hljs-title">pcctes</span> =</span> &#123;<br>        .eventid = <span class="hljs-number">1</span>,<br>        .eventdatasize = SHA1_BUFSIZE,<br>    &#125;;<br>    <span class="hljs-comment">//SMBiosAddr地址在maininit过程中platform_hardware_setup中qemu_platform_setup已经被赋值了</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">smbios_entry_point</span> *<span class="hljs-title">sep</span> =</span> SMBiosAddr;<br><br>    dprintf(DEBUG_tcg, <span class="hljs-string">&quot;TCGBIOS: SMBIOS at %p\n&quot;</span>, sep);<br><br>    <span class="hljs-keyword">if</span> (!sep)<br>        <span class="hljs-keyword">return</span>;<br><br>    sha1((<span class="hljs-type">const</span> u8 *)sep-&gt;structure_table_address,<br>         sep-&gt;structure_table_length, pcctes.digest);<br>    <span class="hljs-comment">//将SMBIOS表的度量值扩展进入对应PCR 1寄存器中，并记录日志。</span><br>    tpm_add_measurement_to_log(<span class="hljs-number">1</span>,<br>                               EV_EVENT_TAG,<br>                               (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)&amp;pcctes, <span class="hljs-keyword">sizeof</span>(pcctes),<br>                               (u8 *)&amp;pcctes, <span class="hljs-keyword">sizeof</span>(pcctes));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tpm-add-measurement-to-log"><a href="#tpm-add-measurement-to-log" class="headerlink" title="tpm_add_measurement_to_log"></a>tpm_add_measurement_to_log</h3><p>在函数中，完成对相应PCR的扩展，并记录日志到ACPI日志中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Add a measurement to the log; the data at data_seg:data/length are</span><br><span class="hljs-comment"> * appended to the TCG_PCClientPCREventStruct</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Input parameters:</span><br><span class="hljs-comment"> *  pcrindex   : which PCR to extend</span><br><span class="hljs-comment"> *  event_type : type of event; specs section on &#x27;Event Types&#x27;</span><br><span class="hljs-comment"> *  event       : pointer to info (e.g., string) to be added to log as-is</span><br><span class="hljs-comment"> *  event_length: length of the event</span><br><span class="hljs-comment"> *  hashdata    : pointer to the data to be hashed</span><br><span class="hljs-comment"> *  hashdata_length: length of the data to be hashed</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">tpm_add_measurement_to_log</span><span class="hljs-params">(u32 pcrindex, u32 event_type,</span><br><span class="hljs-params">                           <span class="hljs-type">const</span> <span class="hljs-type">char</span> *event, u32 event_length,</span><br><span class="hljs-params">                           <span class="hljs-type">const</span> u8 *hashdata, u32 hashdata_length)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!tpm_is_working())<br>        <span class="hljs-keyword">return</span>;<br><br>    u8 hash[SHA1_BUFSIZE];<br>    sha1(hashdata, hashdata_length, hash);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpm_log_entry</span> <span class="hljs-title">le</span> =</span> &#123;<br>        .hdr.pcrindex = pcrindex,<br>        .hdr.eventtype = event_type,<br>    &#125;;<br>    <span class="hljs-type">int</span> digest_len = tpm_build_digest(&amp;le, hash, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (digest_len &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//进行TPM扩展</span><br>    <span class="hljs-type">int</span> ret = tpm_extend(&amp;le, digest_len);<br>    <span class="hljs-keyword">if</span> (ret) &#123;<br>        tpm_set_failure();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    tpm_build_digest(&amp;le, hash, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//记录日志</span><br>    tpm_log_event(&amp;le.hdr, digest_len, event, event_length);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tpm-extend"><a href="#tpm-extend" class="headerlink" title="tpm_extend"></a>tpm_extend</h3><p>就是调用tpmhw_transmit进行TPM扩展命令的发送，进行TPM扩展。</p><h2 id="tpm-add-action"><a href="#tpm-add-action" class="headerlink" title="tpm_add_action"></a>tpm_add_action</h2><p>调用放：<code>tpm_add_action(2, &quot;Start Option ROM Scan&quot;);</code></p><p>我们看一下该函数：添加了对EV_ACTION事件的度量。并将它扩展到PCR 2寄存器。其实底层也是调用tpm_add_measurement_to_log方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Add an EV_ACTION measurement to the list of measurements</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">tpm_add_action</span><span class="hljs-params">(u32 pcrIndex, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>)</span><br>&#123;<br>    u32 len = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>);<br>    tpm_add_measurement_to_log(pcrIndex, EV_ACTION,<br>                               <span class="hljs-built_in">string</span>, len, (u8 *)<span class="hljs-built_in">string</span>, len);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tpm-menu"><a href="#tpm-menu" class="headerlink" title="tpm_menu"></a>tpm_menu</h2><p>接着TPM相关的操作是，在post阶段-&gt;maininit-&gt;interactiva_bootmenu，显示TPM配置菜单，包括两个操作，clear TPM和改变PCR banks。</p><h2 id="tpm-prepboot"><a href="#tpm-prepboot" class="headerlink" title="tpm_prepboot"></a>tpm_prepboot</h2><p>这个函数是接着要执行的，post阶段-&gt;prepareboot()-&gt;tpm_prepboot()，准备要进入boot阶段了执行的，获取授权认证密钥。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span><br><span class="hljs-title function_">tpm_prepboot</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!CONFIG_TCGBIOS)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">switch</span> (TPM_version) &#123;<br>    <span class="hljs-keyword">case</span> TPM_VERSION_1_2:<br>        <span class="hljs-keyword">if</span> (TPM_has_physical_presence)<br>            tpm_simple_cmd(<span class="hljs-number">0</span>, TPM_ORD_PhysicalPresence,<br>                           <span class="hljs-number">2</span>, TPM_PP_NOT_PRESENT_LOCK, TPM_DURATION_TYPE_SHORT);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TPM_VERSION_2:<br>        tpm20_prepboot();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    tpm_add_action(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Calling INT 19h&quot;</span>);<br>    tpm_add_event_separators();<br>&#125;<br></code></pre></td></tr></table></figure><p>tpm20_prepboot如下：先获取随机数，然后获取授权密钥。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">tpm20_prepboot</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> ret = tpm20_stirrandom();<br>    <span class="hljs-keyword">if</span> (ret)<br>         <span class="hljs-keyword">goto</span> err_exit;<br><br>    u8 auth[<span class="hljs-number">20</span>];<br>    <span class="hljs-comment">//获取随机数</span><br>    ret = tpm20_getrandom(&amp;auth[<span class="hljs-number">0</span>], <span class="hljs-keyword">sizeof</span>(auth));<br>    <span class="hljs-keyword">if</span> (ret)<br>        <span class="hljs-keyword">goto</span> err_exit;<br><br>    <span class="hljs-comment">//获取授权密钥</span><br>    ret = tpm20_hierarchychangeauth(auth);<br>    <span class="hljs-keyword">if</span> (ret)<br>        <span class="hljs-keyword">goto</span> err_exit;<br><br>    <span class="hljs-keyword">return</span>;<br><br>err_exit:<br>    dprintf(DEBUG_tcg, <span class="hljs-string">&quot;TCGBIOS: TPM malfunctioning (line %d).\n&quot;</span>, __LINE__);<br><br>    tpm_set_failure();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tpm-add-event-separators"><a href="#tpm-add-event-separators" class="headerlink" title="tpm_add_event_separators"></a>tpm_add_event_separators</h3><p>向PCRS0-7中添加事件分隔符，以便记录系统启动过程中的事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Add event separators for PCRs 0 to 7; specs on &#x27;Measuring Boot Events&#x27;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">tpm_add_event_separators</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> u8 evt_separator[] = &#123;<span class="hljs-number">0xff</span>,<span class="hljs-number">0xff</span>,<span class="hljs-number">0xff</span>,<span class="hljs-number">0xff</span>&#125;;<br>    u32 pcrIndex;<br>    <span class="hljs-keyword">for</span> (pcrIndex = <span class="hljs-number">0</span>; pcrIndex &lt;= <span class="hljs-number">7</span>; pcrIndex++)<br>        <span class="hljs-comment">//tpm_add_measurement_to_log函数会计算事件的哈希值，并将其添加到PCR寄存器中。</span><br>        tpm_add_measurement_to_log(pcrIndex, EV_SEPARATOR,<br>                                   <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>,<br>                                   evt_separator,<br>                                   <span class="hljs-keyword">sizeof</span>(evt_separator));<br></code></pre></td></tr></table></figure><h2 id="tpm-add-bcv"><a href="#tpm-add-bcv" class="headerlink" title="tpm_add_bcv"></a>tpm_add_bcv</h2><p>在boot阶段，调用13号中断将磁盘数据读入内存后，调用TPM设备对MBR进行度量。调用流程：boot阶段，do_boot-&gt;boot_disk-&gt;tpm_add_bcv；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//MBR结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mbr_s</span> &#123;</span><br>    u8 code[<span class="hljs-number">440</span>];<br>    <span class="hljs-comment">// 0x01b8</span><br>    u32 diskseg;<br>    <span class="hljs-comment">// 0x01bc</span><br>    u16 null;<br>    <span class="hljs-comment">// 0x01be</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition_s</span> <span class="hljs-title">partitions</span>[4];</span><br>    <span class="hljs-comment">// 0x01fe</span><br>    u16 signature;<br>&#125; PACKED; <br><br>tpm_add_bcv(bootdrv, MAKE_FLATPTR(bootseg, <span class="hljs-number">0</span>), <span class="hljs-number">512</span>);<br></code></pre></td></tr></table></figure><p>看看度量代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span><br><span class="hljs-title function_">tpm_add_bcv</span><span class="hljs-params">(u32 bootdrv, <span class="hljs-type">const</span> u8 *addr, u32 length)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!tpm_is_working())<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">//如果小于512字节，直接返回MBR一般都是第一个扇区512字节，前440字节一般是代码</span><br>    <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">0x200</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Booting BCV device 00h (Floppy)&quot;</span>;<br>    <span class="hljs-keyword">if</span> (bootdrv == <span class="hljs-number">0x80</span>)<br>        <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Booting BCV device 80h (HDD)&quot;</span>;<br>    <span class="hljs-comment">//添加事件度量，往PCR 4中扩展</span><br>    tpm_add_action(<span class="hljs-number">4</span>, <span class="hljs-built_in">string</span>);<br><br>    <span class="hljs-comment">/* specs: see section &#x27;Hard Disk Device or Hard Disk-Like Devices&#x27; */</span><br>    <span class="hljs-comment">/* equivalent to: dd if=/dev/hda ibs=1 count=440  sha1sum */</span><br>    <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;MBR&quot;</span>;<br>    <span class="hljs-comment">// MBR放在了PCR 寄存器4中</span><br>    tpm_add_measurement_to_log(<span class="hljs-number">4</span>, EV_IPL,<br>                               <span class="hljs-built_in">string</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>),<br>                               addr, <span class="hljs-number">0x1b8</span>);<br><br>    <span class="hljs-comment">/* equivalent to: dd if=/dev/hda ibs=1 count=72 skip=440  sha1sum */</span><br>    <span class="hljs-comment">//512字节的后面72字节分区表，放在了PCR 5寄存器中</span><br>    <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;MBR PARTITION_TABLE&quot;</span>;<br>    tpm_add_measurement_to_log(<span class="hljs-number">5</span>, EV_IPL_PARTITION_DATA,<br>                               <span class="hljs-built_in">string</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>),<br>                               addr + <span class="hljs-number">0x1b8</span>, <span class="hljs-number">0x48</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BIOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>home目录过大，根目录空间却很小，根目录扩容</title>
    <link href="/0031.html"/>
    <url>/0031.html</url>
    
    <content type="html"><![CDATA[<h2 id="home目录过大，根目录-空间却很小，根目录扩容"><a href="#home目录过大，根目录-空间却很小，根目录扩容" class="headerlink" title="&#x2F;home目录过大，根目录&#x2F;空间却很小，根目录扩容"></a>&#x2F;home目录过大，根目录&#x2F;空间却很小，根目录扩容</h2><p>由于当时分配时，没有选好，导致&#x2F;home目录过大，根目录&#x2F;空间却很小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# df -h<br>df: /run/user/0/gvfs: Transport endpoint is not connected<br>df: /run/user/0/gvfs: Transport endpoint is not connected<br>Filesystem           Size  Used Avail Use% Mounted on<br>devtmpfs             126G     0  126G   0% /dev<br>tmpfs                126G  144K  126G   1% /dev/shm<br>tmpfs                126G  692M  126G   1% /run<br>tmpfs                126G     0  126G   0% /sys/fs/cgroup<br>/dev/mapper/cl-root   50G   50G  419M 100% /<br>/dev/mapper/cl-home   14T  134G   14T   1% /home<br>/dev/sda2            976M  268M  641M  30% /boot<br>/dev/sda1            599M  7.3M  592M   2% /boot/efi<br>tmpfs                 26G   16K   26G   1% /run/user/42<br>tmpfs                 26G   36K   26G   1% /run/user/0<br></code></pre></td></tr></table></figure><p>可以看到我们只给根目录目录下面挂载了，50G的空间，显然不够使用。</p><p>接下来我们查看一下逻辑卷组的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vgdisplay #查看逻辑卷组<br>  --- Volume group ---<br>  VG Name               cl<br>  System ID<br>  Format                lvm2<br>  Metadata Areas        1<br>  Metadata Sequence No  4<br>  VG Access             read/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                3<br>  Open LV               3<br>  Max PV                0<br>  Cur PV                1<br>  Act PV                1<br>  VG Size               13.97 TiB<br>  PE Size               4.00 MiB<br>  Total PE              3662153<br>  Alloc PE / Size       3662153 / 13.97 TiB<br>  Free  PE / Size       0 / 0<br><br>[root@localhost ~]# lvdisplay ##查看逻辑卷情况，默认三个，root、home和交换空间swap<br>  --- Logical volume ---<br>  LV Path                /dev/cl/swap<br>  LV Name                swap<br>  VG Name                cl<br>  LV Write Access        read/write<br>  LV Creation host, time localhost, 2023-04-05 22:52:59 +0800<br>  LV Status              available<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">open                 2</span><br>  LV Size                4.00 GiB<br>  Current LE             1024<br>  Segments               1<br>  Allocation             inherit<br>  Read ahead sectors     auto<br>  - currently set to     8192<br>  Block device           253:1<br><br>  --- Logical volume ---<br>  LV Path                /dev/cl/home<br>  LV Name                home<br>  VG Name                cl<br>  LV Write Access        read/write<br>  LV Creation host, time localhost, 2023-04-05 22:53:00 +0800<br>  LV Status              available<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">open                 1</span><br>  LV Size                &lt;13.92 TiB<br>  Current LE             3648329<br>  Segments               1<br>  Allocation             inherit<br>  Read ahead sectors     auto<br>  - currently set to     8192<br>  Block device           253:2<br><br>  --- Logical volume ---<br>  LV Path                /dev/cl/root<br>  LV Name                root<br>  VG Name                cl<br>  LV Write Access        read/write<br>  LV Creation host, time localhost, 2023-04-05 22:53:21 +0800<br>  LV Status              available<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">open                 1</span><br>  LV Size                50.00 GiB<br>  Current LE             12800<br>  Segments               1<br>  Allocation             inherit<br>  Read ahead sectors     auto<br>  - currently set to     8192<br>  Block device           253:0<br></code></pre></td></tr></table></figure><h2 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h2><p>1、备份&#x2F;home (不要在&#x2F;home目录执行该命令)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /mnt<br>sudo tar -cvf /mnt/home.tar /home<br></code></pre></td></tr></table></figure><p>2、终止&#x2F;home目录所有进程 (不要在&#x2F;home目录执行该命令)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo fuser -km /home<br></code></pre></td></tr></table></figure><p>3、卸载&#x2F;home目录 (不要在&#x2F;home目录执行该命令)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo umount /home<br></code></pre></td></tr></table></figure><p>4、删除逻辑卷&#x2F;home (不要在&#x2F;home目录执行该命令)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo lvremove /dev/cl/home<br></code></pre></td></tr></table></figure><p>5、查看逻辑卷组可用空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vgdisplay #可以看到现在又13.92TB的空余空间未分配<br>  --- Volume group ---<br>  VG Name               cl<br>  System ID<br>  Format                lvm2<br>  Metadata Areas        1<br>  Metadata Sequence No  5<br>  VG Access             read/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                2<br>  Open LV               2<br>  Max PV                0<br>  Cur PV                1<br>  Act PV                1<br>  VG Size               13.97 TiB<br>  PE Size               4.00 MiB<br>  Total PE              3662153<br>  Alloc PE / Size       13824 / 54.00 GiB<br>  Free  PE / Size       3648329 / &lt;13.92 TiB<br></code></pre></td></tr></table></figure><p>6、新建一个卷home，fdisk格式化，文件系统还是搞为xfs（同样挂载到&#x2F;home）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">lvcreate -L 5120G -n home cl #大小5T<br>mkfs -t xfs /dev/cl/home<br></code></pre></td></tr></table></figure><p>7、激活卷组(cl是卷组名)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vgchange -ay cl  <br>3 logical volume(s) in volume group &quot;cl&quot; now activevgchange -ay cl<br></code></pre></td></tr></table></figure><p>8、把这个新逻辑卷home挂载到之前的文件夹&#x2F;home中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount /dev/cl/home /home/<br></code></pre></td></tr></table></figure><p>9、查看是否挂载成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# df -h #可以看到/home已经变大了<br>Filesystem           Size  Used Avail Use% Mounted on<br>devtmpfs             126G     0  126G   0% /dev<br>tmpfs                126G  144K  126G   1% /dev/shm<br>tmpfs                126G  692M  126G   1% /run<br>tmpfs                126G     0  126G   0% /sys/fs/cgroup<br>/dev/mapper/cl-root   50G   48G  2.5G  96% /<br>/dev/sda2            976M  268M  641M  30% /boot<br>/dev/sda1            599M  7.3M  592M   2% /boot/efi<br>tmpfs                 26G   16K   26G   1% /run/user/42<br>tmpfs                 26G   32K   26G   1% /run/user/0<br>/dev/mapper/cl-home  5.0T   36G  5.0T   1% /home<br></code></pre></td></tr></table></figure><p>10、恢复&#x2F;home数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xvf /mnt/home.tar -C /<br>rm -rf /mnt/<br></code></pre></td></tr></table></figure><p>11、将剩余的空间分配给根目录&#x2F;即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost /]# vgdisplay #可以看到还有8.92 TiB的空间<br>  --- Volume group ---<br>  VG Name               cl<br>  System ID<br>  Format                lvm2<br>  Metadata Areas        1<br>  Metadata Sequence No  8<br>  VG Access             read/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                3<br>  Open LV               3<br>  Max PV                0<br>  Cur PV                1<br>  Act PV                1<br>  VG Size               13.97 TiB<br>  PE Size               4.00 MiB<br>  Total PE              3662153<br>  Alloc PE / Size       1324544 / 5.05 TiB<br>  Free  PE / Size       2337609 / &lt;8.92 TiB<br><br>[root@localhost ~]# lvextend -L +8.9TiB /dev/cl/root #注意这里添加的空间不要写8.92，因为不可能全部的空间都可用，还有一些索引的信息，所以要小一点<br>  Rounding size to boundary between physical extents: 8.90 TiB.<br>  Size of logical volume cl/root changed from 50.00 GiB (12800 extents) to &lt;8.95 TiB (2345882 extents).<br>  Logical volume cl/root successfully resized.<br>[root@localhost ~]# xfs_growfs /dev/cl/root #使用xfs_growfs扩展文件系统，以确保磁盘认识新扩展的空间<br></code></pre></td></tr></table></figure><p>12、使用df -h查看磁盘情况，已经扩展了&#x2F;目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# df -h<br>Filesystem           Size  Used Avail Use% Mounted on<br>devtmpfs             126G     0  126G   0% /dev<br>tmpfs                126G  144K  126G   1% /dev/shm<br>tmpfs                126G  692M  126G   1% /run<br>tmpfs                126G     0  126G   0% /sys/fs/cgroup<br>/dev/mapper/cl-root  9.0T   82G  8.9T   1% /<br>/dev/sda2            976M  268M  641M  30% /boot<br>/dev/sda1            599M  7.3M  592M   2% /boot/efi<br>tmpfs                 26G   16K   26G   1% /run/user/42<br>tmpfs                 26G   32K   26G   1% /run/user/0<br>/dev/mapper/cl-home  5.0T   66G  5.0T   2% /home<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>操作系统</tag>
      
      <tag>文件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SeaBIOS源码分析-虚拟机启动过程分析</title>
    <link href="/050.html"/>
    <url>/050.html</url>
    
    <content type="html"><![CDATA[<h2 id="0-SeaBIOS四个阶段"><a href="#0-SeaBIOS四个阶段" class="headerlink" title="0 SeaBIOS四个阶段"></a>0 SeaBIOS四个阶段</h2><p>从整体角度出发，SeaBIOS包含四个阶段。</p><ul><li>加电自检（Power On Self Test, POST)</li><li>引导（Boot）</li><li>运行时（Main runtime phase）</li><li>继续运行和重启（Resume and reboot）</li></ul><h2 id="1-POST阶段"><a href="#1-POST阶段" class="headerlink" title="1 POST阶段"></a>1 POST阶段</h2><p>post阶段调用的相关函数如下图所示：</p><p><img src="/wp-content/uploads/2023/06/image-1686304817894.png" alt="file"></p><h3 id="reset-vector"><a href="#reset-vector" class="headerlink" title="reset_vector"></a>reset_vector</h3><p>当VCPU开始运行的时候，会从重置向量处开始执行，这“第一条指令”就在<code>romlayout.S</code>的reset_vector中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">reset_vector:<br>        ljmpw $SEG_BIOS, $entry_post<br>        // 0xfff5 - BiosDate in misc.c<br>        // 0xfffe - BiosModelId in misc.c<br>        // 0xffff - BiosChecksum in misc.c<br>        .end<br></code></pre></td></tr></table></figure><p>前面也分析过了，这是一条长跳转指令，会跳转到CS:IP为<code>$SEG_BIOS:$entry_post</code>的位置，也就是0xF000:0xE05B，</p><p>看看0xE05B的位置代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">        ORG 0xe05b<br>entry_post:<br>        cmpl $0, %cs:HaveRunPost                // Check for resume/reboot<br>        jnz entry_resume<br>        ENTRY_INTO32 _cfunc32flat_handle_post   // Normal entry point<br></code></pre></td></tr></table></figure><p>在romlayout中可以看到他会判断是否经历过POST阶段，如果经历过，意味着当前不应该重新进行，而应该进入继续运行（Resume）。否则就会进入真正的post处理方法：handle_post()。</p><h3 id="handle-post"><a href="#handle-post" class="headerlink" title="handle_post"></a>handle_post</h3><p>通过ENTRY_INTO32 _cfunc32flat_handle_post语句，即先进入保护模式，然后完成对C函数handle_post的调用。</p><p>handle_post函数的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> VISIBLE32FLAT<br><span class="hljs-title function_">handle_post</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!CONFIG_QEMU &amp;&amp; !CONFIG_COREBOOT)<br>        <span class="hljs-keyword">return</span>;<br><br>    serial_debug_preinit();<br>    debug_banner();<br><br>    <span class="hljs-comment">// Check if we are running under Xen.</span><br>    xen_preinit();<br><br>    <span class="hljs-comment">// Allow writes to modify bios area (0xf0000)</span><br>    make_bios_writable();<br><br>    <span class="hljs-comment">// Now that memory is read/writable - start post process.</span><br>    <span class="hljs-comment">//内存可读可写，开始post过程</span><br>    dopost();<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数一开始就对串口进行初始化，准备串口输出调试信息，然后检查是否运行在xen平台上，make_bios_writable方法检测运行的平台，最后将ROM BIOS中的bios复制到1M以内的空间，确保0xC0000-0x100000的这段地址空间是可写的，这个复制高地址处的ROM到低地址处的过程被称为Shadow RAM技术。然而，在这个过程后，这段内存会被保护起来，无法进行写入。make_bios_writable函数就用于让这段内存可写，从而便于更改一些静态分配的全局变量值。</p><h3 id="dopost"><a href="#dopost" class="headerlink" title="dopost"></a>dopost</h3><p>dopost是进一步的初始化。这个函数是POST过程的主体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Setup for code relocation and then relocate.</span><br><span class="hljs-type">void</span> VISIBLE32INIT<br><span class="hljs-title function_">dopost</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    code_mutable_preinit();<br><br>    <span class="hljs-comment">// Detect ram and setup internal malloc.</span><br>    qemu_preinit();<br>    coreboot_preinit();<br>    malloc_preinit();<br><br>    <span class="hljs-comment">// Relocate initialization code and call maininit().</span><br>    reloc_preinit(maininit, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先看一下code_mutable_preinit方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Runs after all code is present and prior to any modifications</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">code_mutable_preinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//全部变量，因为之前经过make_bios_writable方法，可以修改这个变量。</span><br>    <span class="hljs-keyword">if</span> (HaveRunPost)<br>        <span class="hljs-comment">// Already run</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// Setup reset-vector entry point (controls legacy reboots).</span><br>    <span class="hljs-comment">//将复位代码（CMOS_RESET_CODE）写入CMOS芯片中的Reset Status寄存器（0xCF）</span><br>    rtc_write(CMOS_RESET_CODE, <span class="hljs-number">0</span>);<br>    barrier();<br>    HaveRunPost = <span class="hljs-number">1</span>;<br>    barrier();<br>&#125;<br></code></pre></td></tr></table></figure><p>这一段的核心是将HaveRunPost设置为1。可以看出，HaveRunPost实际上相当于一个全局变量，在BIOS ROM中实际上是被初始化为0的。然后将ROM映射到RAM中的BIOS ROM区域之后，通过make_bios_writable，使得这一段RAM区域可写，然后才能更改HaveRunPost的值。</p><p>接着是qemu_preinit();函数，我们尽量不继续深入，探讨具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">qemu_preinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 读取北桥PCI设备的一些配置信息，开启qemu调试的输出端口，检测并判断当前虚拟机运行的平台PlatformRunningOn，QEMU为1、Xen为2、KVM为4.</span><br>    qemu_detect();<br><br>    <span class="hljs-keyword">if</span> (!CONFIG_QEMU)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (runningOnXen()) &#123;<br>        xen_ramsize_preinit();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!runningOnQEMU()) &#123;<br>        dprintf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Warning: No QEMU Northbridge found (isapc?)\n&quot;</span>);<br>        PlatformRunningOn = PF_QEMU;<br>        kvm_detect();<br>    &#125;<br><br>    <span class="hljs-comment">// On emulators, get memory size from nvram.</span><br>    <span class="hljs-comment">//读取coms的虚拟机内存大小信息，并加入到e820表</span><br>    <span class="hljs-comment">//e820表通过BIOS向操作系统提供内存布局，通过BIOS的0x15中断进行访问，并将ax设置为0xe820，这也是e820表的由来。</span><br>    u32 rs = ((rtc_read(CMOS_MEM_EXTMEM2_LOW) &lt;&lt; <span class="hljs-number">16</span>)<br>               (rtc_read(CMOS_MEM_EXTMEM2_HIGH) &lt;&lt; <span class="hljs-number">24</span>));<br>    <span class="hljs-keyword">if</span> (rs)<br>        rs += <span class="hljs-number">16</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">else</span><br>        rs = (((rtc_read(CMOS_MEM_EXTMEM_LOW) &lt;&lt; <span class="hljs-number">10</span>)<br>                (rtc_read(CMOS_MEM_EXTMEM_HIGH) &lt;&lt; <span class="hljs-number">18</span>))<br>              + <span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br>    RamSize = rs;<br>    e820_add(<span class="hljs-number">0</span>, rs, E820_RAM);<br><br>    <span class="hljs-comment">/* reserve 256KB BIOS area at the end of 4 GB */</span><br>    e820_add(<span class="hljs-number">0xfffc0000</span>, <span class="hljs-number">256</span>*<span class="hljs-number">1024</span>, E820_RESERVED);<br><br>    dprintf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;RamSize: 0x%08x [cmos]\n&quot;</span>, RamSize);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着coreboot_preinit代表是从coreboot启动，这里不再探究。</p><p>接着是malloc_preinit();方法，该方法用于SeaBIOS初始化前对系统内存的一些预处理，以便malloc和free操作能够正确地使用系统内存，例如将BIOS区域从映射表删除，以防止被malloc分配使用等，还有就是处理一些高端内存等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">malloc_preinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ASSERT32FLAT();<br>    dprintf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;malloc preinit\n&quot;</span>);<br><br>    <span class="hljs-comment">// Don&#x27;t declare any memory between 0xa0000 and 0x100000</span><br>    <span class="hljs-comment">//将0xa0000到0x100000之间的内存区域从e820内存映射表中删除，以防止这些区域被分配给malloc库使用。</span><br>    e820_remove(BUILD_LOWRAM_END, BUILD_BIOS_ADDR-BUILD_LOWRAM_END);<br><br>    <span class="hljs-comment">// Mark known areas as reserved.</span><br>    <span class="hljs-comment">// 不能再分配给malloc库使用。</span><br>    e820_add(BUILD_BIOS_ADDR, BUILD_BIOS_SIZE, E820_RESERVED);<br><br>    <span class="hljs-comment">// Populate temp high ram</span><br>    u32 highram = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i=e820_count<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">e820entry</span> *<span class="hljs-title">en</span> =</span> &amp;e820_list[i];<br>        u64 end = en-&gt;start + en-&gt;size;<br>        <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (en-&gt;type != E820_RAM  end &gt; <span class="hljs-number">0xffffffff</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        u32 s = en-&gt;start, e = end;<br>        <span class="hljs-keyword">if</span> (!highram) &#123;<br>            u32 newe = ALIGN_DOWN(e - BUILD_MAX_HIGHTABLE, MALLOC_MIN_ALIGN);<br>            <span class="hljs-keyword">if</span> (newe &lt;= e &amp;&amp; newe &gt;= s) &#123;<br>                highram = newe;<br>                e = newe;<br>            &#125;<br>        &#125;<br>        alloc_add(&amp;ZoneTmpHigh, s, e);<br>    &#125;<br><br>    <span class="hljs-comment">// Populate regions</span><br>    alloc_add(&amp;ZoneTmpLow, BUILD_STACK_ADDR, BUILD_EBDA_MINIMUM);<br>    <span class="hljs-keyword">if</span> (highram) &#123;<br>        alloc_add(&amp;ZoneHigh, highram, highram + BUILD_MAX_HIGHTABLE);<br>        e820_add(highram, BUILD_MAX_HIGHTABLE, E820_RESERVED);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是reloc_preinit(maininit, NULL)方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __noreturn<br><span class="hljs-title function_">reloc_preinit</span><span class="hljs-params">(<span class="hljs-type">void</span> *f, <span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span> *) __noreturn = f;<br>    <span class="hljs-comment">//如果没有启用CONFIG_RELOCATE_INIT选项，则直接调用传入的函数。</span><br>    <span class="hljs-keyword">if</span> (!CONFIG_RELOCATE_INIT)<br>        func(arg);<br><br>    <span class="hljs-comment">// Allocate space for init code.</span><br>    <span class="hljs-comment">//计算位于init section的代码的大小和对齐方式，并为其分配一块临时内存，用于存储重定位后的代码。</span><br>    u32 initsize = SYMBOL(code32init_end) - SYMBOL(code32init_start);<br>    u32 codealign = SYMBOL(_reloc_min_align);<br>    <span class="hljs-type">void</span> *codedest = memalign_tmp(codealign, initsize);<br>    <span class="hljs-type">void</span> *codesrc = VSYMBOL(code32init_start);<br>    <span class="hljs-keyword">if</span> (!codedest)<br>        panic(<span class="hljs-string">&quot;No space for init relocation.\n&quot;</span>);<br><br>    <span class="hljs-comment">// Copy code and update relocs (init absolute, init relative, and runtime)</span><br>    dprintf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Relocating init from %p to %p (size %d)\n&quot;</span><br>            , codesrc, codedest, initsize);<br>    s32 delta = codedest - codesrc;<br>    <span class="hljs-comment">//将init section的代码从代码段（codesrc）复制到临时内存（codedest）中，并更新其中的重定位信息（包括绝对重定位、相对重定位和运行时重定位）。</span><br>    <span class="hljs-built_in">memcpy</span>(codedest, codesrc, initsize);<br>    updateRelocs(codedest, VSYMBOL(_reloc_abs_start), VSYMBOL(_reloc_abs_end)<br>                 , delta);<br>    updateRelocs(codedest, VSYMBOL(_reloc_rel_start), VSYMBOL(_reloc_rel_end)<br>                 , -delta);<br>    updateRelocs(VSYMBOL(code32flat_start), VSYMBOL(_reloc_init_start)<br>                 , VSYMBOL(_reloc_init_end), delta);<br>    <span class="hljs-comment">//更新函数指针</span><br>    <span class="hljs-keyword">if</span> (f &gt;= codesrc &amp;&amp; f &lt; VSYMBOL(code32init_end))<br>        func = f + delta;<br><br>    <span class="hljs-comment">// Call function in relocated code.</span><br>    barrier();<br>    <span class="hljs-comment">//调用函数</span><br>    func(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数用于在SeaBIOS初始化之前对一些特殊的代码进行重定位和处理，可以看到接下来dopost就是调用了mainint方法进行初始化。</p><h3 id="maininit"><a href="#maininit" class="headerlink" title="maininit"></a>maininit</h3><p>直接上代码，该函数完成了大量的初始化工作，做了一些注释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Main setup code.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">maininit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// Initialize internal interfaces.</span><br>    <span class="hljs-comment">//初始化内部接口，包括中断向量表、BIOS数据区等</span><br>    interface_init();<br><br>    <span class="hljs-comment">// Setup platform devices.</span><br>    <span class="hljs-comment">//包括设置SMBIOS表，初始化TPM设备，度量SMBIOS使用了1，2号寄存器</span><br>    platform_hardware_setup();<br><br>    <span class="hljs-comment">// Start hardware initialization (if threads allowed during optionroms)</span><br>    <span class="hljs-keyword">if</span> (threads_during_optionroms())<br>        device_hardware_setup();<br><br>    <span class="hljs-comment">// Run vga option rom</span><br>    <span class="hljs-comment">//初始化VGA、串口、启用VGA等，这时候会打开屏幕，输出对应的SeaBIOS版本等</span><br>    vgarom_setup();<br>    sercon_setup();<br>    enable_vga_console();<br><br>    <span class="hljs-comment">// Do hardware initialization (if running synchronously)</span><br>    <span class="hljs-keyword">if</span> (!threads_during_optionroms()) &#123;<br>        device_hardware_setup();<br>        wait_threads();<br>    &#125;<br><br>    <span class="hljs-comment">// Run option roms</span><br>    <span class="hljs-comment">//不是VGA的opention rom初始化，发现所有的PCI rom、CBFS ROM（Coreboot Filesystem（CBFS）ROM）以及构建BEV/BCV向量等。</span><br>    <span class="hljs-comment">//包含可选ROM的TPM度量值 扩展进入PCR2</span><br>    optionrom_setup();<br><br>    <span class="hljs-comment">// Allow user to modify overall boot order.</span><br>    <span class="hljs-comment">//进入BIOS菜单可以选择启动设备，通过修改DEFAULT_BOOTMENU_WAIT参数可以修改默认等待时间</span><br>    <span class="hljs-comment">//这里面还可以改变TPM的菜单，包含clear TPM和改变active PCR banks</span><br>    interactive_bootmenu();<br>    wait_threads();<br><br>    <span class="hljs-comment">// Prepare for boot.</span><br>    <span class="hljs-comment">//准备进入boot阶段</span><br>    prepareboot();<br><br>    <span class="hljs-comment">// Write protect bios memory.</span><br>    <span class="hljs-comment">//自检工作完成，设置bios只读，准备开始boot阶段</span><br>    make_bios_readonly();<br><br>    <span class="hljs-comment">// Invoke int 19 to start boot process.</span><br>    startBoot();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="interface-init"><a href="#interface-init" class="headerlink" title="interface_init"></a>interface_init</h4><p>我们关注一下interface_init();干了些什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">interface_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// Running at new code address - do code relocation fixups</span><br>    <span class="hljs-comment">//进行内存分配器的初始化工作，以便后续的接口和模块能够正确地使用系统内存。</span><br>    malloc_init();<br><br>    <span class="hljs-comment">// Setup romfile items.</span><br>    <span class="hljs-comment">//读取qemu通过fw_cfg设备传过来的配置信息</span><br>    qemu_cfg_init();<br>    <span class="hljs-comment">//初始化Coreboot文件系统（CBFS）的相关接口。</span><br>    coreboot_cbfs_init();<br>    <span class="hljs-comment">//初始化多重引导（multiboot）的相关接口。</span><br>    multiboot_init();<br><br>    <span class="hljs-comment">// Setup ivt/bda/ebda</span><br>    <span class="hljs-comment">//中断向量表相关接口初始化</span><br>    ivt_init();<br>    <span class="hljs-comment">//BIOS—数据区域相关接口初始化</span><br>    bda_init();<br><br>    <span class="hljs-comment">// Other interfaces</span><br>    <span class="hljs-comment">//初始化启动设备的相关接口。</span><br>    boot_init();<br>    <span class="hljs-comment">//初始化BIOS 32位调用的相关接口。</span><br>    bios32_init();<br>    <span class="hljs-comment">//初始化物理内存管理（PMM）的相关接口。</span><br>    pmm_init();<br>    <span class="hljs-comment">//初始化即插即用（Plug and Play）的相关接口。</span><br>    pnp_init();<br>    <span class="hljs-comment">//键盘数据区</span><br>    kbd_init();<br>    <span class="hljs-comment">//鼠标数据区</span><br>    mouse_init();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在看一下中断向量表初始化内容ivt_init：</p><blockquote><p>中断向量表（Interrupt Vector Table）是一张在实模式下使用的表，这个表将中断号映射到中断处理程序的一个列表。中断向量表必须存储在低地址区域（也就是从0x00000000）开始，大小一般是0x400字节。是一块由很多个项组成的连续的内存空间。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ivt_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    dprintf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;init ivt\n&quot;</span>);<br><br>    <span class="hljs-comment">// Initialize all vectors to the default handler.</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//首先将所有的中断向量都初始化为默认的中断处理程序（entry_iret_official）。</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)<br>        SET_IVT(i, FUNC16(entry_iret_official));<br><br>    <span class="hljs-comment">// Initialize all hw vectors to a default hw handler.</span><br>    <span class="hljs-comment">// 初始化硬件中断</span><br>    <span class="hljs-keyword">for</span> (i=BIOS_HWIRQ0_VECTOR; i&lt;BIOS_HWIRQ0_VECTOR+<span class="hljs-number">8</span>; i++)<br>        SET_IVT(i, FUNC16(entry_hwpic1));<br>    <span class="hljs-keyword">for</span> (i=BIOS_HWIRQ8_VECTOR; i&lt;BIOS_HWIRQ8_VECTOR+<span class="hljs-number">8</span>; i++)<br>        SET_IVT(i, FUNC16(entry_hwpic2));<br><br>    <span class="hljs-comment">// Initialize software handlers.</span><br>    <span class="hljs-comment">//初始化常见的软件中断，包括</span><br>    SET_IVT(<span class="hljs-number">0x02</span>, FUNC16(entry_02));<br>    SET_IVT(<span class="hljs-number">0x05</span>, FUNC16(entry_05));<br>    SET_IVT(<span class="hljs-number">0x10</span>, FUNC16(entry_10));<br>    SET_IVT(<span class="hljs-number">0x11</span>, FUNC16(entry_11));<br>    SET_IVT(<span class="hljs-number">0x12</span>, FUNC16(entry_12));<br>    SET_IVT(<span class="hljs-number">0x13</span>, FUNC16(entry_13_official));<br>    SET_IVT(<span class="hljs-number">0x14</span>, FUNC16(entry_14));<br>    SET_IVT(<span class="hljs-number">0x15</span>, FUNC16(entry_15_official));<br>    SET_IVT(<span class="hljs-number">0x16</span>, FUNC16(entry_16));<br>    SET_IVT(<span class="hljs-number">0x17</span>, FUNC16(entry_17));<br>    SET_IVT(<span class="hljs-number">0x18</span>, FUNC16(entry_18));<br>    SET_IVT(<span class="hljs-number">0x19</span>, FUNC16(entry_19_official));<br>    SET_IVT(<span class="hljs-number">0x1a</span>, FUNC16(entry_1a_official));<br>    SET_IVT(<span class="hljs-number">0x40</span>, FUNC16(entry_40));<br><br>    <span class="hljs-comment">// INT 60h-66h reserved for user interrupt</span><br>    <span class="hljs-comment">//用户保留中断</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0x60</span>; i&lt;=<span class="hljs-number">0x66</span>; i++)<br>        SET_IVT(i, SEGOFF(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// set vector 0x79 to zero</span><br>    <span class="hljs-comment">// this is used by &#x27;gardian angel&#x27; protection system</span><br>    <span class="hljs-comment">//用于保护系统</span><br>    SET_IVT(<span class="hljs-number">0x79</span>, SEGOFF(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这些定义了硬件中断、软件中断、用户保留中断以及保护中断，大多数中断处理程序有在对应的romlayout.S中的入口。</p><h4 id="platform-hardware-setup"><a href="#platform-hardware-setup" class="headerlink" title="platform_hardware_setup"></a>platform_hardware_setup</h4><p>直接看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">platform_hardware_setup</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// Make sure legacy DMA isn&#x27;t running.</span><br>    <span class="hljs-comment">//确保不会运行传统的DMA（直接内存访问），因为它可能会与其他硬件组件冲突</span><br>    dma_setup();<br><br>    <span class="hljs-comment">// Init base pc hardware.</span><br>    pic_setup();<br>    thread_setup();<br>    mathcp_setup();<br><br>    <span class="hljs-comment">// Platform specific setup</span><br>    qemu_platform_setup();<br>    coreboot_platform_setup();<br><br>    <span class="hljs-comment">// Setup timers and periodic clock interrupt</span><br>    <span class="hljs-comment">//设置定时器和周期性时钟中断，</span><br>    timer_setup();<br>    clock_setup();<br><br>    <span class="hljs-comment">// Initialize TPM</span><br>    <span class="hljs-comment">//初始化可信计算模块</span><br>    tpm_setup();<br>&#125;<br></code></pre></td></tr></table></figure><p>其中有两个函数我们关注一下，qemu_platform_setup和tpm_setup。</p><p>对于qemu_platform_setup，在这个函数中会进行PCI设备的探测，然后SeaBIOS会得到所有设备需要的MMIO和I&#x2F;O端口资源，然后统一在虚拟机的物理地址空间进行分配。接着完成smm、mtrr寄存器、smp等初始化，然后建立各种表，如PCI interrupt routing表。值得注意的是，早期QEMU ACPI表是SeaBIOS构建的，但是后来QEMU自己创建acpi表就不再依赖SeaBIOS的构建的，也就是if (CONFIG_FW_ROMFILE_LOAD)，如果为真，则直接调用find_acpi_rsdp，如果获取到了就直接返回了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">qemu_platform_setup</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!CONFIG_QEMU)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (runningOnXen()) &#123;<br>        pci_probe_devices();<br>        xen_hypercall_setup();<br>        xen_biostable_setup();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Initialize pci</span><br>    pci_setup();<br>    smm_device_setup();<br>    smm_setup();<br><br>    <span class="hljs-comment">// Initialize mtrr, msr_feature_control and smp</span><br>    mtrr_setup();<br>    msr_feature_control_setup();<br>    smp_setup();<br><br>    <span class="hljs-comment">// Create bios tables</span><br>    <span class="hljs-keyword">if</span> (MaxCountCPUs &lt;= <span class="hljs-number">255</span>) &#123;<br>        pirtable_setup();<br>        mptable_setup();<br>    &#125;<br>    smbios_setup();<br><br>    <span class="hljs-keyword">if</span> (CONFIG_FW_ROMFILE_LOAD) &#123;<br>        <span class="hljs-type">int</span> loader_err;<br><br>        dprintf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;load ACPI tables\n&quot;</span>);<br><br>        loader_err = romfile_loader_execute(<span class="hljs-string">&quot;etc/table-loader&quot;</span>);<br><br>        RsdpAddr = find_acpi_rsdp();<br><br>        <span class="hljs-keyword">if</span> (RsdpAddr)<br>            <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">/* If present, loader should have installed an RSDP.</span><br><span class="hljs-comment">         * Not installed? We might still be able to continue</span><br><span class="hljs-comment">         * using the builtin RSDP.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (!loader_err)<br>            warn_internalerror();<br>    &#125;<br><br>    acpi_setup();<br>&#125;<br></code></pre></td></tr></table></figure><p>对于tpm_setup，用于初始化可信计算模块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">tpm_setup</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!CONFIG_TCGBIOS)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">//探测tpm2设备</span><br>    <span class="hljs-type">int</span> ret = tpm_tpm2_probe();<br>    <span class="hljs-keyword">if</span> (ret) &#123;<br>        <span class="hljs-comment">//探测tpm1.2设备</span><br>        ret = tpm_tcpa_probe();<br>        <span class="hljs-keyword">if</span> (ret)<br>            <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//获取TPM版本 u8 TPM_version</span><br>    TPM_version = tpmhw_probe();<br>    <span class="hljs-keyword">if</span> (TPM_version == TPM_VERSION_NONE)<br>        <span class="hljs-keyword">return</span>;<br><br>    dprintf(DEBUG_tcg,<br>            <span class="hljs-string">&quot;TCGBIOS: Detected a TPM %s.\n&quot;</span>,<br>             (TPM_version == TPM_VERSION_1_2) ? <span class="hljs-string">&quot;1.2&quot;</span> : <span class="hljs-string">&quot;2&quot;</span>);<br><br>    TPM_working = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (runningOnXen())<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">//初始化TPM</span><br>    ret = tpm_startup();<br>    <span class="hljs-keyword">if</span> (ret)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">//度量smbios</span><br>    tpm_smbios_measure();<br>    <span class="hljs-comment">//添加度量日志</span><br>    tpm_add_action(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Start Option ROM Scan&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="optionrom-setup"><a href="#optionrom-setup" class="headerlink" title="optionrom_setup"></a>optionrom_setup</h4><p>optionrom_setup(void) -&gt; init_pcirom(pci, 0, sources); -&gt; init_optionrom-&gt;tpm_option_rom</p><p>会将所有option rom进行度量并扩展进入PCR2中。</p><h4 id="interactive-bootmenu"><a href="#interactive-bootmenu" class="headerlink" title="interactive_bootmenu"></a>interactive_bootmenu</h4><p>BIOS引导菜单，可以按ESC键进入，但是由于默认等待时间只有2.5s，可能来不及点击，可以修改默认等待时间DEFAULT_BOOTMENU_WAIT参数。</p><p>进入菜单后，会让你选择引导设备，TPM设置（如果有TPM设备的话）等。</p><h4 id="prepareboot"><a href="#prepareboot" class="headerlink" title="prepareboot();"></a>prepareboot();</h4><p>引导前准备阶段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span><br><span class="hljs-title function_">prepareboot</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// Change TPM phys. presence state befor leaving BIOS</span><br>    <span class="hljs-comment">//获取TPM授权密钥，并且接着调用了方法，</span><br>    <span class="hljs-comment">//tpm_add_action(4, &quot;Calling INT 19h&quot;);添加了Calling INT 19h度量事件并扩展到了PCR4中</span><br>    <span class="hljs-comment">//tpm_add_event_separators(); 从PCR0-7分别添加事件分隔符</span><br>    tpm_prepboot();<br><br>    <span class="hljs-comment">// Run BCVs</span><br>    bcv_prepboot();<br><br>    <span class="hljs-comment">// Finalize data structures before boot</span><br>    <span class="hljs-comment">//一系列的最终数据结构准备，为boot阶段做准备，内存收回等等</span><br>    cdrom_prepboot();<br>    pmm_prepboot();<br>    malloc_prepboot();<br>    e820_prepboot();<br><br>    HaveRunPost = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// Setup bios checksum.</span><br>    BiosChecksum -= checksum((u8*)BUILD_BIOS_ADDR, BUILD_BIOS_SIZE);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="make-bios-readonly"><a href="#make-bios-readonly" class="headerlink" title="make_bios_readonly"></a>make_bios_readonly</h4><p>自检结束，要开始启动了，设置0xF0000-0x100000内存段只读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Make the BIOS code segment area (0xf0000) read-only.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">make_bios_readonly</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!CONFIG_QEMU  runningOnXen())<br>        <span class="hljs-keyword">return</span>;<br>    dprintf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;locking shadow ram\n&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (ShadowBDF &lt; <span class="hljs-number">0</span>) &#123;<br>        dprintf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Unable to lock ram - bridge not found\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    u16 device = pci_config_readw(ShadowBDF, PCI_DEVICE_ID);<br>    <span class="hljs-keyword">if</span> (device == PCI_DEVICE_ID_INTEL_82441)<br>        make_bios_readonly_intel(ShadowBDF, I440FX_PAM0);<br>    <span class="hljs-keyword">else</span><br>        make_bios_readonly_intel(ShadowBDF, Q35_HOST_BRIDGE_PAM0);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="startBoot"><a href="#startBoot" class="headerlink" title="startBoot"></a>startBoot</h4><p>startBoot函数最终是调用INT 19H中断来，进入BOOT阶段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Begin the boot process by invoking an int0x19 in 16bit mode.</span><br><span class="hljs-type">void</span> VISIBLE32FLAT<br><span class="hljs-title function_">startBoot</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// Clear low-memory allocations (required by PMM spec).</span><br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)BUILD_STACK_ADDR, <span class="hljs-number">0</span>, BUILD_EBDA_MINIMUM - BUILD_STACK_ADDR);<br><br>    dprintf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Jump to int19\n&quot;</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bregs</span> <span class="hljs-title">br</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;br, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(br));<br>    br.flags = F_IF;<br>    call16_int(<span class="hljs-number">0x19</span>, &amp;br); <span class="hljs-comment">//回到实模式，进入Boot状态</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-boot阶段"><a href="#2-boot阶段" class="headerlink" title="2 boot阶段"></a>2 boot阶段</h2><p>0x19中断的入口，也是在layoutrom.S文件中，为entry_19，直接跳转到了handle_19，后者主要作用就是do_boot开始引导。</p><h3 id="handle-19"><a href="#handle-19" class="headerlink" title="handle_19"></a>handle_19</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// INT 19h Boot Load Service Entry Point</span><br><span class="hljs-type">void</span> VISIBLE32FLAT<br><span class="hljs-title function_">handle_19</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    debug_enter(<span class="hljs-literal">NULL</span>, DEBUG_HDL_19);<br>    BootSequence = <span class="hljs-number">0</span>;<br>    do_boot(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-boot"><a href="#do-boot" class="headerlink" title="do_boot"></a>do_boot</h3><p>主要的引导函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Determine next boot method and attempt a boot using it.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_boot</span><span class="hljs-params">(<span class="hljs-type">int</span> seq_nr)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (! CONFIG_BOOT)<br>        panic(<span class="hljs-string">&quot;Boot support not compiled in.\n&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (seq_nr &gt;= BEVCount)<br>        boot_fail();<br><br>    <span class="hljs-comment">// Boot the given BEV type.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bev_s</span> *<span class="hljs-title">ie</span> =</span> &amp;BEV[seq_nr];<br>    <span class="hljs-keyword">switch</span> (ie-&gt;type) &#123;<br>    <span class="hljs-keyword">case</span> IPL_TYPE_FLOPPY:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Booting from Floppy...\n&quot;</span>);<br>        boot_disk(<span class="hljs-number">0x00</span>, CheckFloppySig);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> IPL_TYPE_HARDDISK:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Booting from Hard Disk...\n&quot;</span>);<br>        boot_disk(<span class="hljs-number">0x80</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> IPL_TYPE_CDROM:<br>        boot_cdrom((<span class="hljs-type">void</span>*)ie-&gt;<span class="hljs-built_in">vector</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> IPL_TYPE_CBFS:<br>        boot_cbfs((<span class="hljs-type">void</span>*)ie-&gt;<span class="hljs-built_in">vector</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> IPL_TYPE_BEV:<br>        boot_rom(ie-&gt;<span class="hljs-built_in">vector</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> IPL_TYPE_HALT:<br>        boot_fail();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Boot failed: invoke the boot recovery function</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bregs</span> <span class="hljs-title">br</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;br, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(br));<br>    br.flags = F_IF;<br>    call16_int(<span class="hljs-number">0x18</span>, &amp;br);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在boot之前SeaBIOS已经准备好了各个启动设备并放入了BEV数组中，可以看到，可引导设备，为软盘、硬盘、CDROM等一系列设备中引导都提供了支持，如果尝试启动失败，那么就会调用0x18中断，0x18中断实质上是添加BootSequence，然后继续执行do_boot，当没有一个设备可以启动就会调用boot_fail()，可看到最后一项IPL_TYPE_HALT，最后就会打印”No bootable device”。</p><p>我们主要看一下虚拟机从硬盘disk启动的场景，因为这是使用最多的。</p><h3 id="boot-disk-从硬盘启动"><a href="#boot-disk-从硬盘启动" class="headerlink" title="boot_disk 从硬盘启动"></a>boot_disk 从硬盘启动</h3><p>boot_disk(0x80, 1);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//MBR结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mbr_s</span> &#123;</span><br>    u8 code[<span class="hljs-number">440</span>];<br>    <span class="hljs-comment">// 0x01b8</span><br>    u32 diskseg;<br>    <span class="hljs-comment">// 0x01bc</span><br>    u16 null;<br>    <span class="hljs-comment">// 0x01be</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition_s</span> <span class="hljs-title">partitions</span>[4];</span><br>    <span class="hljs-comment">// 0x01fe</span><br>    u16 signature;<br>&#125; PACKED; <br><br><span class="hljs-comment">// Boot from a disk (either floppy or harddrive)</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">boot_disk</span><span class="hljs-params">(u8 bootdrv, <span class="hljs-type">int</span> checksig)</span><br>&#123;<br>    u16 bootseg = <span class="hljs-number">0x07c0</span>;<br><br>    <span class="hljs-comment">// Read sector</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bregs</span> <span class="hljs-title">br</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;br, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(br));<br>    br.flags = F_IF;<br>    br.dl = bootdrv;<br>    br.es = bootseg;<br>    br.ah = <span class="hljs-number">2</span>;<br>    br.al = <span class="hljs-number">1</span>;<br>    br.cl = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//调用0x13中断读取磁盘数据到内存</span><br>    call16_int(<span class="hljs-number">0x13</span>, &amp;br);<br><br>    <span class="hljs-keyword">if</span> (br.flags &amp; F_CF) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Boot failed: could not read the boot disk\n\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (checksig) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mbr_s</span> *<span class="hljs-title">mbr</span> =</span> (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//判断是不是以0xaa55结尾，是否是可引导设备MBR</span><br>        <span class="hljs-keyword">if</span> (GET_FARVAR(bootseg, mbr-&gt;signature) != MBR_SIGNATURE) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Boot failed: not a bootable disk\n\n&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//TPM度量可引导设备</span><br>    tpm_add_bcv(bootdrv, MAKE_FLATPTR(bootseg, <span class="hljs-number">0</span>), <span class="hljs-number">512</span>);<br><br>    <span class="hljs-comment">/* Canonicalize bootseg:bootip */</span><br>    u16 bootip = (bootseg &amp; <span class="hljs-number">0x0fff</span>) &lt;&lt; <span class="hljs-number">4</span>;<br>    bootseg &amp;= <span class="hljs-number">0xf000</span>;<br><br>    <span class="hljs-comment">//跳转到 0x7c00执行MBR，并准备寄存器</span><br>    call_boot_entry(SEGOFF(bootseg, bootip), bootdrv);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，调用BIOS 0x13中断读取磁盘数据到内存，这里读取的是第一个扇区，放到内存0x7c00的位置，也就是MBR开始运行的地方，然后调用TPM进行度量MBR，最后调用call_boot_entry跳转到0x7c00，这样MBR就开始运行了，控制权就转移了，之后MBR就会加载操作系统内核。。</p><h2 id="3-main和runtime阶段"><a href="#3-main和runtime阶段" class="headerlink" title="3 main和runtime阶段"></a>3 main和runtime阶段</h2><p>BIOS移交控制权以后，可能以后的程序，包括操作系统，他们有可能会调用SeaBIOS的一些信息，如访问ACPI表或者调用BIOS的中断，就是中断向量表中的内容，定义在layoutrom.S中，形如entry_xxx函数，xxx代表中断号。</p><h2 id="4-Resume-and-reboot阶段"><a href="#4-Resume-and-reboot阶段" class="headerlink" title="4 Resume and reboot阶段"></a>4 Resume and reboot阶段</h2><p>当虚拟机发生错误或者操作系统发出重启请求时，就会进入这个阶段。SeaBIOS处理重启的入口也在entry_post，但是这次会调用entry_resume，从而进入到handle_resume函数里面。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>后续还会介绍重点关注，与vtpm设备的交互情况。</p>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
      <category>SeaBIOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BIOS</tag>
      
      <tag>MBR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU的事件循环-01 glib事件循环机制</title>
    <link href="/048.html"/>
    <url>/048.html</url>
    
    <content type="html"><![CDATA[<h2 id="01-glib事件循环机制"><a href="#01-glib事件循环机制" class="headerlink" title="01 glib事件循环机制"></a>01 glib事件循环机制</h2><p>Linux系统中“一切皆文件”，包括具体文件、设备、网络、Socket等都被抽象为文件。Linux通过fd来访问一个文件，应用程序也可以调用select、poll、epoll系统调用来监听文件的变化。QEMU程序的运行即是基于各类文件fd事件的，<strong>QEMU在运行过程中会将自己感兴趣的文件fd添加到其监听列表上并定义相应的处理函数</strong>，在其主线程中，有一个循环用来处理这些文件fd的事件，如来自用户的输入、来自VNC的连接、虚拟网卡对应tap设备的收包等。QEMU程序的事件机制是基于glib的，我们需要了解一下glib。</p><h3 id="glib是什么？"><a href="#glib是什么？" class="headerlink" title="glib是什么？"></a>glib是什么？</h3><p>GLib是一种开源的通用C语言库，提供了许多常用的数据类型、数据结构、线程支持、文件操作、内存管理、字符串处理、网络编程等功能，方便开发者进行跨平台的应用程序开发。GLib最初是GTK+项目的一部分，但现在已经成为一个独立的开源项目，其设计目标是为了提供一个高效、可移植、易于使用的C语言库。 其官方网址：<a href="https://docs.gtk.org/glib/">GLib – 2.0 (gtk.org)</a></p><h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><p>我们先说glib事件循环机制一般有什么用？glib实现了一个功能完整的事件循环分发处理的机制，这些事件来源包括各种文件描述符（文件、管道或者socket）、超时和idle事件等，当然也可以自定义事件源。使用这套接口注册事件源以及对应的处理回调方法，可以方便开发基于事件触发的应用，如QEMU。 glib的事件循环机制是基于<code>poll</code>的，这又是牵扯到一个叫做 <strong>I&#x2F;O多路复用</strong> 的概念。 IO多路复用是一种同步 IO 模型,实现一个线程可以监视多个文件句柄。一旦某个文件句柄就绪,就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出CPU。这样就可以减少系统开销，避免创建过多进程或者线程维护文件句柄。而实现IO多路复用的方式主要是这三种：<code>select</code>、<code>poll</code>、<code>epoll</code>。 glib是一个跨平台的库，在Linux上，使用的是<code>poll</code>函数，在window上，使用的是<code>select</code>。而<code>epoll</code>这个接口，在linux2.6中才正式推出，它的效率比前两者更高，在网络编程中大量使用。而本质上，这三个函数，其实是相同的。如果要看详细的对比，可以看这个博主的文章： <a href="https://blog.csdn.net/ChineseSoftware/article/details/123812179">IO 多路复用_io多路复用_JFS_Study的博客-CSDN博客</a></p><h3 id="poll机制"><a href="#poll机制" class="headerlink" title="poll机制"></a>poll机制</h3><p>以poll为例，简单介绍的poll使用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br>...<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span>[2];</span><br><span class="hljs-type">int</span> timeout_msecs = <span class="hljs-number">500</span>;<br><span class="hljs-type">int</span> ret;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-comment">/* Open STREAMS device. */</span><br>fds[<span class="hljs-number">0</span>].fd = open(<span class="hljs-string">&quot;/dev/dev0&quot;</span>, ...);<br>fds[<span class="hljs-number">1</span>].fd = open(<span class="hljs-string">&quot;/dev/dev1&quot;</span>, ...);<br>fds[<span class="hljs-number">0</span>].events = POLLOUT  POLLWRBAND; <span class="hljs-comment">//等待发生的事件</span><br>fds[<span class="hljs-number">1</span>].events = POLLOUT  POLLWRBAND; <span class="hljs-comment">//等待发生的事件</span><br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>    ret = poll(fds, <span class="hljs-number">2</span>, timeout_msecs);<br>    <span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/* An event on one of the fds has occurred. */</span><br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">//检查实际发生的事件</span><br>            <span class="hljs-keyword">if</span> (fds[i].revents &amp; POLLWRBAND) &#123;<br>            <span class="hljs-comment">/* Priority data may be written on device number i. */</span><br>            ...<br>            &#125;<br>            <span class="hljs-keyword">if</span> (fds[i].revents &amp; POLLOUT) &#123;<br>            <span class="hljs-comment">/* Data may be written on device number i. */</span><br>            ...<br>            &#125;<br>            <span class="hljs-keyword">if</span> (fds[i].revents &amp; POLLHUP) &#123;<br>            <span class="hljs-comment">/* A hangup has occurred on device number i. */</span><br>            ...<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>上面这个代码，我们可以把它拆分成3部分：</p><ol><li><p>准备要检测的文件集合（不是简单的准备“文件描述符”的集合，而是准备<code>struct pollfd</code>结构体的集合。这就包括了文件描述符，以及希望监控的事件，如可读&#x2F;可写&#x2F;或可执行其他操作等)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span><br><span class="hljs-type">int</span> fd;        <span class="hljs-comment">/* 文件描述符 */</span><br><span class="hljs-type">short</span> events;  <span class="hljs-comment">/* 等待的事件 */</span><br><span class="hljs-type">short</span> revents; <span class="hljs-comment">/* 实际发生了的事件 */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>执行<code>poll</code>，等待事件发生（文件描述符对应的文件可读&#x2F;可写&#x2F;或可执行其他操作等）或者是函数超时返回。</p></li><li><p>遍历文件集合（<code>struct pollfd</code>结构体的集合)，判断具体是哪些文件有“事件”发生，并且进一步判断是何种“事件”。然后，根据需求，执行对应的操作（上面的代码中，用…表示的对应操作)。</p></li></ol><p>其中<strong>2</strong>和<strong>3</strong>对应的代码，都放在一个<code>while</code>循环中。而在<strong>3</strong>中所谓的“对应的操作”，还可以包括一种“退出”操作，这样的话，就可以从<code>while</code>循环中退出，这样的话，整个进程也有机会正常结束。 这段代码比较简单，但是存在一些使用上的问题：</p><ol><li>这段代码里仅仅打开了两个文件，传递给poll函数，如果程序运行过程中，想要动态的增加poll函数监控的文件，怎么实现？</li><li>这段代码里面，设置的超时时间是固定的，加入某个时刻有100个文件需要监控，那么怎么针对100个文件设置不同的超时时间？</li><li>这段代码里面，当poll函数返回时，对监控的每个fd进行遍历，逐个判断并执行对应的擦欧总。那如果有100个文件被监控，其中某个文件优先级很高，非常紧急怎么办？</li></ol><p>可以从面向对象的角度来看：</p><ol><li>对第1个问题，可以想到，需要对 <strong>所有的文件</strong>（<code>struct pollfd</code>）做一个统一的管理，需要有添加和删除文件的功能。用面向对象的思想来看，这就是一个类，暂且叫做<strong>类A</strong>。</li><li>对第2个问题，可以想到，还需要对 <strong>每一个被监控的文件</strong>（<code>struct pollfd</code>）做更多的控制。也可以用一个类来包装被监控的文件，对这个文件进行管理，在该对象中，包含了<code>struct pollfd</code>结构体，该类还可以提供对应的文件所期望的超时时间。暂且叫做<strong>类B</strong>。</li><li>对第3个问题，可以考虑为每一个被监控的文件设置一个优先级，然后就可以根据优先级优先执行更“紧急”的“对应的操作”。这个优先级信息，也可以存储在<strong>类B</strong>中。设计出了<strong>类B</strong>之后，<strong>类A</strong>就不再是直接统一管理文件了，而是变成统一管理<strong>类B</strong>，可以看成是<strong>类B</strong>的一个容器类。</li></ol><p>有了这些思想，在glib中的GMainLoop等就是做的这些事，接下来就看看glib中是怎么按照这个思想实现的。</p><h3 id="glib事件循环涉及的重要数据结构"><a href="#glib事件循环涉及的重要数据结构" class="headerlink" title="glib事件循环涉及的重要数据结构"></a>glib事件循环涉及的重要数据结构</h3><p>要深入理解glib事件循环机制，还是要看：<a href="https://github.com/GNOME/glib">Glib源码</a> <code>glib</code>的主事件循环框架，由3个类来实现，<code>GMainLoop</code>，<code>GMainContext</code>和<code>GSource</code>。 其中对应关系：一个<code>GMainLoop</code>只包含一个<code>GMainContext</code>，一个<code>GMainContext</code>可以对应多个<code>GSource</code>。这里面最主要的还是<code>GMainContext</code>和<code>GSource</code>，分别对应前面提到的<strong>类A</strong>和<strong>类B</strong>。 <strong>GSource</strong> <code>GSource</code>相当于前面提到的<strong>类B</strong>，它里面会保存优先级信息以及对应的需要监控的文件，并且GSource是一个链表的结构，保存了下一个GSource的引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">GSource</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/*&lt; private &gt;*/</span><br>  gpointer callback_data; <span class="hljs-comment">//回调函数的参数。</span><br>  GSourceCallbackFuncs *callback_funcs; <span class="hljs-comment">//回调函数的指针。</span><br><br>  <span class="hljs-type">const</span> GSourceFuncs *source_funcs; <span class="hljs-comment">//GSource 的函数指针，用于实现 GSource 的事件处理逻辑。</span><br>  guint ref_count;<br><br>  GMainContext *context; <span class="hljs-comment">//GSource 所属的 GMainContext。</span><br><br>  gint priority; <span class="hljs-comment">//GSource 的优先级。</span><br>  guint flags; <span class="hljs-comment">//GSource 的标志位，表示 GSource 的状态和类型。</span><br>  guint source_id; <span class="hljs-comment">//GSource 的唯一标识符。</span><br><br>  GSList *poll_fds; <span class="hljs-comment">//GSource 关心的文件描述符列表。</span><br><br>  GSource *prev; <span class="hljs-comment">//GSource 在 GMainContext 中的链表中的前驱和后继。</span><br>  GSource *next; <br><br>  <span class="hljs-type">char</span>    *name; <span class="hljs-comment">//GSource 的名称。</span><br><br>  GSourcePrivate *priv; <span class="hljs-comment">//GSource 的私有数据。</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>GSource 的函数指针指向的结构体定义了用于实现 GSource 的事件处理逻辑。（从面向对象的角度看，<code>GSource</code>是一个抽象类，而且有4个重要的纯虚函数，需要子类来具体实现)，这4个函数就是：其中最重要的还是prepare、check、dispatch。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">GSourceFuncs</span></span><br><span class="hljs-class">&#123;</span><br>  gboolean (*prepare)  (GSource    *source,<br>                        gint       *timeout_);<span class="hljs-comment">/* Can be NULL */</span><br>  gboolean (*check)    (GSource    *source);<span class="hljs-comment">/* Can be NULL */</span><br>  gboolean (*dispatch) (GSource    *source,<br>                        GSourceFunc callback,<br>                        gpointer    user_data);<br>  <span class="hljs-comment">//释放资源的</span><br>  <span class="hljs-type">void</span>     (*finalize) (GSource    *source); <span class="hljs-comment">/* Can be NULL */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们对比poll机制中示例代码中的3部分，这个<code>prepare</code>函数，就是要在第一部分被调用的，<code>check</code>和<code>dispathch</code>函数，就是在第3部分被调用的。有一点区别是，<code>prepare</code>函数也要放到<code>while</code>循环中，而不是在循环之外（因为要动态的增加或者删除<code>poll</code>函数监控的文件)。</p><ol><li><code>prepare</code>函数，会在执行<code>poll</code>之前被调用。该<code>GSource</code>中的<code>struct pollfd</code>是否希望被<code>poll</code>函数监控，就由<code>prepare</code>函数的返回值来决定。</li><li><code>check</code>函数，在执行<code>poll</code>之后被调用。该<code>GSource</code>中的<code>struct pollfd</code>是否有事件发生，就由<code>check</code>函数的返回值来描述（在<code>check</code>函数中可以检测<code>struct pollfd</code>结构体中的返回信息)。</li><li><code>dispatch</code>函数，在执行<code>poll</code>和<code>check</code>函数之后被调用，并且，仅当对应的<code>check</code>函数返回true的时候，对应的<code>dispatch</code>函数才会被调用，<code>dispatch</code>函数，就相当于“对应的操作”。</li></ol><p><img src="/wp-content/uploads/2023/06/image-1686191288096.png" alt="file"> <strong>GMainContext</strong> <code>GMainContext</code>是<code>GSource</code>的容器，<code>GSource</code>可以添加到<code>GMainContext</code>里面（间接的就把<code>GSource</code>中的<code>struct pollfd</code>也添加到<code>GMainContext</code>里面了)，<code>GSource</code>也可以从<code>GMainContext</code>中移除（间接的就把<code>GSource</code>中的<code>struct pollfd</code>从<code>GMainContext</code>中移除了）。<code>GMainContext</code>可以遍历<code>GSource</code>，自然就有机会调用每个<code>GSource</code>的<code>prepare/check/dispatch</code>函数，可以根据每个<code>GSource</code>的<code>prepare</code>函数的返回值来决定，是否要在<code>poll</code>函数中，监控该<code>GSource</code>管理的文件。当然可以根据<code>GSource</code>的优先级进行排序。当<code>poll</code>返回后，可以根据每个<code>GSource</code>的<code>check</code>函数的返回值来决定是否需要调用对应的<code>dispatch</code>函数。 <code>GMainContext</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * GMainContext:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The `GMainContext` struct is an opaque data</span><br><span class="hljs-comment"> * type representing a set of sources to be handled in a main loop.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">GMainContext</span> <span class="hljs-title">GMainContext</span>;</span><br><br><span class="hljs-comment">//以下结构体省略了很多字段，多线程之间同步互斥等字段都以省略，</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">GMainContext</span> &#123;</span><br>  GThread *owner; <span class="hljs-comment">/* 拥有该 GMainContext 的线程 */</span><br><br>  GHashTable *sources;     <span class="hljs-comment">/* 存储所有的 GSource 对象 */</span><br><br>  GList *source_lists;        <span class="hljs-comment">/* 存储不同优先级的 GSource 对象列表 */</span><br>  GPollRec *poll_records;     <span class="hljs-comment">/* 存储需要监听的文件描述符及其对应的事件类型 */</span><br><br>  guint next_id;              <span class="hljs-comment">/* 下一个 GSource 对象的 ID */</span><br>  GPollFunc poll_func;        <span class="hljs-comment">/* 用于监听文件描述符状态变化的函数 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>GMainLoop</strong> GMainLoop结构一般调用下面的方法<code>g_main_loop_new</code>创建，需要传入GMainContext，这个参数可以为NULL，将使用默认的上下文，这个结构体代表着一个事件循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">GMainLoop* <span class="hljs-title function_">g_main_loop_new</span> <span class="hljs-params">(</span><br><span class="hljs-params">  GMainContext* context,</span><br><span class="hljs-params">  gboolean is_running</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure><h3 id="glib中g-main-context-iterate-关键函数理解"><a href="#glib中g-main-context-iterate-关键函数理解" class="headerlink" title="glib中g_main_context_iterate()关键函数理解"></a>glib中g_main_context_iterate()关键函数理解</h3><p><code>g_main_loop_run</code> 函数是 GLib 中用于运行主循环的函数之一。它的作用是启动主循环并运行，直到被调用的 <code>g_main_loop_quit</code> 函数被调用或者发生错误（比如被信号中断）。 我们使用时一般都是按照如下步骤：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    GMainLoop *loop = g_main_loop_new(<span class="hljs-literal">NULL</span>, FALSE);<br>    <span class="hljs-comment">// 注册事件源到主循环中</span><br>    ...<br>    <span class="hljs-comment">// 启动主循环并运行</span><br>    g_main_loop_run(loop);<br>    <span class="hljs-comment">// 主循环结束，清理资源</span><br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们看一下源码：<code>g_main_loop_run</code> 函数中的<code>g_main_context_iterate()</code>函数，其实就相当于poll机制中代码片段中的循环体中要做的动作。循环的退出，则是靠<code>loop-&gt;is_running</code>这个标记变量来标识的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">g_main_loop_run</span> <span class="hljs-params">(GMainLoop *loop)</span><br>&#123;<br>    ...<br>    <span class="hljs-comment">//该标志会出现错误等情况被设置为false，终止循环。</span><br>    loop-&gt;is_running = TRUE;<br>    <span class="hljs-keyword">while</span> (loop-&gt;is_running)<br>       g_main_context_iterate (loop-&gt;context, TRUE, TRUE, self);<br>    ...<br>&#125;<br><br><span class="hljs-type">static</span> gboolean <span class="hljs-title function_">g_main_context_iterate</span> <span class="hljs-params">(GMainContext *context, </span><br><span class="hljs-params">        gboolean block, gboolean dispatch, GThread *self)</span> <br>&#123;<br>    gint max_priority;<br>    gint timeout;<br>    gboolean some_ready;<br>    gint nfds, allocated_nfds;<br>    GPollFD *fds = <span class="hljs-literal">NULL</span>;<br><br>    UNLOCK_CONTEXT (context);<br>    ...<br>    <span class="hljs-keyword">if</span> (!context-&gt;cached_poll_array) &#123;<br>        context-&gt;cached_poll_array_size = context-&gt;n_poll_records;<br>        context-&gt;cached_poll_array = g_new (GPollFD, context-&gt;n_poll_records);<br>    &#125;<br>    allocated_nfds = context-&gt;cached_poll_array_size;<br>    fds = context-&gt;cached_poll_array;<br><br>    UNLOCK_CONTEXT (context);<br><br>    <span class="hljs-comment">//prepare实现方法，准备需要被监控的fd</span><br>    g_main_context_prepare(context, &amp;max_priority);<br>    <span class="hljs-keyword">while</span> ((nfds = g_main_context_query(context, max_priority, &amp;timeout, fds,<br>                                        allocated_nfds)) &gt; allocated_nfds) &#123;<br>        LOCK_CONTEXT (context);<br>        g_free(fds);<br>        context-&gt;cached_poll_array_size = allocated_nfds = nfds;<br>        context-&gt;cached_poll_array = fds = g_new (GPollFD, nfds);<br>        UNLOCK_CONTEXT (context);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!block)<br>        timeout = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//poll函数简单封装</span><br>    g_main_context_poll(context, timeout, max_priority, fds, nfds);<br>    <span class="hljs-comment">//检查有没有需要处理的fd</span><br>    some_ready = g_main_context_check(context, max_priority, fds, nfds);<br>    <span class="hljs-keyword">if</span> (dispatch)<br>        <span class="hljs-comment">//调用对应的处理方法。</span><br>        g_main_context_dispatch(context);<br><br>    LOCK_CONTEXT (context);<br>    <span class="hljs-keyword">return</span> some_ready;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第一部分-准备要监控的文件集合"><a href="#第一部分-准备要监控的文件集合" class="headerlink" title="第一部分 准备要监控的文件集合"></a>第一部分 准备要监控的文件集合</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">g_main_context_prepare(context, &amp;max_priority);<br><br><span class="hljs-keyword">while</span> ((nfds = g_main_context_query(context, max_priority, &amp;timeout, fds,<br>                                    allocated_nfds)) &gt; allocated_nfds) &#123;<br>    LOCK_CONTEXT (context);<br>    g_free(fds);<br>    context-&gt;cached_poll_array_size = allocated_nfds = nfds;<br>    context-&gt;cached_poll_array = fds = g_new (GPollFD, nfds);<br>    UNLOCK_CONTEXT (context);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是调用<code>g_main_context_prepare(context, &amp;max_priority)</code>，这个就是遍历每个<code>GSource</code>，调用每个<code>GSource</code>的<code>prepare</code>函数，选出一个最高的优先级<code>max_priority</code>，函数内部其实还计算出了一个最短的超时时间。 然后调用<code>g_main_context_query</code>，其实这是再次遍历每个<code>GSource</code>，把优先级等于<code>max_priority</code>的<code>GSource</code>中的<code>struct pollfd</code>，添加到<code>poll</code>的监控集合中。</p><h4 id="第二部分-执行poll，等待事件发生"><a href="#第二部分-执行poll，等待事件发生" class="headerlink" title="第二部分 执行poll，等待事件发生"></a>第二部分 执行poll，等待事件发生</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (!block)<br>    timeout = <span class="hljs-number">0</span>;<br>g_main_context_poll(context, timeout, max_priority, fds, nfds);<br></code></pre></td></tr></table></figure><p>就是调用<code>g_main_context_poll(context, timeout, max_priority, fds, nfds)</code>，<code>g_main_context_poll</code>只是对<code>poll</code>函数的一个简单封装。</p><h4 id="第三部分-遍历被监控的文件集合，执行对应操作"><a href="#第三部分-遍历被监控的文件集合，执行对应操作" class="headerlink" title="第三部分 遍历被监控的文件集合，执行对应操作"></a>第三部分 遍历被监控的文件集合，执行对应操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">some_ready = g_main_context_check(context, max_priority, fds, nfds);<br><span class="hljs-keyword">if</span> (dispatch)<br>    g_main_context_dispatch(context);<br></code></pre></td></tr></table></figure><p>实际上，<code>glib</code>的处理方式是，先遍历所有的<code>GSource</code>，执行<code>g_main_context_prepare(context, &amp;max_priority)</code>，调用每个GSource的<code>check</code>函数，然后把满足条件的<code>GSource</code>（<code>check</code>函数返回<code>true</code>的<code>GSource</code>)，添加到一个内部链表中。 然后执行<code>g_main_context_dispatch(context)</code>，遍历刚才准备好的内部链表中的<code>GSource</code>，调用每个<code>GSource</code>的<code>dispatch</code>函数。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>所以可以看出，glib实现方式与poll机制使用思想是一致的，只是实现上更加复杂了，上述我们没有讨论到多线程等情况，如果讨论了会更加复杂。</p><h3 id="glib事件循环机制使用示例"><a href="#glib事件循环机制使用示例" class="headerlink" title="glib事件循环机制使用示例"></a>glib事件循环机制使用示例</h3><p>经过上面的了解，大概也知道了glib事件循环机制主要的结构和实现的思路，我们再给出一个例子可以更好的了解glib事件循环机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 文件描述符的回调函数，用于处理文件描述符的可读事件</span><br><span class="hljs-type">static</span> gboolean <span class="hljs-title function_">on_fd_events</span><span class="hljs-params">(GIOChannel *channel, GIOCondition condition, gpointer data)</span> &#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>    gsize bytes_read;<br>    <span class="hljs-comment">// 从文件描述符中读取数据</span><br>    g_io_channel_read_chars(channel, buffer, <span class="hljs-keyword">sizeof</span>(buffer), &amp;bytes_read, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 处理读取到的数据</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received data: %s\n&quot;</span>, buffer);<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    GMainLoop *loop;<br>    GIOChannel *channel;<br>    GSource *source;<br>    <span class="hljs-type">int</span> fd;<br><br>    <span class="hljs-comment">// 打开文件</span><br>    fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建 GIOChannel 对象，用于封装文件描述符</span><br>    channel = g_io_channel_unix_new(fd);<br><br>    <span class="hljs-comment">// 创建 GSource 对象，用于监听文件描述符的可读事件</span><br>    source = g_io_create_watch(channel, G_IO_IN);<br><br>    <span class="hljs-comment">// 设置 GSource 的回调函数</span><br>    g_source_set_callback(source, (GSourceFunc)on_fd_events, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建 GMainLoop 对象，用于启动事件循环</span><br>    loop = g_main_loop_new(<span class="hljs-literal">NULL</span>, FALSE);<br><br>    <span class="hljs-comment">// 将 GSource 对象添加到事件循环中</span><br>    g_source_attach(source, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 启动事件循环</span><br>    g_main_loop_run(loop);<br><br>    <span class="hljs-comment">// 清理资源</span><br>    g_source_destroy(source);<br>    g_main_loop_unref(loop);<br>    g_io_channel_unref(channel);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先查看glib在哪儿不然直接编译有可能出错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@test-ubuntu-no-vgpu:~# pkg-config --cflags --libs glib-2.0<br>-I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include -lglib-2.0<br><br>root@test-ubuntu-no-vgpu:~# gcc glib_test.c -o glib_test -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include -lglib-2.0<br>root@test-ubuntu-no-vgpu:~# ./glib_test<br>Received data: 123456789<br>7F<br>Received data: 123456789<br>7F<br>Received data: 123456789<br>...<br></code></pre></td></tr></table></figure><p>可以看到在上述代码中，我们先创建了<code>GSource</code>，添加了需要监听的fd，然后将<code>GSource</code>加入了默认<code>GMainContext</code>中，然后启动事件循环。</p><h3 id="如何自定义事件源"><a href="#如何自定义事件源" class="headerlink" title="如何自定义事件源"></a>如何自定义事件源</h3><p>glib还支持自定义我们的事件源GSource，可以参考这个博主的<a href="https://github.com/liyansong2018/glib_demo">liyansong2018&#x2F;glib_demo: glib 主事件循环的案例 (github.com)</a>。 基本上就是定义事件源结构，实现对应的Gsource的抽象接口，QEMU中也实现了自己的自定义事件源AioContext。 如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* 自定义事件源 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyGSource</span> &#123;</span><br>    GSource source;<br>    ...<br>    其他字段<br>    GPollFD fd;<br>&#125; MyGSource;<br><br><span class="hljs-comment">//实现如下几个方法</span><br>gboolean <span class="hljs-title function_">g_source_myself_prepare</span><span class="hljs-params">(GSource * source, gint * timeout)</span>;<br>gboolean <span class="hljs-title function_">g_source_myself_check</span><span class="hljs-params">(GSource * source)</span>;<br>gboolean <span class="hljs-title function_">g_source_myself_dispatch</span><span class="hljs-params">(GSource * source,</span><br><span class="hljs-params">                GSourceFunc callback, gpointer user_data)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">g_source_myself_finalize</span><span class="hljs-params">(GSource * source)</span>;<br><br><span class="hljs-comment">//自定义函数集合</span><br>GSourceFuncs g_source_myself_funcs = &#123;<br>        g_source_myself_prepare,<br>        g_source_myself_check,<br>        g_source_myself_dispatch,<br>        g_source_myself_finalize,<br>    &#125;;<br><br><span class="hljs-comment">//使用方法：</span><br>GMainLoop *loop = g_main_loop_new(<span class="hljs-literal">NULL</span>, FALSE);<br><span class="hljs-comment">//事件源容器创建，事件源上下文</span><br>GMainContext *context = g_main_loop_get_context(loop);<br><span class="hljs-comment">//事件源创建，绑定对应的事件处理函数</span><br>GSource *source = g_source_new(&amp;g_source_myself_funcs, <span class="hljs-keyword">sizeof</span>(MyGSource));<br>MyGSource *source_myself = (MyGSource *) source;<br><span class="hljs-comment">//绑定要监听的fd</span><br>g_source_add_poll(source, &amp;source_myself-&gt;fd);<br><span class="hljs-comment">//添加事件源</span><br>g_source_attach(source, context);<br><span class="hljs-comment">//开启主循环</span><br>g_main_loop_run(loop);<br></code></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://blog.csdn.net/ChineseSoftware/article/details/123812179">IO 多路复用_io多路复用_JFS_Study的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/huang987246510/article/details/90738137">深入理解qemu事件循环 —— 基本框架_享乐主的博客-CSDN博客</a></li><li><a href="https://github.com/liyansong2018/glib_demo">liyansong2018&#x2F;glib_demo: glib 主事件循环的案例 (github.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/512939620">Glib事件循环机制 - 知乎 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/u013554213/article/details/104789699">【glib】GMainLoop的实现原理和代码模型_EthanYYYY的博客-CSDN博客</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>openstack报错：nova.compute.manager nova.exception.PortBindingFailed</title>
    <link href="/0037.html"/>
    <url>/0037.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2021-03-25 05:39:29.986 50398 ERROR nova.compute.manager nova.exception.PortBindingFailed: Binding failed for port d5b2d94a-b79a-4d6b-93ec-9c5a19b5221e, please check neutron logs for more information.<br></code></pre></td></tr></table></figure><p>根据提示是nova组建报错，查看nova相关日志，提示查看neutron相关日志。 查看&#x2F;var&#x2F;log&#x2F;neutron&#x2F;linuxbridge-agent.log发现该日志一直在刷新，查看neutron相关服务，发现neutron-linuxbridge-agent服务一直在重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">2021-03-25 07:07:06.327 469548 WARNING oslo.privsep.daemon [-] privsep log: PermissionError: [Errno 13] Permission denied: ‘/var/log/neutron/privsep-helper.log’<br>2021-03-25 07:07:06.432 469548 CRITICAL oslo.privsep.daemon [-] privsep helper command exited non-zero (1)<br>2021-03-25 07:07:06.433 469548 CRITICAL neutron [-] Unhandled error: oslo_privsep.daemon.FailedToDropPrivileges: privsep helper command exited non-zero (1)<br></code></pre></td></tr></table></figure><p>解决 在&#x2F;etc&#x2F;sudoers.d&#x2F;neutron中添加</p><p><code>neutron ALL = (root) NOPASSWD: /usr/bin/privsep-helper *</code></p>]]></content>
    
    
    <categories>
      
      <category>OpenStack</category>
      
      <category>云计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机加电后启动后的内存布局-BIOS-bootloader-OS</title>
    <link href="/005.html"/>
    <url>/005.html</url>
    
    <content type="html"><![CDATA[<h1 id="计算机加电后BIOS启动的内存布局"><a href="#计算机加电后BIOS启动的内存布局" class="headerlink" title="计算机加电后BIOS启动的内存布局"></a>计算机加电后BIOS启动的内存布局</h1><h2 id="计算机启动流程"><a href="#计算机启动流程" class="headerlink" title="计算机启动流程"></a>计算机启动流程</h2><p>这张图可以清晰的看出来启动流程：</p><p><img src="/wp-content/uploads/2023/06/image-1686189888942.png" alt="file"></p><h2 id="内存映射图和布局"><a href="#内存映射图和布局" class="headerlink" title="内存映射图和布局"></a>内存映射图和布局</h2><p><img src="/wp-content/uploads/2023/06/image-1686189898456.png" alt="file"></p><p>区域起始地址</p><p>区域结束地址</p><p>大小</p><p>描述</p><p>0000h</p><p>03FFh</p><p>1 KB</p><p>中断向量表</p><p>0400h</p><p>04FFh</p><p>256 B</p><p>BIOS 数据区</p><p>0500h</p><p>7BFFh</p><p>30 KB</p><p>自定义区域</p><p>7C00h</p><p>7DFFh</p><p>512 B</p><p>MBR 被 BIOS 加载到的内存区域</p><p>7E00h</p><p>9FBFFh</p><p>608 KB</p><p>自定义区域</p><p>9FC00h</p><p>9FFFFh</p><p>1 KB</p><p>扩展 BIOS 数据区</p><p>A0000h</p><p>AFFFFh</p><p>64 KB</p><p>彩色显示适配器</p><p>B0000h</p><p>B7FFFh</p><p>32 KB</p><p>黑白显示适配器</p><p>B8000h</p><p>BFFFFh</p><p>32 KB</p><p>文本显示适配器</p><p>C0000h</p><p>C7FFFh</p><p>32 KB</p><p>显示适配器 BIOS</p><p>C8000h</p><p>EFFFFh</p><p>160 KB</p><p>映射硬件适配器的 ROM 或内存映射 I&#x2F;O</p><p>F0000h</p><p>FFFEFh</p><p>64 KB-16</p><p>真正的入口</p><p>FFFF0h</p><p>FFFFFh</p><p>16 B</p><p>BIOS 入口地址（跳转使用，因为空间有限）</p><h2 id="上电，按下开机键"><a href="#上电，按下开机键" class="headerlink" title="上电，按下开机键"></a>上电，按下开机键</h2><p>按下主机的电源键后，计算机开始启动，主板上电后开始初始化其固件（firmware）。固件是一些固化在芯片组上的程序，它会试图去启动 CPU。如果启动失败（例如 CPU 坏了或没插好），计算机就会死机并给出错误提示（如某些版本的主板固件会发出蜂鸣警告）。这种状态称为“zoombie-with-fans”。</p><p>如果前一个阶段未出错，就开始加电工作，在多 CPU 或多核 CPU 情况下，某一个 CPU 会被随机选取作为启动 CPU（bootstrap processor，BSP）运行 BIOS 内部的程序。其余的 CPU（application processor，AP）保持停机直到操作系统内核显式地使用它们。</p><blockquote><p>2000 年以前的计算机主板上均使用 <a href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a>，如今绝大多数计算机采用的是 <a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2">EFI</a>（Mac 用的就是 EFI）或 <a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a>，BIOS 正在逐步被淘汰。基于 EFI、UEFI 的开机过程与传统的BIOS不尽相同，本文将以传统的 BIOS，Intel CPU 为例介绍开机过程。</p></blockquote><p>此时 CPU 工作模式为实模式，该模式下地址总线是 20 位，寻址范围是 <code>0x00000</code>~&#96;0xFFFFF&#96; 的 1M 范围。这也就解释了为什么 BIOS 的容量只有 1MB。</p><blockquote><p>CPU的工作模式是指CPU的寻址方式、寄存器大小等用来反应CPU在该环境下如何工作的概念。</p><p>Intel CPU 用三种运行模式: 实模式、32 位保护模式、64 位保护模式。</p><ul><li><strong>实模式</strong>：实模式出现于早期8088CPU时期，当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB）。实模式下地址计算为：<code>物理地址 = 段基址&lt;&lt;4+段内偏移</code>，这样就可以使用16位寄存器，表示20位地址。该模式下，CPU的得到的地址就是物理地址，可以直接访问，没有区分系统程序或者应用程序。没有虚拟地址的概念，实模式下没有分段或是分页机制，逻辑地址和物理地址相等。<ul><li>在实模式下最大寻址空间时1M，1M以上的内存空间在实模式下不会被使用。</li><li>在实模式所有的内存数据都可以被访问。不存在用户态、内核态之分。</li><li>在BIOS加载、MBR、ntdlr启动阶段都处在实模式下。</li></ul></li><li><strong>保护模式</strong>：随着CPU、内存的发展，CPU的地址线的个数也从原来的20根变为现在的32根，所以可以访问的内存空间也从1MB变为现在4GB，寄存器的位数也变为32位。实模式下的内存地址计算方式就已经不再适合了，因此引入了保护模式，实现内存的安全访问。但是由于<strong>兼容性问题</strong>，操作系统启动前的启动过程依旧是实模式，操作系统内核启动后，切换为保护模式，该模式下，进程访问的都是虚拟地址，需要操作系统实现地址转换，这阶段才有的页表，权限控制等。保护模式的寻址方式是通过逻辑地址 (Logical Address) 的 <code>segment:offset</code> 中的 <code>segment</code> 作为 <code>selector</code> 来索引到 <code>GDT/LDT</code> 中的一项，然后通过 <code>flags</code> 判断当前程序是否可以访问这段内存，可以访问的话提取 <code>base</code>与 <code>offset</code> 相加得到线性地址 (Linear Address)，最后将线性地址通过分页表得到物理地址 (Physical Address) 。<ul><li>现在应用程序运行的模式均处于保护模式。</li><li>横向保护，又叫任务间保护，多任务操作系统中，一个任务不能破坏另一个任务的代码，这是通过内存分页以及不同任务的内存页映射到不同物理内存上来实现的。</li><li>纵向保护，又叫任务内保护，系统代码与应用程序代码虽处于同一地址空间，但系统代码具有高优先级，应用程序代码处于低优先级，规定只能高优先级代码访问低优先级代码，这样杜绝用户代码破坏系统代码。</li></ul></li></ul></blockquote><p>1981年IBM PC机刚推出时系统只带有640KB的RAM。由于所采用的8088&#x2F;8086 CPU只有20根地址线，因此内存寻址范围最高为1024KB(1MB)。现如今，CPU的物理内存寻址范围已经可以到4GB。但是为了与原来的PC兼容，系统1MB以下物理内存使用分配上任然保持与原来的PC机基本一致。ROM BIOS 都在物理内存能寻址的最高端位置处，所以在大于 1M 内存的新计算机上，ROM BIOS 最后会被映射到 1M 末尾的区域中（也就是ROM BIOS映射区域）。内存映射图如下图所示:</p><p><img src="/wp-content/uploads/2023/06/image-1686189898456.png" alt="file"></p><p>计算机上电初始化时，物理内存被设置成从地址 0 开始的连续区域。除了地址从 <code>0xA0000 ~ 0xFFFFF</code>（640K<del>1M）存放显存和 ROM BIOS 和 &#96;0xFFFE0000</del>0xFFFFFFFF&#96;（4G 的最后 64K）存放 ROM BIOS 以外，其他部分都可以用作主要内存。</p><p>我们可以通过<code>cat /pro/iomem</code>查看系统物理内存映射信息。 <img src="/wp-content/uploads/2023/06/image-1686189959775.png" alt="file"></p><p>对照上图，可以看到<code>0xF0000 ~ 0xFFFFF</code>（最靠近1M的64KB这个区间是ROM BIOS的映射区域），<code>0xA0000 ~ 0xBFFFF</code>这段是显示缓冲区，<code>0xC0000 ~ 0xC7FFF</code>这段是VGA的ROM BIOS区域。</p><p><img src="/wp-content/uploads/2023/06/image-1686189942478.png" alt="file"></p><h3 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h3><h4 id="问题1-CPU到底是怎么加载BIOS的？"><a href="#问题1-CPU到底是怎么加载BIOS的？" class="headerlink" title="问题1 CPU到底是怎么加载BIOS的？"></a>问题1 CPU到底是怎么加载BIOS的？</h4><p>现在我们知道了大致的内存分布，也知道一般存放BIOS的ROM硬件会被映射到最靠近4GB（0xFFFFFFF0）的那个地址空间，然后因为该地址空间在实模式下无法被寻址，只能将数据映射到1M以内的空间，那么这个CPU到底是怎么找到存放在ROM里的BIOS代码呢？</p><p>这就需要提到一个概念：<strong>重置向量</strong>，又叫<strong>复位向量</strong></p><p>重置向量的设计是CPU标准，为了统一标准，方便CPU找到相应的固件代码执行，并且由于兼容性考虑，依旧是采用1M一下内存空间运行BIOS代码，所以在32位甚至64位系统中需要重置向量，将CPU执行的寄存器设置到1M以内。</p><p>具体的，在CPU上电后，大部分寄存器都被初始化，包括指令指针寄存器（EIP）、CS代码段寄存器，它记录了下一条即将被CPU执行的指令所在的内存地址。其中EIP会被初始化为<code>0xFFF0</code>,CS会被初始化为<code>0xF000</code>，但是CS的基址会被初始化为<code>0xFFFF0000</code>，通常情况下此模式下CPU寻址方式位<code>cs &lt;&lt; 6 + EIP</code>，但是CS还包含了隐藏的基址部分，此时 CPU 会有一个特殊行为，其会对 EIP 的初始值加上一个CS基址寄存器的值，生成一个 32 位的地址 <code>CS基址+EIP</code> &#x3D;<code>0xFFFF0000</code>+<code>0xFFF0</code> &#x3D; <code>0xFFFFFFF0</code> 。之所以称为特殊行为，是因为实模式下 CPU 只能寻址 1MB 地址空间，而这个 32 位地址已经大于 1MB 的内存限制。因此，<code>0xFFFFFFF0</code> 也被称为重置向量（reset vector）.</p><p>于是，CPU 开始执行 <code>0xFFFFFFF0</code> 地址处的指令，该地址处是一条 <code>JUMP</code> 指令，这条指令清空了基址寄存器的值，并让指令跳回到 BIOS 开始处（物理地址为 <code>0xF0000</code>，参考上图 <code>0xF0000</code> 处的标识）以执行 BIOS。</p><blockquote><p>ps: 完整的CS段寄存器由两部分组成，分别是可见部分和隐藏部分，可见部分就是能偶被程序设置和读取的部分，隐藏的部分就是基址部分。</p></blockquote><p>如下图，0xFFFFFFF0处是一个跳转指令， 为了和以前的 BIOS 代码兼容，故地址 0xFFFFFFF0 处的指令还是一条长跳转指令<code>jmp F000:E05B</code>。</p><p><img src="/wp-content/uploads/2023/06/image-1686189981734.png" alt="file"></p><p>将要跳转的地址：F000:E05B，其中F000代表CS寄存器的值，E05B代表EIP的值。当执行完重置向量之后，其实CS段寄存器的值已经被修改了，CPU此时寻址，不再是特殊方式（CS基址+EIP），而是实模式通用寻址：<code>CS &lt;&lt; 4+EIP</code>，也就是说F000:E05B，将会跳转到0xFE05B执行，刚好位于1M的空间内。</p><p>于是 Intel 设计了一种映射机制，<strong>将内存高端的 BIOS ROM 映射到 1MB 以内的 RAM 空间里，并且可以使这一段被映射的 RAM 空间具有与 ROM 类似的只读属性</strong>。所以 PC 机启动时将开启这种映射机制，让 4GB 地址空间的最高一个 64KB 的内容等同于 1MB 地址空间的最高一个 64K 的内容，从而使得执行了长跳转指令后，其实是回到了早期的 8086 CPU 初始化控制流，保证了向下兼容。</p><h4 id="问题2-cpu加电执行的第一句代码，究竟是从BIOS的ROM中执行，还是从内存中执行？"><a href="#问题2-cpu加电执行的第一句代码，究竟是从BIOS的ROM中执行，还是从内存中执行？" class="headerlink" title="问题2 cpu加电执行的第一句代码，究竟是从BIOS的ROM中执行，还是从内存中执行？"></a>问题2 cpu加电执行的第一句代码，究竟是从BIOS的ROM中执行，还是从内存中执行？</h4><p>cpu加电执行的第一句代码，究竟是从ROM中执行？还是从内存RAM中执行？<a href="https://bbs.csdn.net/topics/90489738">请教，cpu加电执行的第一句代码，究竟是从bios中执行，还是从内存中执行？-CSDN社区</a></p><p>这个问题，网上大家讨论的很激烈，大致的意思就是ROM和RAM是统一编址，ROM不需要载入内存，CPU也能寻址到指令进行执行，就像前面分析的，执行的第一条重置向量跳转指令，就是在ROM BIOS之中。</p><h4 id="问题3-ROM-BIOS是什么时候映射到RAM中的"><a href="#问题3-ROM-BIOS是什么时候映射到RAM中的" class="headerlink" title="问题3 ROM BIOS是什么时候映射到RAM中的"></a>问题3 ROM BIOS是什么时候映射到RAM中的</h4><p>ROM具有掉电不会丢失数据的特性，RAM具有访问速度快的特性。因此，在真正执行BIOS代码前，ROM中的一部分boot block已经被映射或者拷贝到了RAM中，执行复位向量后，跳转到RAM中执行。</p><p>那ROM BIOS是如何映射到RAM中的？这是在执行复位向量之前，CPU还有一些过程，还有内存控制器等，就已经将ROM BIOS映射过去了，过去是映射，现在大多是拷贝。具体的细节，我这里就不继续寻找了。</p><h4 id="问题4-RAM中留给system-bios的地址空间是64K，可是现在主板bios动辄2M，甚至4M，那么整个real-mode内存才1M，它怎么来寻址？"><a href="#问题4-RAM中留给system-bios的地址空间是64K，可是现在主板bios动辄2M，甚至4M，那么整个real-mode内存才1M，它怎么来寻址？" class="headerlink" title="问题4 RAM中留给system bios的地址空间是64K，可是现在主板bios动辄2M，甚至4M，那么整个real mode内存才1M，它怎么来寻址？"></a>问题4 RAM中留给system bios的地址空间是64K，可是现在主板bios动辄2M，甚至4M，那么整个real mode内存才1M，它怎么来寻址？</h4><p>BIOS起关键作用的只是一个block而已, 即boot block, 其他的块通过接近4G的高端地址访问就可以了。boot block是BIOS中一段特定区域，包含用于引导的最小指令集。</p><h2 id="MBR-bootloader"><a href="#MBR-bootloader" class="headerlink" title="MBR bootloader"></a>MBR bootloader</h2><p>由内存分布可知7C00h -7DFFh是MBR加载的区域，大小为512字节。</p><p>x86 体系的 PC 启动之后由 BIOS 完成自检，然后开始搜索外存上的引导信息，查找设备进行系统启动。</p><p>BIOS 会按照设定扫描不同的设备（硬盘，CD-ROM，Flash Drive，等等）并判断设备中是否可引导 (Bootable)。这个判断的方式通常是去 **查看设备的第一个 Sector 的最后两字节（即 511 和 512 字节）是否为<code>0x55 和 0xaa</code>（注意是低字节序 Little-Endian 还是高字节序 Big-Endian），是的话该设备就是可引导的。</p><p>当 BIOS 发现了可引导设备后，他就会把该可引导设备的 <strong>第一个 Sector 拷贝到 RAM 中的 <code>0x7c00</code></strong> （从 <code>0x7c00</code> 开始的 512 字节），并跳到 <code>0x7c00</code> 开始执行拷贝的程序。这一段程序通常被叫做 Bootloader。常见的 Boot Loader 有 grub、lilo、spfdisk。下图可以帮助大家理解 MBR 的结构。</p><p><img src="/wp-content/uploads/2023/06/image-1686190035119.png" alt="file"></p><h2 id="以GRUB为例MBR-bootloader"><a href="#以GRUB为例MBR-bootloader" class="headerlink" title="以GRUB为例MBR bootloader"></a>以GRUB为例MBR bootloader</h2><p>可以说GRUB 是bootloader中比较常用的，它本身可以看作一个小型操作系统，内置了简单的文件系统，可以读取分区， grub 启动之后首先就是加载它自己的一个简单的文件系统，然后读取自己的相关配置文件。</p><p>总体上GRUB更像是一个mini os，只不过这个mini os的作用只是加载其他的操作系统，在GRUB中包括stage1、stage1.5（可选）和stage2，其中stage1和stage1.5属于boot loader，stage2属于mini os的内核部分。</p><p>GRUB中stage1过程主要位于MBR的前446字节中（对于支持GPT分区的磁盘，同样有最开始的512字节作为保护MBR，保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，以此来表示这块硬盘使用GPT分区表，不能识别GPT硬盘的操作系统通常会识别出一个未知类型的分区，并且拒绝对硬盘进行操作），之后的64字节为硬盘的分区表，最后两个字节为MBR结束标志位（0xAA55）。</p><h3 id="grub-stage-1"><a href="#grub-stage-1" class="headerlink" title="grub stage 1"></a>grub stage 1</h3><p>主要作用：加载下一阶段代码。因为该扇区只有512B，功能单一。</p><p>其中stage1要被安装（也就是写入）某个硬盘的主引导记录，或者某个活动分区（这个分区要用fdisk标记成可启动的）的启动扇区。 stage1的主要的也是唯一的作用就是找到你存放在硬盘上某个地方的stage2文件，来完成后续的工作。</p><p>MBR中前 446个字节，如果把这里面的内容损坏，那么系统会认为当前磁盘没有启动引导功能,会尝试从光盘或者网络启动系统。</p><p>stage1部分占用了446字节，其代码文件是源码目录下stage1&#x2F;stage1.S文件，汇编后生成一个512字节的boot.img，被写在硬盘的0面0道1扇区中，作为硬盘的MBR。stage1的工作很简单，就是加载<strong>0面0道2扇区</strong>上的512字节到0x8000，然后跳转到0x8000执行。在0面0道2扇区上的512字节内容为<code>stage1/start.S</code>文件汇编后生成。该扇区上的内容的作用是加载stage1.5或是stage2过程，并将控制权转交。</p><h3 id="问题汇总-1"><a href="#问题汇总-1" class="headerlink" title="问题汇总"></a>问题汇总</h3><h4 id="1-为什么需要grub-1-5"><a href="#1-为什么需要grub-1-5" class="headerlink" title="1 为什么需要grub 1.5"></a>1 为什么需要grub 1.5</h4><p>因为stage1的容量有限（主引导记录MBR和启动扇区的大小只能够是512字节），所以它对文件系统是无法识别的，那如果你把 stage2存放在ext2或者fat格式的文件系统上，它如何来找到这个文件呢？这就要用到上面提到的那些stage1_5的文件了，它们负责解释文件系统。你的stage2放在什么格式的文件系统上，就要调用对应的那个stage1_5文件。比如，你把stage2存放在ext2格式的文件系统上，就 需要e2fs_stage1_5；stage2存放在fat格式的文件系统上，就需要fat_stage1_5了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>grub被分为三个阶段</p><ul><li><p>stage1：由于只有512字节，它的功能就是加载stage1.5然后转移控制权</p></li><li><p>stage1.5：stage1.5通常是之后的n个扇区，大小通常是10几k到几十k这么大。当然这样也只能装一种类型的文件系统，所以stage1.5就很多种，分别对应不同的文件系统，在grub安装时按需装入。识别出文件系统后，找到文件系统中的stage2的core.img加载，并移交控制权。</p></li><li><p>stage2：真正干活的，读取配置文件grub.cfg并生成启动菜单，根据用户选择的操作系统，加载内核并转移权限。</p><h3 id="grub-stage-1-5"><a href="#grub-stage-1-5" class="headerlink" title="grub stage 1.5"></a>grub stage 1.5</h3></li></ul><p>主要作用：加载文件系统。</p><p>在stage1过程将控制权转交后，接下来就是GRUB的核心过程了。该过程之所以区分stage1.5和stage2，主要原因是GRUB和GRUB2的区别。在GRUB2中，将stage1.5过程集成到了stage2的过程中，所以stage1.5过程仅仅是针对GRUB的。下面将介绍GRUB。</p><p>Stage1.5过程很无辜，它的作用很单一，但是非常关键。<strong>它的主要功用就是构造一个boot分区系统对应的文件系统</strong>，这样可以通过文件系统的路径（&#x2F;boot&#x2F;grub&#x2F;）寻找stage2过程需要的core.img，进而加载到内存中开始执行。</p><p>Stage1.5存在于<strong>0面0道3扇区开始的地方</strong>，并一直延续十几k字节的区域，具体的大小与相应的文件系统的大小有关（文中涉及到了0面0道1-3+x扇区，这部分扇区为保留扇区，BIOS不会放置任何数据。正因为如此如果转换到GPT分区形式，系统将不能被正确引导，MBR后面的扇区都被其他内容所占据）。e2fs_stage1_5（针对ext2fs，可引导ext2和ext3文件系统）、fat_stage1_5（针对fat文件系统，可引导fat32和fat16）、ffs_stage1_5、jfs_stage1_5、minix_stage1_5、reiserfs_stage1_5、vstafs_stage1_5和xfs_stage1_5，这些文件被称为stage1.5过程，这些文件每个至少都在11k以上。除此之外还有两个比较特殊的文件，分别为nbgrub和pxegrub，这两个文件主要是在网络引导时使用，只是格式不同而已，他们很类似与stage2，只是需要建立网络来获取配置文件。</p><h3 id="grub-stage-2"><a href="#grub-stage-2" class="headerlink" title="grub stage 2"></a>grub stage 2</h3><p>主要作用：bootloader核心，在文件系统建立以后选择合适的操作系统进行加载并转交控制权，达到最后引导操作系统的目标。</p><p>由于GRUB属于multi boot loader，因此在引导的时候要进行选择，选择哪种操作系统来运行。在GRUB内部主要包括两种方式，首先是从grub. cfg中读取显示到屏幕让用户选择，其次是通过grub-shell中定义的命令手动进行启动。通常，只要我们看到内核的启动菜单,表示已经成功的进入了grub的stage 2阶段,因为启动菜单是在stage 2 生成的。</p><h2 id="OS-Kernel加载"><a href="#OS-Kernel加载" class="headerlink" title="OS Kernel加载"></a>OS Kernel加载</h2><p>Bootloader 会寻找操作系统内核所在分区，找到将其加载进入内存RAM，然后跳转到开始的程序开始的位置。至于拷贝多少扇区，跳转到哪里执行？这个就不像 <code>0x7c00</code> 这个数那么经典了，<strong>不同的操作系统肯定也不一样</strong>，也不用事先规定好，反正写操作系统的人给自己定一个就好了，别覆盖其他关键设备用到的区域就好。</p><blockquote><p>以grub为例，加载哪个操作系统，到哪个位置，不是明文规定的。</p></blockquote><p>在一些早期的PC系统中，操作系统内核确实是被加载到物理内存地址 <code>0x100000</code>（也称为1MB）开始启动的。这是因为在这些系统中，BIOS中断13h的读取扇区的函数所支持的最大扇区数是256个，每个扇区的大小为512字节，因此最大支持的读取大小为128KB（256 * 512）。因此，为了尽可能地利用可用的内存空间，并避免与其他系统组件冲突，操作系统内核通常被加载到物理内存 <code>0x100000</code> 开始的位置上。</p><p>一个从0x100000加载的系统内存图如下：</p><p>开始从 RAM 中的 <code>0x100000</code> 加载系统内核。在这个过程中，Bootloader 或者是操作系统本身会把 CPU 的运行模式从 <strong>实模式</strong> 切换到 <strong>保护模式</strong> 。于是我们的操作系统就被启动了。</p><blockquote><p>当然，这里省略了很多细节</p></blockquote><p><img src="/wp-content/uploads/2023/06/image-1686190090706.png" alt="file"></p><p>但是，随着计算机硬件的不断发展，现代计算机通常有更大的物理内存和更高的处理能力，因此操作系统内核的加载和启动方式也随之发生了变化。例如，在64位x86架构的计算机上，操作系统内核通常是被加载到更高的物理内存地址上，例如 <code>0x1000000</code>（也称为16MB）或更高的位置，放在哪儿，取决于内核开发人员。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.cnblogs.com/liuzhenbo/p/10806119.html">GRUB&amp;MBR引导 - 心田居士 - 博客园 (cnblogs.com)</a></li><li><a href="http://chuquan.me/2016/12/14/computer-boot-process/">计算机那些事(2)——开机启动过程 楚权的世界 (chuquan.me)</a></li><li><a href="https://www.longtao.fun/metaverse/bootofcomputer/">计算机启动到操作系统运行 LongTao</a></li><li><a href="https://learningos.github.io/ucore_os_webdocs/lab1/lab1_3_1_bios_booting.html">BIOS 启动过程 · GitBook (learningos.github.io)</a></li><li><a href="https://soptq.me/2020/07/22/os-boot/">“当按下电源后，x86 CPU 的 OS 是如何被启动的？” - Soptlog Soptq’s Blog</a></li><li><a href="https://jcf94.com/2015/08/19/2015-08-19-biosinit/">BIOS 内核载入的方式（引导实验） Chenfan Blog (jcf94.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/324210723">x86段寄存器和分段机制 - 知乎 (zhihu.com)</a></li><li><a href="https://bbs.csdn.net/topics/90489738">请教，cpu加电执行的第一句代码，究竟是从bios中执行，还是从内存中执行？-CSDN社区</a></li><li><a href="https://blog.csdn.net/mshxuyi/article/details/100610074">(32条消息) CentOS 7 编译安装 nbd 模块_modprobe nbd_tom.ma的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/zerfew/article/details/86981408">(32条消息) *** No rule to make target ‘tools&#x2F;objtool&#x2F;objtool’_zerfew的博客-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/100746398#:~:text=Stage2%EF%BC%9AG,ernel%E7%A8%8B%E5%BA%8F%E3%80%82">详解Linux开机流程：BIOS-&gt;MBR-&gt;GRUB-&gt;等等。。。 - 知乎 (zhihu.com)</a></li><li><a href="https://wiki.osdev.org/Memory_Map_(x86)">Memory Map (x86) - OSDev Wiki</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>BIOS</tag>
      
      <tag>计算机启动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wordpress出现致命错误，如何调试找到原因</title>
    <link href="/0025.html"/>
    <url>/0025.html</url>
    
    <content type="html"><![CDATA[<p>1 打开vim wp-config.php</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注释掉原有的语句，添加三条语句</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define( <span class="hljs-string">&#x27;WP_DEBUG&#x27;</span>, <span class="hljs-literal">false</span> );</span><br>define(&#x27;WP_DEBUG&#x27;, true);<br>define(&#x27;WP_DEBUG_DISPLAY&#x27;, false);<br>define(&#x27;WP_DEBUG_LOG&#x27;, true);<br></code></pre></td></tr></table></figure><p>2 保存并退出，重启nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart nginx<br></code></pre></td></tr></table></figure><p>3 这样就可以在.&#x2F;wp-content&#x2F;目录下看到调试文件debug.log</p><p>4 找到原因后，记得取消调试日志。</p>]]></content>
    
    
    <categories>
      
      <category>wordpress使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查看真实的qcow2镜像中二进制数据-以MBR为例</title>
    <link href="/0022.html"/>
    <url>/0022.html</url>
    
    <content type="html"><![CDATA[<h2 id="查看真实的qcow2镜像中二进制数据："><a href="#查看真实的qcow2镜像中二进制数据：" class="headerlink" title="查看真实的qcow2镜像中二进制数据："></a>查看真实的qcow2镜像中二进制数据：</h2><p>问题：如何查看qcow2镜像的MBR中的Bootloader代码？使用qemu-nbd工具，这个一般安装了qemu之后都有的。</p><h3 id="1-安装nbd模块"><a href="#1-安装nbd模块" class="headerlink" title="1 安装nbd模块"></a>1 安装nbd模块</h3><p>0、nbd模块未安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@qemuswtpmsm4 ~]# sudo modprobe nbd max_part=8<br>modprobe: FATAL: Module nbd not found.<br></code></pre></td></tr></table></figure><p>1、查看Linux版本以及内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@qemuswtpmsm4 ~]# cat /etc/redhat-release<br>CentOS Linux release 7.9.2009 (Core)<br>[root@qemuswtpmsm4 ~]# uname -r<br>3.10.0-1160.el7.x86_64<br></code></pre></td></tr></table></figure><p>2、安装相关包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install kernel-devel kernel-headers elfutils-libelf-devel　gcc+ gcc-c++<br></code></pre></td></tr></table></figure><p>3、下载对应的内核包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">https://vault.centos.org/7.9.2009/os/Source/SPackages/kernel-3.10.0-1160.el7.src.rpm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">根据自己的系统版本去下载</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">7.9.2009 　为redhat-release　系统版本</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">3.10.0-1160.el7.x86_64　　为<span class="hljs-built_in">uname</span> -r  内核信息</span><br></code></pre></td></tr></table></figure><p>4、解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"> rpm -ivh kernel-3.10.0-1160.el7.src.rpm<br><br> find / grep rpmbuild<br> cd /root/rpmbuild/SOURCES<br> tar -xvf linux-3.10.0-1160.el7.tar.xz -C /usr/src/kernels/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"> #</span><span class="language-bash">解压后文件：/usr/src/kernels/</span><br> ll /usr/src/kernels/<br>drwxr-xr-x. 22 root root 4096 May 30 18:20 3.10.0-1160.90.1.el7.x86_64<br>drwxr-xr-x. 22 root root 4096 May 30 18:20 3.10.0-1160.el7.x86_64<br>drwxrwxr-x. 24 root root 4096 May 30 18:30 linux-3.10.0-1160.el7<br></code></pre></td></tr></table></figure><p>5、编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/src/kernels/linux-3.10.0-1160.el7/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除所有编译生成文件，内核配置文件</span><br>make mrproper<br><br>cp /usr/src/kernels/3.10.0-1160.90.1.el7.x86_64/Module.symvers ./<br><br>cp /boot/config-3.10.0-1160.el7.x86_64 ./.config<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份当前.config文件为.config.old</span><br>make oldconfig<br><br>make prepare<br><br>make scripts<br></code></pre></td></tr></table></figure><p>6、编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make CONFIG_BLK_DEV_NBD=m M=drivers/block <br></code></pre></td></tr></table></figure><p><strong>错误</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">drivers/block/nbd.c: 在函数‘__nbd_ioctl’中:<br>drivers/block/nbd.c:619:19: 错误：‘REQ_TYPE_SPECIAL’未声明(在此函数内第一次使用)<br>   sreq.cmd_type = REQ_TYPE_SPECIAL;<br>                   ^<br>drivers/block/nbd.c:619:19: 附注：每个未声明的标识符在其出现的函数内只报告一次<br>make[1]: *** [drivers/block/nbd.o] 错误 1<br>make: *** [_module_drivers/block] 错误 2<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim drivers/block/nbd.c<br><br>//sreq.cmd_type = REQ_TYPE_SPECIAL;<br>sreq.cmd_type = 7;　　#修改为7<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">重新执行一次</span><br>make CONFIG_BLK_DEV_NBD=m M=drivers/block<br></code></pre></td></tr></table></figure><p><strong>报错</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">No rule to make target &#x27;tools/objtool/objtool&#x27;<br></code></pre></td></tr></table></figure><p>原因：缺少参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加参数后执行</span><br>make CONFIG_BLK_DEV_NBD=m M=drivers/block CONFIG_STACK_VALIDATION=<br></code></pre></td></tr></table></figure><p>7、复制编译好的内核模块文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp drivers/block/nbd.ko /lib/modules/3.10.0-1160.el7.x86_64/kernel/drivers/block/<br>depmod -a #生成 modules.dep 和映射文件<br></code></pre></td></tr></table></figure><p>8、验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@qemuswtpmsm4 ~]# modinfo nbd<br>filename:       /lib/modules/3.10.0-1160.el7.x86_64/kernel/drivers/block/nbd.ko<br>license:        GPL<br>description:    Network Block Device<br>retpoline:      Y<br>rhelversion:    7.9<br>srcversion:     EDE909A294AC5FE08E81957<br>depends:<br>vermagic:       3.10.0 SMP mod_unload modversions<br>parm:           nbds_max:number of network block devices to initialize (default: 16) (int)<br>parm:           max_part:number of partitions per device (default: 0) (int)<br>parm:           debugflags:flags for controlling debug output (int)<br></code></pre></td></tr></table></figure><h3 id="2-挂载qcow2镜像为块设备"><a href="#2-挂载qcow2镜像为块设备" class="headerlink" title="2 挂载qcow2镜像为块设备"></a>2 挂载qcow2镜像为块设备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo modprobe nbd max_part=8 #Linux 内核模块 nbd 并设置网络块设备（Network Block Device，即 NBD）最大分区数为 8 。<br>qemu-nbd -c /dev/nbd0 &lt;qcow2_filename&gt;<br></code></pre></td></tr></table></figure><p>执行以上命令后，<code>qcow2</code> 镜像文件就会被挂载为 <code>/dev/nbd0</code> 块设备。</p><h3 id="3-使用hexdump等工具查看块设备内容"><a href="#3-使用hexdump等工具查看块设备内容" class="headerlink" title="3 使用hexdump等工具查看块设备内容"></a>3 使用hexdump等工具查看块设备内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo hexdump -C /dev/nbd0  less<br></code></pre></td></tr></table></figure><p>该命令会将 <code>/dev/nbd0</code> 块设备的内容以十六进制形式输出，并使用 <code>less</code> 工具进行分页显示。 查看MBR代码：512字节</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexdump -n 512 -e &#x27;16/1 &quot;%02x &quot; &quot;\n&quot;&#x27; /dev/nbd0<br></code></pre></td></tr></table></figure><p>该命令作用是将 <code>/dev/nbd0</code> 设备的前 512 个字节以十六进制格式输出。其中<code>-n 512</code> 选项表示只转储前 512 个字节。<code>-e</code> 选项用于指定输出格式，<code>16/1 &quot;%02x &quot;</code> 表示每行输出 16 个字节，每个字节使用两位十六进制表示，并在字节之间添加一个空格。最后的 <code>&quot;\n&quot;</code> 表示在每行的结尾添加一个换行符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@qemuswtpmsm4 lyy]#  hexdump -n 512 -e &#x27;16/1 &quot;%02x &quot; &quot;\n&quot;&#x27; /dev/nbd0<br>eb 63 90 10 8e d0 bc 00 b0 b8 00 00 8e d8 8e c0<br>fb be 00 7c bf 00 06 b9 00 02 f3 a4 ea 21 06 00<br>00 be be 07 38 04 75 0b 83 c6 10 81 fe fe 07 75<br>....<br>29 82 8e fe ff ff 00 08 20 00 00 f8 5f 02 00 00<br>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa<br></code></pre></td></tr></table></figure><h3 id="4-卸载-dev-nbd0块设备"><a href="#4-卸载-dev-nbd0块设备" class="headerlink" title="4 卸载&#x2F;dev&#x2F;nbd0块设备"></a>4 卸载&#x2F;dev&#x2F;nbd0块设备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo qemu-nbd -d /dev/nbd0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MBR</tag>
      
      <tag>nbd模块</tag>
      
      <tag>qcow2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux判断文件类型以及查看ELF文件结构</title>
    <link href="/0030.html"/>
    <url>/0030.html</url>
    
    <content type="html"><![CDATA[<h2 id="判断文件类型"><a href="#判断文件类型" class="headerlink" title="判断文件类型"></a>判断文件类型</h2><p>1、对于一个二进制文件：file可能会输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@qemuswtpmsm4 seabios-tpm]# file /usr/bin/file<br>/usr/bin/file: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=58f6c8b82ee70887d7136a7181ffc8fa18030cde, stripped<br></code></pre></td></tr></table></figure><p>其中，<code>/usr/bin/file</code> 是文件名，<code>ELF 64-bit LSB executable</code> 表示文件类型为 ELF 64 位可执行文件。</p><p>2、对于一个文本文件它的结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@qemuswtpmsm4 seabios-tpm]# file test.txt<br>test.txt: ASCII text<br></code></pre></td></tr></table></figure><p>3、对于一个图片文件，他的结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@qemuswtpmsm4 ~]# file f1c2c7d2f335ce7a67f315433a53e0fec9997bdd.jpg<br>f1c2c7d2f335ce7a67f315433a53e0fec9997bdd.jpg: JPEG image data, JFIF standard 1.01<br></code></pre></td></tr></table></figure><p>可以看出他是jpg格式的文件。</p><p>4、于是，可以使用 file命令：查看seabios编译后产生的bios.bin文件的类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@qemuswtpmsm4 seabios-tpm]# file out/bios.bin<br>out/bios.bin: data<br></code></pre></td></tr></table></figure><p>根据 <code>file</code> 命令的输出结果 <code>out/bios.bin: data</code>，可以看出 <code>out/bios.bin</code> 文件的类型为 data，即数据文件。这意味着 <code>file</code> 命令无法确定该文件的具体类型，因为该文件不属于任何已知的文件类型。</p><h2 id="elf文件"><a href="#elf文件" class="headerlink" title="elf文件"></a>elf文件</h2><p>ELF（Executable and Linkable Format）是一种<strong>可执行文件</strong>和<strong>可链接文件</strong>的文件格式标准，常用于 Unix 和 Linux 等操作系统上的可执行文件和库文件。ELF 文件具有可移植性、可扩展性和安全性等优点，已经成为主流的可执行文件和库文件格式之一。</p><p>ELF主要包括三种类型文件：</p><ul><li><code>可重定位文件(relocatable)</code>：编译器和汇编器产生的.o文件，被Linker所处理</li><li><code>可执行文件(executable)</code>：Linker对.o文件进行处理输出的文件，进程映像</li><li><code>共享对象文件(shared object)</code>：动态库文件.so</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">include &amp;lt;stdio.h&amp;gt;</span><br><br>int add(int a,int  b)<br>&#123;<br>    printf(&amp;quot;Number are added together\n&amp;quot;);<br>    return a + b;<br>&#125;<br><br>int main()<br>&#123;<br>    int a,b;<br>    a = 3;<br>    b = 4;<br>    int ret = add(a,b);<br>    printf(&amp;quot;Result:%u\n&amp;quot;,ret);<br>    exit(0);<br>&#125;<br><br>gcc test.c -o test #生成可执行文件<br>gcc test.c -c -o test.o # -c参数表示“生成目标文件，不生成可执行文件”，此时只编译了，未链接<br></code></pre></td></tr></table></figure><p>查看一个可重定位文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@qemuswtpmsm4 ~]# file test.o<br>test.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped<br></code></pre></td></tr></table></figure><p>查看可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@qemuswtpmsm4 ~]# file /usr/bin/file<br>/usr/bin/file: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=58f6c8b82ee70887d7136a7181ffc8fa18030cde, stripped<br></code></pre></td></tr></table></figure><p>使用file命令查看一个库文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@qemuswtpmsm4 ~]# file /usr/lib64/libgdbm.so.4.0.0<br>/usr/lib64/libgdbm.so.4.0.0: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=8883331bdb71df9fbd10305b90f89a8f830ea182, stripped<br></code></pre></td></tr></table></figure><h3 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h3><p>一个典型的ELF文件布局如下：</p><p><img src="/wp-content/uploads/2023/05/image-griq.png" alt="1E586701BB476D23DB08C85919910967"></p><p>它包含：</p><ul><li>一个ELF文件头（ELF Header）：该文件头，始终从文件偏移量0处开始，其定义了文件使用32位还是64位地址，以及程序头表和节头表的偏移量等。</li><li>一个程序头表（Program Header Table）：是一组数据结构，规定了系统运行时如何创建进程镜像，每一个数据结构描述了系统准备执行程序所需要的段（Segment）或其他信息，仅针对的是可执行文件或者可重定位目标文件。</li><li>一个节头表（Section Header Table）：定义了文件的所有节（Section）的位置，记录了二进制文件中每个节到文件起始位置的字节偏移量。</li></ul><p>文件格式定义的所有数据结构有可能包含显示填充，以确保对象的4字节对齐，强制要求数据结构大小为4的倍数。</p><h3 id="查看elf文件内容"><a href="#查看elf文件内容" class="headerlink" title="查看elf文件内容"></a>查看elf文件内容</h3><p>1、使用readelf工具（也可以使用objdump，这里就不说了）查看ELF文件头：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@qemuswtpmsm4 ~]# readelf -h test<br>ELF Header:<br>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 #ELF 文件的魔数，用于标识该文件是否为 ELF 格式文件。<br>  Class:                             ELF64 <br>  Data:                              2&amp;#039;s complement, little endian #ELF 文件的字节序，这里是小端字节序。<br>  Version:                           1 (current)<br>  OS/ABI:                            UNIX - System V #ELF 文件所运行的操作系统和 ABI，这里是 UNIX - System V。<br>  ABI Version:                       0<br>  Type:                              EXEC (Executable file)<br>  Machine:                           Advanced Micro Devices X86-64 #ELF 文件所运行的 CPU 架构，这里是 AMD X86-64。<br>  Version:                           0x1<br>  Entry point address:               0x4004d0<br>  Start of program headers:          64 (bytes into file) #程序头表的起始位置，即程序头表相对于文件开头的偏移量，这里是 64 字节。<br>  Start of section headers:          6568 (bytes into file) #节头表的起始位置，即节头表相对于文件开头的偏移量，这里是 6568 字节。<br>  Flags:                             0x0<br>  Size of this header:               64 (bytes) #ELF 头部的大小，这里是 64 字节。<br>  Size of program headers:           56 (bytes) #程序头表中程序头的大小，这里是 56 字节。<br>  Number of program headers:         9 #程序头表中程序头的数量，这里是 9。<br>  Size of section headers:           64 (bytes) #节头表中单个节头的大小，这里是 64 字节。<br>  Number of section headers:         30 # 节头数量<br>  Section header string table index: 29 # 节头表中 “节区名称字符串表” 的索引。<br></code></pre></td></tr></table></figure><p>由此可见，这个 ELF 头部信息描述了一个 64 位小端字节序的可执行文件，该文件是一个 AMD X86-64 架构的可执行文件，程序入口地址是 0x4004d0，包含了 9 个程序头部和 30 个节区头部，其中第 29 个节区是节区名称字符串表。该可执行文件的程序头部表起始位置相对于文件开头的偏移量是 64 字节，节区头部表的起始位置相对于文件开头的偏移量是 6568 字节。</p><p>使用hexdump查看test字节码，可以看到文件头部对应。</p><p><img src="/wp-content/uploads/2023/05/image-oxhv.png" alt="image-20230525103558082"></p><p>上图中，字节码0x19a8&#x3D;6568，代表节头表起始位置，最后的0x001d&#x3D;29，代表节头表中“节区名称字符串表” 的索引。依次对应。</p><p>2、查看程序头表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@qemuswtpmsm4 ~]# readelf -l test -W<br><br>Elf file type is EXEC (Executable file)<br>Entry point 0x4004d0<br>There are 9 program headers, starting at offset 64<br><br>Program Headers:<br>  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align<br>  PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x0001f8 0x0001f8 R E 0x8<br>  INTERP         0x000238 0x0000000000400238 0x0000000000400238 0x00001c 0x00001c R   0x1<br>      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]<br>  LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x00083c 0x00083c R E 0x200000<br>  LOAD           0x000e10 0x0000000000600e10 0x0000000000600e10 0x000234 0x000238 RW  0x200000<br>  DYNAMIC        0x000e28 0x0000000000600e28 0x0000000000600e28 0x0001d0 0x0001d0 RW  0x8<br>  NOTE           0x000254 0x0000000000400254 0x0000000000400254 0x000044 0x000044 R   0x4<br>  GNU_EH_FRAME   0x0006e8 0x00000000004006e8 0x00000000004006e8 0x00003c 0x00003c R   0x4<br>  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10<br>  GNU_RELRO      0x000e10 0x0000000000600e10 0x0000000000600e10 0x0001f0 0x0001f0 R   0x1<br><br> Section to Segment mapping:<br>  Segment Sections...<br>   00<br>   01     .interp<br>   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame<br>   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss<br>   04     .dynamic<br>   05     .note.ABI-tag .note.gnu.build-id<br>   06     .eh_frame_hdr<br>   07<br>   08     .init_array .fini_array .jcr .dynamic .got<br></code></pre></td></tr></table></figure><p>这是一个 ELF 可执行文件或共享库的程序头部表中各个字段的含义：</p><ul><li><code>Type</code>：程序头部类型，描述了该程序头部的用途和内容，如 ELF 文件头部、代码段、数据段等等。常见的程序头部类型包括：<code>PHDR</code>（程序头部表）、<code>LOAD</code>（可加载的段）、<code>DYNAMIC</code>（动态链接信息段）等等。</li><li><code>Offset</code>：该程序头部在 ELF 文件中的偏移量，即该程序头部相对于 ELF 文件开头的字节偏移量。</li><li><code>VirtAddr</code>：该程序头部的虚拟地址，即该程序头部在被加载到内存中时在进程虚拟地址空间中的地址。</li><li><code>PhysAddr</code>：该程序头部的物理地址，即该程序头部在被加载到内存中时在物理地址空间中的地址（对于可执行文件，通常与虚拟地址相同）。</li><li><code>FileSiz</code>：该程序头部在 ELF 文件中的大小，即该程序头部占用的字节数。</li><li><code>MemSiz</code>：该程序头部在内存中的大小，即该程序头部被加载到内存中后占用的字节数，通常大于或等于 <code>FileSiz</code>。</li><li><code>Flg</code>：该程序头部的标志位，用于描述该程序头部的属性和特征，如可执行、可写、可读等等。</li><li><code>Align</code>：该程序头部的对齐方式，即该程序头部在 ELF 文件中和内存中的起始地址要按照多少字节对齐。</li></ul><p>以下是该 ELF 可执行文件或共享库的各个程序头部的含义：</p><ul><li><code>PHDR</code>：程序头部表，描述 ELF 文件中所有程序头部的位置和大小信息。</li><li><code>INTERP</code>：动态链接器路径，描述 ELF 文件使用的动态链接器路径。</li><li><code>LOAD</code>：可加载的段，描述 ELF 文件中可加载的代码和数据段信息。该可执行文件中包含两个 <code>LOAD</code> 类型的程序头部，分别对应代码段和数据段，<code>FileSiz</code> 和 <code>MemSiz</code> 字段的值相同，代表在 ELF 文件中和内存中占用的空间大小相同。</li><li><code>DYNAMIC</code>：动态链接信息段，描述 ELF 文件中动态链接器需要读取的信息，如动态链接表、符号表等信息。</li><li><code>NOTE</code>：注释段，描述 ELF 文件中的注释信息。</li><li><code>GNU_EH_FRAME</code>：GCC 增强型异常处理框架，描述 ELF 文件中的异常处理框架信息。</li><li><code>GNU_STACK</code>：栈段，描述 ELF 文件中栈的起始地址和大小。</li><li><code>GNU_RELRO</code>：重定位只读段，描述 ELF 文件中只读数据段的重定位信息。</li></ul><p>我们分析这个ELF文件中的代码段和数据段就是<code>LOAD</code>这个类型指示的，其中代码段是只读可执行的：如下图所示，</p><p><img src="/wp-content/uploads/2023/05/image-gzvp.png" alt="image-20230524170802954"></p><p>该文件代码段起始与ELF的0x000000，大小位0x00083c，标志E代表可执行。</p><p>改代码段包含以下节：</p><p><img src="/wp-content/uploads/2023/05/image-lusc.png" alt="image-20230524170923512"></p><p>分别是：.interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件系统</tag>
      
      <tag>elf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openstack- DiskNotFound No disk at</title>
    <link href="/043.html"/>
    <url>/043.html</url>
    
    <content type="html"><![CDATA[<h2 id="openstack-DiskNotFound-No-disk-at-var-lib-nova-instances-b83ded98-6e32-4c2e-ac07-764648400e74-disk"><a href="#openstack-DiskNotFound-No-disk-at-var-lib-nova-instances-b83ded98-6e32-4c2e-ac07-764648400e74-disk" class="headerlink" title="openstack- DiskNotFound No disk at &#x2F;var&#x2F;lib&#x2F;nova&#x2F;instances&#x2F;b83ded98-6e32-4c2e-ac07-764648400e74&#x2F;disk"></a>openstack- DiskNotFound No disk at &#x2F;var&#x2F;lib&#x2F;nova&#x2F;instances&#x2F;b83ded98-6e32-4c2e-ac07-764648400e74&#x2F;disk</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">2023-03-31 01:35:58.938 49205 ERROR nova.compute.manager [req-aa6f500a-b8e7-420c-bb85-80244be2bc03 - - - - -] <br>Error updating resources for node compute1.: DiskNotFound: No disk at /var/lib/nova/instances/b83ded98-6e32-4c2e-ac07-764648400e74/diskn2023-03-31 01:34:57.974 49205 <br>ERROR nova.compute.manager     dk_size = disk_api.get_allocated_disk_size(path)n2023-03-31 01:34:57.974 49205 ERROR nova.compute.manager   File &quot;/usr/lib/python2.7/site-packages/nova/virt/disk/api.py&quot;, line 156, in get_allocated_disk_sizen2023-03-31 01:34:57.974 49205 <br>ERROR nova.compute.manager     return images.qemu_img_info(path).disk_sizen2023-03-31 01:34:57.974 49205 ERROR nova.compute.manager   File &quot;/usr/lib/python2.7/site-packages/nova/virt/images.py&quot;, line 57, in qemu_img_infon2023-03-31 01:34:57.974 49205 ERROR nova.compute.manager     raise exception.DiskNotFound(location=path)n2023-03-31 01:34:57.974 49205 <br>ERROR nova.compute.manager DiskNotFound: No disk at /var/lib/nova/instances/b83ded98-6e32-4c2e-ac07-764648400e74/disk<br></code></pre></td></tr></table></figure><p>解决办法：直接删除&#x2F;etc&#x2F;libvirt&#x2F;qemu&#x2F;*.xml，删除不存在虚拟机</p>]]></content>
    
    
    <categories>
      
      <category>OpenStack</category>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openstack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openstack libvirt报错</title>
    <link href="/044.html"/>
    <url>/044.html</url>
    
    <content type="html"><![CDATA[<h1 id="openstack-libvirt报错"><a href="#openstack-libvirt报错" class="headerlink" title="openstack libvirt报错"></a>openstack libvirt报错</h1><p>报错内容： error : virPidFileAcquirePath:422 : Failed to acquire pid file ‘&#x2F;run&#x2F;user&#x2F;1000&#x2F;libvirt&#x2F;libvirtd.pid’: Resource temporarily unavailable 解决办法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef  grep libvirtd<br>mv /var/run/libvirtd.pid /var/run/libvirtd.pid.old<br>systemctl stop libvirtd.service<br>systemctl start libvirtd.service<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OpenStack</category>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openstack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux获取系统调用信息</title>
    <link href="/036.html"/>
    <url>/036.html</url>
    
    <content type="html"><![CDATA[<h1 id="Linux获取系统调用信息"><a href="#Linux获取系统调用信息" class="headerlink" title="Linux获取系统调用信息"></a>Linux获取系统调用信息</h1><p>获取系统调用信息方式很多，下面是比较简单的几种方式，可以直观的查看每个进程的系统调用数据。</p><h2 id="1-sysdig"><a href="#1-sysdig" class="headerlink" title="1 sysdig"></a>1 sysdig</h2><h3 id="抓取系统调用"><a href="#抓取系统调用" class="headerlink" title="抓取系统调用"></a>抓取系统调用</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 每一分钟采集一个文件，会保留5个采集文件，采集的是系统全部数据</span><br><span class="hljs-attribute">sysdig</span> -G <span class="hljs-number">60</span> -W <span class="hljs-number">5</span> -w dump_0323.scap <br><span class="hljs-comment"># 采集某个容器的系统调用：jolly_gates是容器名称，-w指定文件n sysdig container.name=jolly_gates -w dump_0323_19.scapn </span><br></code></pre></td></tr></table></figure><h3 id="读取抓取的系统调用数据"><a href="#读取抓取的系统调用数据" class="headerlink" title="读取抓取的系统调用数据"></a>读取抓取的系统调用数据</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"> # 读取数据，<span class="hljs-keyword">grep</span> -v反选<br>sysdig -r dump_0323_19.scap  <span class="hljs-keyword">grep</span> -v tail  <span class="hljs-keyword">grep</span> -v mysqld<br></code></pre></td></tr></table></figure><h2 id="2-strace"><a href="#2-strace" class="headerlink" title="2 strace"></a>2 strace</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-comment"># strace指定进程-p， -o指定文件</span><br><span class="hljs-attribute">strace</span> -p PID -o <span class="hljs-number">1</span>.txt<br></code></pre></td></tr></table></figure><h2 id="3-系统trace-debug"><a href="#3-系统trace-debug" class="headerlink" title="3 系统trace debug"></a>3 系统trace debug</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /sys/kernel/debug/tracing/<br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>linux3.10:</p><p><img src="/wp-content/uploads/2023/05/image-qghb.png"></p><p>linux4.18:</p><p><img src="/wp-content/uploads/2023/05/image-uemj.png">这里面的envents文件代表可以监控的类型，包括tcp、kvm、系统调用等</p><p><img src="/wp-content/uploads/2023/05/image-puir.png">该目录下及其子目录下都有一个enable文件，只需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"> <span class="hljs-built_in">echo</span> 1 &gt; <span class="hljs-built_in">enable</span><br></code></pre></td></tr></table></figure><p>在完成相应操作后。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"> <span class="hljs-built_in">echo</span> 0 &gt; <span class="hljs-built_in">enable</span><br></code></pre></td></tr></table></figure><p>这时可以在**&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;trace**文件中查看到采集的数据。</p><p>而该目录下的set_envent_pid文件中，可以放入特定进程号，这样就可以只抓特定进程的数据。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7.9更换软件源</title>
    <link href="/029.html"/>
    <url>/029.html</url>
    
    <content type="html"><![CDATA[<h1 id="CentOS7-9更换软件源"><a href="#CentOS7-9更换软件源" class="headerlink" title="CentOS7.9更换软件源"></a>CentOS7.9更换软件源</h1><p>推荐：清华源：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/centos/?repo=centos7">centos 镜像站使用帮助 清华大学开源软件镜像站 Tsinghua Open Source Mirror</a> 阿里的那个源，你下之后各种问题，如果你不是阿里云用户有问题，http也有问题，不想折腾直接用清华源。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak<br>vi /etc/yum.repos.d/CentOS-Base.repo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">CentOS-Base.repo</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># The mirror system uses the connecting IP address of the client and the</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">update status of each mirror to pick mirrors that are updated to and</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">geographically close to the client.  You should use this <span class="hljs-keyword">for</span> CentOS updates</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">unless you are manually picking other mirrors.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># If the mirrorlist= does not work for you, as a fall back you can try the</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">remarked out baseurl= line instead.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment">#</span></span><br><br>[base]<br>name=CentOS-$releasever - Base<br>baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/<br><span class="hljs-meta prompt_">#</span><span class="language-bash">mirrorlist=http://mirrorlist.centos.org/?release=<span class="hljs-variable">$releasever</span>&amp;<span class="hljs-built_in">arch</span>=<span class="hljs-variable">$basearch</span>&amp;repo=os</span><br>gpgcheck=1<br>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">released updates</span><br>[updates]<br>name=CentOS-$releasever - Updates<br>baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/updates/$basearch/<br><span class="hljs-meta prompt_">#</span><span class="language-bash">mirrorlist=http://mirrorlist.centos.org/?release=<span class="hljs-variable">$releasever</span>&amp;<span class="hljs-built_in">arch</span>=<span class="hljs-variable">$basearch</span>&amp;repo=updates</span><br>gpgcheck=1<br>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">additional packages that may be useful</span><br>[extras]<br>name=CentOS-$releasever - Extras<br>baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/<br><span class="hljs-meta prompt_">#</span><span class="language-bash">mirrorlist=http://mirrorlist.centos.org/?release=<span class="hljs-variable">$releasever</span>&amp;<span class="hljs-built_in">arch</span>=<span class="hljs-variable">$basearch</span>&amp;repo=extras</span><br>gpgcheck=1<br>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">additional packages that extend functionality of existing packages</span><br>[centosplus]<br>name=CentOS-$releasever - Plus<br>baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/<br><span class="hljs-meta prompt_">#</span><span class="language-bash">mirrorlist=http://mirrorlist.centos.org/?release=<span class="hljs-variable">$releasever</span>&amp;<span class="hljs-built_in">arch</span>=<span class="hljs-variable">$basearch</span>&amp;repo=centosplus</span><br>gpgcheck=1<br>enabled=0<br>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br></code></pre></td></tr></table></figure><p>生成缓存即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum makecache<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qemu -monitor如何使用</title>
    <link href="/047.html"/>
    <url>/047.html</url>
    
    <content type="html"><![CDATA[<h2 id="qemu-monitor如何使用"><a href="#qemu-monitor如何使用" class="headerlink" title="qemu -monitor如何使用"></a>qemu -monitor如何使用</h2><p>qemu启动虚拟机时有一个<code>-monitor</code>参数选项，<code>-monitor</code>参数用于开启QEMU虚拟机中的Monitor模式，允许用户在虚拟机中使用命令行界面进行管理和监控。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali"> root@test-ubuntu-no-vgpu:~<span class="hljs-comment"># /opt/qemu-7.2.1/build/x86_64-softmmu/qemu-system-x86_64 -h  grep monitor</span><br> -monitor dev    redirect the<span class="hljs-built_in"> monitor </span>to char device &#x27;dev&#x27;<br></code></pre></td></tr></table></figure><p>其中，dev可以是telnet、stdio、vc、serial等连接方式之一，options可以是连接选项，包括连接方式、端口号、认证方式等。</p><h3 id="stdio"><a href="#stdio" class="headerlink" title="stdio"></a>stdio</h3><p>直接使用stdio方式标准输入输出接口链接：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"> /<span class="hljs-keyword">opt</span>/qemu-<span class="hljs-number">7.2</span>.<span class="hljs-number">1</span>/build/x86_64-softmmu/qemu-<span class="hljs-built_in">system</span>-x86_64 -accel kvm -<span class="hljs-keyword">m</span> <span class="hljs-number">4096</span> -smp <span class="hljs-number">4</span> -hda /<span class="hljs-keyword">opt</span>/lyy/CentOS7.qcow2 -boot <span class="hljs-keyword">menu</span>=<span class="hljs-keyword">on</span> -bios /<span class="hljs-keyword">opt</span>/seabios/out/bios.bin -d unimp -<span class="hljs-keyword">k</span> <span class="hljs-keyword">en</span>-us -monitor stdio<br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/05/image-auux.png"> 就可以输入相应的命令了</p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>要在QEMU虚拟机中开启Monitor模式并使用telnet连接方式，可以使用以下命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"> /<span class="hljs-keyword">opt</span>/qemu-<span class="hljs-number">7.2</span>.<span class="hljs-number">1</span>/build/x86_64-softmmu/qemu-<span class="hljs-built_in">system</span>-x86_64 -accel kvm -<span class="hljs-keyword">m</span> <span class="hljs-number">4096</span> -smp <span class="hljs-number">4</span> -hda /<span class="hljs-keyword">opt</span>/lyy/CentOS7.qcow2 -boot <span class="hljs-keyword">menu</span>=<span class="hljs-keyword">on</span> -bios /<span class="hljs-keyword">opt</span>/seabios/out/bios.bin -d unimp -<span class="hljs-keyword">k</span> <span class="hljs-keyword">en</span>-us -monitor telne<span class="hljs-variable">t:127</span>.<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">5555</span>,server,nowait<br></code></pre></td></tr></table></figure><p>telnet表示连接方式，127.0.0.1:5555表示连接的IP地址和端口号，server表示使用服务器模式，nowait表示不等待连接。 启动QEMU虚拟机后，用户可以在另一个终端窗口中使用telnet命令连接到Monitor界面，例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">telnet</span> <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">5555</span><br></code></pre></td></tr></table></figure><p>连接成功后，用户就可以使用Monitor命令行界面来管理和监控虚拟机的运行状态，包括查看虚拟机状态、修改虚拟机配置、控制虚拟机的运行、挂载和卸载虚拟机磁盘、设置虚拟机的网络连接、管理虚拟机的设备等。 <img src="/wp-content/uploads/2023/05/image-lnxx.png"></p><h2 id="一些monitor命令"><a href="#一些monitor命令" class="headerlink" title="一些monitor命令"></a>一些monitor命令</h2><h3 id="1-help"><a href="#1-help" class="headerlink" title="1 help"></a>1 help</h3><p>help可以列出可以执行的命令，如果知道执行的命令可以使用help+命令查看更详细的解释，如help info</p><h3 id="2-info"><a href="#2-info" class="headerlink" title="2 info"></a>2 info</h3><p>info可以查看QEMU虚拟机的状态、CPU、内存、设备等信息。</p><h4 id="info-cpus"><a href="#info-cpus" class="headerlink" title="info cpus"></a>info cpus</h4><p><img src="/wp-content/uploads/2023/05/image-qtuy.png"></p><h4 id="info-status"><a href="#info-status" class="headerlink" title="info status"></a>info status</h4><p><img src="/wp-content/uploads/2023/05/image-jzrv.png"></p><h4 id="info-kvm"><a href="#info-kvm" class="headerlink" title="info kvm"></a>info kvm</h4><p><img src="/wp-content/uploads/2023/05/image-izis.png"></p><h4 id="info-uuid"><a href="#info-uuid" class="headerlink" title="info uuid"></a>info uuid</h4><p>  <img src="/wp-content/uploads/2023/05/image-ilmt.png"></p><h4 id="3-虚拟机控制"><a href="#3-虚拟机控制" class="headerlink" title="3 虚拟机控制"></a>3 虚拟机控制</h4><p>如</p><ul><li>重启:<code>system_reset</code></li><li>关机:<code>system_powerdown</code></li><li>快照相关：<code>savevm</code>、<code>loadvm</code>、<code>delvm</code>等等</li><li>控制vCPU等等</li></ul><p>其他的命令可以通过help命令查看。</p>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用GDB对qemu进行调试</title>
    <link href="/022.html"/>
    <url>/022.html</url>
    
    <content type="html"><![CDATA[<h2 id="如何使用GDB对qemu进行调试："><a href="#如何使用GDB对qemu进行调试：" class="headerlink" title="如何使用GDB对qemu进行调试："></a>如何使用GDB对qemu进行调试：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"> gdb --arg /opt/qemu-7.2.1/build/x86_64-softmmu/qemu-system-x86_64 -accel kvm -m 4096 -smp 4 -hda /opt/lyy/CentOS7.qcow2 -boot menu=on -bios /opt/seabios/out/bios.bin -d unimp -k en-us  -vnc :0 -S<br></code></pre></td></tr></table></figure><p>其中：&#x2F;<strong>opt&#x2F;qemu-7.2.1&#x2F;build&#x2F;x86_64-softmmu&#x2F;qemu-system-x86_64 -accel kvm -m 4096 -smp 4 -hda &#x2F;opt&#x2F;lyy&#x2F;CentOS7.qcow2 -boot menu&#x3D;on -bios &#x2F;opt&#x2F;seabios&#x2F;out&#x2F;bios.bin -d unimp -k en-us</strong> ：是正常qemu启动流程， -vnc表示开启VNC监听，可以使用VNC连接这个虚拟机，端口是5900 -S选项代表运行后暂停QEMU执行。 启动后进入如下界面： <img src="/wp-content/uploads/2023/05/image-qwwo.png"> 使用gdb命令进行调试， 可以先设置断点：例如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"> <span class="hljs-keyword">break</span> main<br> # <span class="hljs-keyword">break</span> 方法名，上述命令代表对main方法进行打上断点<br></code></pre></td></tr></table></figure><p>例如我们需要查看vnc_listen_io方法进入时的参数已经栈中函数，可以给vnc_listen_io打上断点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"> <span class="hljs-keyword">break</span> vnc_listen_io<br></code></pre></td></tr></table></figure><p>查看已经打的断点：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> <span class="hljs-built_in">info</span> breakpoints<br></code></pre></td></tr></table></figure><p>然后启动我们要调试的程序：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"> <span class="hljs-built_in">run</span><br></code></pre></td></tr></table></figure><p>一直运行直到下一个断点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"> <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><p>进入下一步：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"> step<br></code></pre></td></tr></table></figure><p>在调试vnc连接过程中，因为qemu启动过程会不停进入，需要run后进行continue等待qemu启动： <img src="/wp-content/uploads/2023/05/image-cvhl.png"> 启动过后，可以看到5900端口就可以访问了，采用vnc客户端连接vnc 5900端口： 再使用gdb命令bt：查看函数调用堆栈</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"> <span class="hljs-keyword">bt</span><br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/05/image-vpqe.png"></p>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nova-compute服务源码解析</title>
    <link href="/039.html"/>
    <url>/039.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Nova-compute服务源码解析"><a href="#1-Nova-compute服务源码解析" class="headerlink" title="1 Nova-compute服务源码解析"></a>1 Nova-compute服务源码解析</h1><p>nova-compute创建虚拟机时，其主要任务就是通过用户准备的各种参数，最终生成创建虚拟机的XML文件以供Hypervisor使用，主要步骤如下：</p><p>NaN.  准备虚拟机所需要的资源（CPU资源，RAM资源以及镜像资源等），网络资源也会在这个阶段一同分配<br>NaN.  创建虚拟机的镜像文件，nova-compute会调用glanceclient拉取镜像，以该镜像为基础创建镜像文件。<br>NaN.  生成创建虚拟机的XML文件<br>NaN.  创建网络并启动虚拟机</p><p>以上过程中生成的XML或者暂存在计算节点的镜像都会存放在计算节点的&#x2F;var&#x2F;lib&#x2F;nova&#x2F;instances文件夹下以该虚拟机的UUID命名的子目录中。</p><h2 id="1-1-Nova-compute启动流程"><a href="#1-1-Nova-compute启动流程" class="headerlink" title="1.1 Nova-compute启动流程"></a>1.1 Nova-compute启动流程</h2><p>nova-compute服务的入口位于nova&#x2F;cmd&#x2F;compute.py，如下图所示： <img src="/wp-content/uploads/2023/05/image-cync.png"> 其中第45行会读取配置文件进行一些初始化的工作，第59行代码用于创建RPC Service，并将此RPC Service的topic设置为CONF.compute_topic，类Service的定义位于nova&#x2F;service.py，其中第116行为实例化一个ComputeManager（nova&#x2F;compute&#x2F;manager.py）类，里面定义了接受并处理各种RPC请求的方法。 <img src="/wp-content/uploads/2023/05/image-ivyr.jpg"> 最后在nova&#x2F;cmd&#x2F;compute.py的第61行service.serve(server)用于启动RPC Service()，service.serve()的实现方法（nova&#x2F;service.py）如下所示，通过oslo_service&#x2F;service.py中的launch方法，启动相应数量的RPC Service进程，至此nova-compute服务启动。  </p><h2 id="1-2-Nova-compute创建虚拟机流程"><a href="#1-2-Nova-compute创建虚拟机流程" class="headerlink" title="1.2 Nova-compute创建虚拟机流程"></a>1.2 Nova-compute创建虚拟机流程</h2><p>在OpenStack nova创建虚拟机过程中，nova-api收到虚拟机创建请求，然后nova-scheduler完成选择合适计算节点的任务，nova-conductor则开始调用build_instance()来创建虚机。 <a href="http://在conductor.manager.computetaskmanager.build/">在conductor.manager.ComputeTaskManager.build</a>_instance()中，通过rpc调用：self.compute_rpcapi.build_and_run_instance()，该方法的代码如下所示（nova&#x2F;compute&#x2F;rpcapi.py）该方法通过RPC调用nova&#x2F;compute&#x2F;manager.py:ComputeManager中的build_and_run_instance()方法。而build_and_run_instance()方法就完成VM在计算节点上的创建和启动任务。 nova&#x2F;compute&#x2F;rpcapi.py：   <img src="/wp-content/uploads/2023/05/image-fpfs.png"> nova&#x2F;compute&#x2F;manager.py： <img src="/wp-content/uploads/2023/05/image-luem.png"> 里面定义了一个_locked_do_build_and_run_instance()方法，这里真正实现instance的创建和启动的，还有一个spawn方法调用，这是因为nova compute创建VM的时间会比较长，因为其中包括了下载VM镜像、创建和配置VM网卡信息、文件注入等任务，因此调用utils.spawn_n()方法返回RPC线程而不会造成阻塞。 在_locked_do_build_and_run_instance()_<a href="http://方法直接调用self.do/">_方法直接调用self._do</a>_build_and_run_instance()。 <img src="/wp-content/uploads/2023/05/image-fqtj.png"> <img src="/wp-content/uploads/2023/05/image-wbev.png"> self._do_build_and_run_instance()方法主要做了一下几件事： 1、 设置虚拟机状态为BUILDING instance.vm_state &#x3D; vm_states.BUILDING， task_state为None，然后调用instance.save()将状态存入数据库中。 2、 如果起虚机时有文件注入，将会调用nova.compute.manager.ComputeManager._decode_files()完成文件注入处理。decoded_files &#x3D; self._decode_files(injected_files) 3、 接下来就是调用self._build_and_run_instance方法进行虚拟机创建。     self._build_and_run_instance： <img src="/wp-content/uploads/2023/05/image-slzr.png"> 该方法包含如下几个部分： 1、 通知部分，通知其他组件实例的创建状态： <img src="/wp-content/uploads/2023/05/image-dyia.png"> 2、 检查设备和证书： <img src="/wp-content/uploads/2023/05/image-qgyc.png"> 3、 provider_mapping &#x3D; self._get_request_group_mapping(request_spec) 要在服务器调度期间支持 QoS 最小带宽策略，Neutron 需要知道哪个资源提供程序为服务器创建请求中的每个端口提供带宽资源。在处理 VGPU 和加速器设备时会出现类似的需求。返回一个字典，如果该字典不为空，那么就需要更新pci_request_spec。 <img src="/wp-content/uploads/2023/05/image-gsjd.png"> 4、 获取该用户的分配情况： <img src="/wp-content/uploads/2023/05/image-rkvw.png"> 5、 _get_scheduler_hints获取调度程序提示，self.rt.instance_claim获取实例资源分配声明，可用于发生异常后恢复资源，self._validate_instance_group_policy验证是否符合调度程序设置的策略： <img src="/wp-content/uploads/2023/05/image-bivc.png"> 6、 接下来就是调用self._build_resources申请各种资源，成功后，更新数据库中的状态：vm_state为building, task_state为spawning， <img src="/wp-content/uploads/2023/05/image-nxvg.png"> 7、 最后调用driver.spawn方法完成VM孵化，OpenStack底层调用的是libvirt，因此这里的driver就是libvirt提供的接口。在配置文件&#x2F;etc&#x2F;nova&#x2F;nova.conf中设置了Driver&#x3D; LibvirtDriver。   <img src="/wp-content/uploads/2023/05/image-lzha.png">   查看具体如何申请各种资源的： self._build_resources()方法： 1、如果accel_uuids不为空，执行_get_bound_arq_resources和_split_network_arqs。 <img src="/wp-content/uploads/2023/05/image-uhav.png"> 2、为实例构建网络：_build_networks_for_instance <img src="/wp-content/uploads/2023/05/image-izrz.png"> 3、分配块设备 <img src="/wp-content/uploads/2023/05/image-yyiw.png"></p>]]></content>
    
    
    <categories>
      
      <category>OpenStack</category>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openstack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4k壁纸网站推荐</title>
    <link href="/002.html"/>
    <url>/002.html</url>
    
    <content type="html"><![CDATA[<h1 id="4k壁纸网站推荐"><a href="#4k壁纸网站推荐" class="headerlink" title="4k壁纸网站推荐"></a>4k壁纸网站推荐</h1><p>最近想找找一些图片当个桌面或者装饰一下网站，需要4k图片，在这里也分享一下我找的一些不错的网站 1 二次元网站 <a href="http://konachan.net/">konachan.net</a> <a href="https://konachan.net/">-</a> <a href="http://konachan.com/">Konachan.com</a> <a href="https://konachan.net/">Anime Wallpapers</a> 网站内的图片非常高清，都是4K画质，简直太酷了！</p><h2 id="2-Wallpaper-Abyss"><a href="#2-Wallpaper-Abyss" class="headerlink" title="2 Wallpaper Abyss"></a><img src="/wp-content/uploads/2023/05/image-hmre.png">2 Wallpaper Abyss</h2><p><a href="https://wall.alphacoders.com/">Wallpaper Abyss - HD Wallpapers, Background Images (</a><a href="http://alphacoders.com/">alphacoders.com</a><a href="https://wall.alphacoders.com/">)</a> 这也是一个国外的壁纸网站，绝大部分的壁纸都是超清、4K的，而且壁纸的质量都很高。 <img src="/wp-content/uploads/2023/05/image-igwf.jpg"></p><h2 id="2-彼岸图网"><a href="#2-彼岸图网" class="headerlink" title="2 彼岸图网"></a>2 彼岸图网</h2><p>访问链接：<a href="https://pic.netbian.com/">4K壁纸_4K手机壁纸_4K高清壁纸大全_电脑壁纸_4K,5K,6K,7K,8K壁纸图片素材_彼岸图网 (</a><a href="http://netbian.com/">netbian.com</a>) 质量还是可以的，缺点是资源还是不是特别多，更新也不是很快，还有收费，不过不是很贵。可以看一下有看上的1块钱的会员。 <img src="/wp-content/uploads/2023/05/image-izbm.jpg">收费价格也还可以：1块钱7天会员，每天可以下载20张。 <img src="/wp-content/uploads/2023/05/image-qmsl.png"></p>]]></content>
    
    
    <categories>
      
      <category>好用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>壁纸网站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可视化监控服务器资源包括CPU、内存、磁盘、GPU的使用</title>
    <link href="/011.html"/>
    <url>/011.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-目标"><a href="#1-目标" class="headerlink" title="1 目标"></a>1 目标</h2><p>目标：可视化监控服务器资源包括CPU、内存、磁盘、GPU的使用，以及监控docker容器的使用情况。 有一台监控节点和三台被监控节点GPU服务器，被监控节点操作都是一样的。</p><h2 id="2-使用Grafana-Promethus的方式采集数据"><a href="#2-使用Grafana-Promethus的方式采集数据" class="headerlink" title="2 使用Grafana+Promethus的方式采集数据"></a>2 使用Grafana+Promethus的方式采集数据</h2><p>采用Grafana做可视化面板，Promethus做数据采集和收集存储。</p><ul><li>CPU、内存、磁盘等：node-exporter</li><li>GPU：nvidia_gpu_exporter、dcgm-exporter</li><li>docker容器：cadvisor</li></ul><h3 id="2-1-监控节点"><a href="#2-1-监控节点" class="headerlink" title="2.1 监控节点"></a>2.1 监控节点</h3><h4 id="安装Grafana"><a href="#安装Grafana" class="headerlink" title="安装Grafana"></a>安装Grafana</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"> cd /opt<br> wget https://dl.grafana.com/enterprise/release/grafana-enterprise-9.5.1-1.x86_64.rpm<br> ls<br> yum install -y grafana-enterprise-9.5.1-1.x86_64.rpm<br> ​<br><span class="hljs-meta prompt_"> #</span><span class="language-bash">设置systemctl</span><br> systemctl enable grafana-server.service<br> systemctl start grafana-server.service<br> systemctl status grafana-server.service<br></code></pre></td></tr></table></figure><p>访问：<a href="http://172.xx.xx.xx:3000/">http://172.xx.xx.xx:3000/</a> 查看是否安装成功：初始密码admin，admin可以修改密码。 设置中文：修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"> <br> vim /etc/grafana/grafana.ini<br> ​<br><span class="hljs-meta prompt_"> #</span><span class="language-bash">修改如下语句</span><br> default_language = zh-Hans<br></code></pre></td></tr></table></figure><blockquote><p>该处修改语言，可能不需要修改配置文件，web界面进入后，点击管理-&gt;默认首选项就可以设置语言，保存即可，下图是已经设置好的结果</p></blockquote><p>  <img src="/wp-content/uploads/2023/05/image-voqe.png"></p><h4 id="安装promethus"><a href="#安装promethus" class="headerlink" title="安装promethus"></a>安装promethus</h4><p>监控节点上的promethus负责收集各个主机上的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"> cd /opt<br> wget  https://mirrors.tuna.tsinghua.edu.cn/github-release/prometheus/prometheus/LatestRelease/prometheus-2.37.8.linux-amd64.tar.gz<br> tar -zxvf prometheus-2.37.8.linux-amd64.tar.gz<br> ​<br> mv prometheus-2.37.8.linux-amd64/ prometheus-linux-amd64/<br> cd prometheus-linux-amd64/<br> ​<br> nohup ./prometheus &amp;<br></code></pre></td></tr></table></figure><p>验证一下：<a href="http://172.xx.xx.xx:9090/">http://172.XX.xx.xx:9090/</a> 默认端口9090，如果可以访问就说明安装成功，但是这样的启动方式不太好，我们使用systemd管理 设置systemctl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"> vim /lib/systemd/system/prometheus.service<br></code></pre></td></tr></table></figure><p>文件内容包含：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"> [Unit]<br> Description=Prometheus Server<br> After=network.target<br> ​<br> [Service]<br> ​<br> User=root<br> Group=root<br> ​<br> Type=simple<br> ExecStart=/opt/prometheus-linux-amd64/prometheus --config.file=/opt/prometheus-linux-amd64/prometheus.yml<br> ​<br> [Install]<br> WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"> systemctl daemon-reload<br> systemctl enable prometheus<br> systemctl start prometheus<br> systemctl status prometheus<br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/05/image-funw.png"></p><h4 id="监控节点安装node-exporter"><a href="#监控节点安装node-exporter" class="headerlink" title="监控节点安装node-exporter"></a>监控节点安装node-exporter</h4><p>node-exporter用来采集主机相关的数据的。我们先安装这个测试一下是否可以正常拿到数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"> # </span><span class="language-bash">查看以下是否可以直接通过yum源安装</span><br> yum search node-export<br></code></pre></td></tr></table></figure><p><img src="/wp-content/uploads/2023/05/image-trmh.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"> yum install golang-github-prometheus-node-exporter<br> systemctl enable node_exporter.service<br> systemctl start node_exporter.service<br> systemctl status node_exporter.service<br></code></pre></td></tr></table></figure><p>验证一下：curl <a href="http://172.xx.xx.xx:9400/metrics%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E6%95%B0%E6%8D%AE%E6%88%96%E8%80%85%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BD%86%E6%B2%A1%E6%9C%89%E6%8A%A5%E9%94%99%EF%BC%8C%E8%AF%B4%E6%98%8E%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E4%BA%86%E3%80%82">http://172.xx.xx.xx:9400/metrics，如果有数据或者没有数据但没有报错，说明安装成功了。</a> 同样的方式，再各个节点安装node-exporter。</p><h4 id="修改promethus-yml配置文件"><a href="#修改promethus-yml配置文件" class="headerlink" title="修改promethus.yml配置文件"></a>修改promethus.yml配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"> <span class="hljs-attr">scrape_configs:</span><br>   <span class="hljs-comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;prometheus&quot;</span><br> <span class="hljs-string">​</span><br>     <span class="hljs-comment"># metrics_path defaults to &#x27;/metrics&#x27;</span><br>     <span class="hljs-comment"># scheme defaults to &#x27;http&#x27;.</span><br> <span class="hljs-string">​</span><br>     <span class="hljs-attr">static_configs:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9090&quot;</span>]<br> <span class="hljs-string">​</span><br> <span class="hljs-comment">#添加如下内容，targets的ip，端口根据你要监控的节点不同二设置，instance可以设置名称</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">linux</span><br>     <span class="hljs-attr">static_configs:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9100&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">监控节点</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9100&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">被监控GPU节点1</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9100&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">被监控GPU节点2</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9100&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">被监控GPU节点3</span><br></code></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"> systemctl <span class="hljs-built_in">restart</span> promethus<br></code></pre></td></tr></table></figure><p>访问promethus的web： <img src="/wp-content/uploads/2023/05/image-etzo.png"> 查看对应的node-exporter是否正常： <img src="/wp-content/uploads/2023/05/image-atea.png"></p><h3 id="2-2-被监控节点"><a href="#2-2-被监控节点" class="headerlink" title="2.2 被监控节点"></a>2.2 被监控节点</h3><p>以下操作每个被监控节点上按照需求安装。</p><h4 id="安装node-exporter"><a href="#安装node-exporter" class="headerlink" title="安装node-exporter"></a>安装node-exporter</h4><p>与监控节点一致，不再多言。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"> yum install golang-github-prometheus-<span class="hljs-keyword">node</span><span class="hljs-title">-exporter</span><br> ​<br> systemctl status node_exporter.service<br> systemctl enable node_exporter.service<br> systemctl <span class="hljs-literal">start</span> node_exporter.service<br></code></pre></td></tr></table></figure><h4 id="安装GPU采集器-nvidia-gpu-exporter"><a href="#安装GPU采集器-nvidia-gpu-exporter" class="headerlink" title="安装GPU采集器-nvidia_gpu_exporter"></a>安装GPU采集器-nvidia_gpu_exporter</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">cd</span> /opt<br> <span class="hljs-attribute">wget</span> https://github.com/utkuozdemir/nvidia_gpu_exporter/releases/download/v1.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>/nvidia_gpu_exporter_1.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>_linux_x86_64.tar.gz<br> <span class="hljs-attribute">tar</span> -xvzf nvidia_gpu_exporter_1.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>_linux_x86_64.tar.gz<br> <span class="hljs-attribute">mv</span> nvidia_gpu_exporter /usr/bin<br></code></pre></td></tr></table></figure><p>设置systemctl：vim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nvidia_gpu_exporter.service，内容如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> [Unit]<br> <span class="hljs-attribute">Description</span>=Nvidia GPU Exporter<br> <span class="hljs-attribute">After</span>=network-online.target<br> ​<br> [Service]<br> <span class="hljs-attribute">Type</span>=simple<br> ​<br> <span class="hljs-attribute">User</span>=root<br> <span class="hljs-attribute">Group</span>=root<br> ​<br> <span class="hljs-attribute">ExecStart</span>=/usr/bin/nvidia_gpu_exporter<br> ​<br> <span class="hljs-attribute">SyslogIdentifier</span>=nvidia_gpu_exporter<br> ​<br> <span class="hljs-attribute">Restart</span>=always<br> <span class="hljs-attribute">RestartSec</span>=1<br> ​<br> <span class="hljs-attribute">NoNewPrivileges</span>=<span class="hljs-literal">yes</span><br> ​<br> <span class="hljs-attribute">ProtectHome</span>=<span class="hljs-literal">yes</span><br> <span class="hljs-attribute">ProtectSystem</span>=strict<br> <span class="hljs-attribute">ProtectControlGroups</span>=<span class="hljs-literal">true</span><br> <span class="hljs-attribute">ProtectKernelModules</span>=<span class="hljs-literal">true</span><br> <span class="hljs-attribute">ProtectKernelTunables</span>=<span class="hljs-literal">yes</span><br> <span class="hljs-attribute">ProtectHostname</span>=<span class="hljs-literal">yes</span><br> <span class="hljs-attribute">ProtectKernelLogs</span>=<span class="hljs-literal">yes</span><br> <span class="hljs-attribute">ProtectProc</span>=<span class="hljs-literal">yes</span><br> ​<br> [Install]<br> <span class="hljs-attribute">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nsis"> <span class="hljs-params">system</span>ctl daemon-reload<br> <span class="hljs-params">system</span>ctl start  nvidia_gpu_exporter.service<br> <span class="hljs-params">system</span>ctl status nvidia_gpu_exporter.service<br> <span class="hljs-params">system</span>ctl enable nvidia_gpu_exporter.service<br></code></pre></td></tr></table></figure><p>测试：curl <a href="http://localhost:9835/metrics">http://localhost:9835/metrics</a></p><h4 id="安装另一种GPU采集器dcgm-exporter"><a href="#安装另一种GPU采集器dcgm-exporter" class="headerlink" title="安装另一种GPU采集器dcgm-exporter"></a>安装另一种GPU采集器dcgm-exporter</h4><p>这里我们使用docker安装了，没有装docker的需要装一下docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"> docker pull nvidia/dcgm-exporter<br> docker run -d --gpus all --<span class="hljs-built_in">rm</span> -p 9400:9400 nvidia/dcgm-exporter:latest<br> ​<br> curl http://localhost:9400/metrics<br></code></pre></td></tr></table></figure><h4 id="安装容器监控cadvisor"><a href="#安装容器监控cadvisor" class="headerlink" title="安装容器监控cadvisor"></a>安装容器监控cadvisor</h4><p>这里也是使用容器监控，由于cadvisor默认的是8080端口，我们替换成9080，防止冲突。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"> docker run   --volume=<span class="hljs-regexp">/:/rootfs</span><span class="hljs-symbol">:ro</span>   --volume=<span class="hljs-regexp">/var/run</span><span class="hljs-symbol">:/var/run</span><span class="hljs-symbol">:rw</span>   --volume=<span class="hljs-regexp">/sys:/sys</span><span class="hljs-symbol">:ro</span>   --volume=<span class="hljs-regexp">/var/lib</span><span class="hljs-regexp">/docker/</span><span class="hljs-symbol">:/var/lib/docker</span><span class="hljs-symbol">:ro</span>   --volume=<span class="hljs-regexp">/dev/disk</span><span class="hljs-regexp">/:/dev</span><span class="hljs-regexp">/disk:ro   --publish=9080:8080   --detach=true   --name=cadvisor   google/cadvisor</span><span class="hljs-symbol">:latest</span><br> docker ps -a<br> curl <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/localhost:9080/metrics</span><br> ​<br></code></pre></td></tr></table></figure><h2 id="设置promethus-yml文件"><a href="#设置promethus-yml文件" class="headerlink" title="设置promethus.yml文件"></a>设置promethus.yml文件</h2><p>现在我们已经再各个监控节点上安装好了采集器，并且可以通过&#x2F;metrics获取到度量数据，现在我们修改promethus.yml文件，添加对应的job节点 完整的配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs yaml"> <span class="hljs-comment"># my global config</span><br> <span class="hljs-attr">global:</span><br>   <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span> <span class="hljs-comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br>   <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span> <span class="hljs-comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span><br>   <span class="hljs-comment"># scrape_timeout is set to the global default (10s).</span><br> <span class="hljs-string">​</span><br> <span class="hljs-comment"># Alertmanager configuration</span><br> <span class="hljs-attr">alerting:</span><br>   <span class="hljs-attr">alertmanagers:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-attr">static_configs:</span><br>         <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>           <span class="hljs-comment"># - alertmanager:9093</span><br> <span class="hljs-string">​</span><br> <span class="hljs-comment"># Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.</span><br> <span class="hljs-attr">rule_files:</span><br>   <span class="hljs-comment"># - &quot;first_rules.yml&quot;</span><br>   <span class="hljs-comment"># - &quot;second_rules.yml&quot;</span><br> <span class="hljs-string">​</span><br> <span class="hljs-comment"># A scrape configuration containing exactly one endpoint to scrape:</span><br> <span class="hljs-comment"># Here it&#x27;s Prometheus itself.</span><br> <span class="hljs-attr">scrape_configs:</span><br>   <span class="hljs-comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;prometheus&quot;</span><br> <span class="hljs-string">​</span><br>     <span class="hljs-comment"># metrics_path defaults to &#x27;/metrics&#x27;</span><br>     <span class="hljs-comment"># scheme defaults to &#x27;http&#x27;.</span><br> <span class="hljs-string">​</span><br>     <span class="hljs-attr">static_configs:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9090&quot;</span>]<br> <span class="hljs-string">​</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">linux</span><br>     <span class="hljs-attr">static_configs:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9100&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">监控节点</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9100&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">被监控节点GPU节点1</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9100&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">被监控节点GPU节点2</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9100&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">被监控节点GPU节点3</span><br> <span class="hljs-string">​</span><br> <span class="hljs-string">​</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">gpu</span>                       <span class="hljs-comment"># 任务名称，会在prometheus targets页面显示名称</span><br>      <span class="hljs-attr">static_configs:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9835&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">被监控节点GPU节点1</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9835&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">被监控节点GPU节点2</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9835&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">被监控节点GPU节点3</span><br> <span class="hljs-string">​</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">gpu_dcgm</span>                     <br>     <span class="hljs-attr">static_configs:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9400&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">被监控节点GPU节点1</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9400&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">被监控节点GPU节点2</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9400&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">被监控节点GPU节点3</span><br> <span class="hljs-string">​</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">docker</span>                  <br>     <span class="hljs-attr">static_configs:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9080&#x27;</span>]  <br>         <span class="hljs-attr">labels:</span>                        <br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">&quot;被监控节点GPU节点1:9080&quot;</span>               <br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9080&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">&quot;被监控节点GPU节点2:9080&quot;</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.xx.xx:9080&#x27;</span>]<br>         <span class="hljs-attr">labels:</span><br>           <span class="hljs-attr">instance:</span> <span class="hljs-string">&quot;被监控节点GPU节点3:9080&quot;</span><br> <span class="hljs-string">​</span><br></code></pre></td></tr></table></figure><h2 id="配置grafana面板"><a href="#配置grafana面板" class="headerlink" title="配置grafana面板"></a>配置grafana面板</h2><p>导入dashboard，分别导入：13631、12239、11074、14574，四个面板，可以分别进行自定义相应的面板，也可以去grafana官网搜索更多有关的仪表盘。 展示一下：14574面板：如果面板不符合自己的要求，可以通过设置调整成自己想要的界面。</p><blockquote><p>14574界面：展示的只是GPU的UUID但是，我给他添加了几个变量，分别是instance、device，方便我们使用，这样就可以方便的看到没一台物理服务器上的GPU显卡设备：。</p></blockquote><p><img src="/wp-content/uploads/2023/05/image-blip.png"> <img src="/wp-content/uploads/2023/05/image-dyou.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>grafana</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU和KVM的关系</title>
    <link href="/0035.html"/>
    <url>/0035.html</url>
    
    <content type="html"><![CDATA[<h1 id="QEMU和KVM的关系"><a href="#QEMU和KVM的关系" class="headerlink" title="QEMU和KVM的关系"></a>QEMU和KVM的关系</h1><p>我们已经知道QEMU是作为用户态软件模拟IO，而KVM负责完成CPU、内存等虚拟化，为什么常常把KVM和QEMU联系起来，因为KVM诞生之初就是使用的QEMU作为用户态的设备模拟软件，其实Xen也可以使用QEMU作为用户态组件来实现设备的模拟。 KVM在内核中通过&#x2F;dev&#x2F;kvm给用户态的软件，提供了一系列的接口，例如用户态创建、配置、启动虚拟机等，在设备模拟的部分，KVM创立之初就重用了QEMU的设备模拟的部分，从本质上来讲，QEMU和KVM是完全可以不用相互依赖的。举个例子，来展示QEMU和KVM之间的关系，这个例子包括精简版内核，这个内核功能简单，作用只是向I&#x2F;O端口写入数据；第二部分可以看作是一个精简版的QEMU，它的功能也很简单，就是使用上述内核创建虚拟机，打印出精简内核的端口数据。</p><h2 id="精简内核代码"><a href="#精简内核代码" class="headerlink" title="精简内核代码"></a>精简内核代码</h2><p>精简内核代码如下：作用是将”SCU HELLO”字符串输出到I&#x2F;O端口0xf1上，然后调用hlt指令使CPU进入停机状态，直到有中断或者复位信号发生才会继续执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">test.S 代码如下：<br>start:<br>mov $0x53,%al<br>outb %al,$Oxf1<br>mov $0x43,%al<br>outb %al,$Oxf1<br>mov $0x55,%al<br>outb %al,$0xf1<br>mov $0x20,%al<br>outb %al,$Oxf1<br>mov $0x48,%al<br>outb %al,$Oxf1<br>mov $0x45, %al<br>outb %al,$Oxf1<br>mov $0x4c, %al<br>outb %al,$Oxf1<br>mov $0x4c, %al<br>outb %al,$Oxf1<br>mov $0x4f, %al<br>outb %al,$Oxf1<br>mov $0x0a, %al<br>outb %al,$Oxf1<br>hlt<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mov $0x48,%al<br>outb %al,$Oxf1<br></code></pre></td></tr></table></figure><p>这是两条x86汇编语言指令，它们的作用是将十六进制数0x48输出到I&#x2F;O端口0xf1上。具体来说，第一条指令<code>mov $0x48,%al</code>的作用已经在上一个问题中解释过了，它将立即数0x48移动到AL寄存器中。第二条指令<code>outb %al,$0xf1</code>则是将AL寄存器中的值输出到I&#x2F;O端口0xf1上。outb是x86汇编语言中的一个输出指令，它的作用是将一个字节（8位）的数据输出到指定的I&#x2F;O端口。 使用如下命令进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">as -32 test.S -o test.o<br>objcopy -O binary test.o test.bin<br></code></pre></td></tr></table></figure><p>第一个命令<code>as -32 test.S -o test.o</code>是使用GNU汇编器（as）将汇编代码文件<code>test.S</code>汇编成目标文件（object file）<code>test.o</code>。其中，<code>-32</code>选项指定生成32位目标文件，<code>-o</code>选项指定输出文件名为<code>test.o</code>。 第二个命令<code>objcopy -O binary test.o test.bin</code>是使用GNU二进制文件操作工具（objcopy）将目标文件<code>test.o</code>转换为二进制文件<code>test.bin</code>。其中，<code>-O binary</code>选项指定输出文件格式为二进制文件，<code>test.o</code>为输入文件名，<code>test.bin</code>为输出文件名。</p><h2 id="精简版QEMU代码"><a href="#精简版QEMU代码" class="headerlink" title="精简版QEMU代码"></a>精简版QEMU代码</h2><p>qemu.c代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kvm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_sregs</span> <span class="hljs-title">sregs</span>;</span><br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-comment">//通过打开/edv/kvm获取系统中KVM子系统的文件描述符</span><br>    <span class="hljs-type">int</span> kvmfd = open (&amp;quot;/dev/kvm&amp;quot;,O_RDWR);<br>    <span class="hljs-comment">//保持应用层与内核统一，获取KVM版本，应用层可以知晓KVM的支持情况</span><br>    ioctl(kvmfd, KVM_GET_API_VERSION,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 创建虚拟机，返回一个代表虚拟机的文件描述符</span><br>    <span class="hljs-type">int</span> vmfd = ioctl(kvmfd, KVM_CREATE_VM,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 给虚拟机分配物理内存，虚拟机的物理内存是QEMU的位于进程地址空间，这段内存大小为0x1000 4KB</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *ram = mmap(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0x1000</span>,PROT_READ  PROT_WRITE,MAP_SHARED  MAP_ANONYMOUS,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//将精简内核读入内存</span><br>    <span class="hljs-type">int</span> kfd = open(&amp;quot;test.bin&amp;quot;,O_RDONLY);<br>    read(kfd,ram,<span class="hljs-number">4096</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> <span class="hljs-title">mem</span> =</span> &#123;<br>        <span class="hljs-comment">//slot用来表示不同的内存空间</span><br>        .slot = <span class="hljs-number">0</span>,<br>        <span class="hljs-comment">//表示这段空间在虚拟机物理内存空间的地址</span><br>        .guest_phys_addr = <span class="hljs-number">0</span>,<br>        <span class="hljs-comment">//表示这段物理空间的大小</span><br>        .memory_size = <span class="hljs-number">0x1000</span>,<br>        <span class="hljs-comment">//表示这段物理空间对应宿主机上的虚拟机地址 也就是GPA-&amp;gt;HVA</span><br>        .userspace_addr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) ram,<br>    &#125;;<br>    <span class="hljs-comment">//为虚拟机分配内存，一个内存条</span><br>    ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION,&amp;amp;mem);<br>    <span class="hljs-comment">//创建vCPU</span><br>    <span class="hljs-type">int</span> vcpufd = ioctl(vmfd,KVM_CREATE_VCPU,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//每一个vCPU都有一个struct kvm_run的结构，用来在用户态(qemu)和内核态(kvm)之间共享数据。</span><br>    <span class="hljs-comment">//用户态需要将这段空间映射到用户空间</span><br>    <span class="hljs-type">int</span> mmap_size = ioctl(kvmfd, KVM_GET_VCPU_MMAP_SIZE, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_run</span> *<span class="hljs-title">run</span> =</span> mmap(<span class="hljs-literal">NULL</span>,mmap_size, PROT_READ PROT_WRITE,MAP_SHARED,vcpufd, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//设置VCPU相关的寄存器，sregs存放的如段寄存器、控制寄存器等特殊寄存器。</span><br>    ret = ioctl(vcpufd, KVM_GET_SREGS, &amp;amp;sregs);<br>    <span class="hljs-comment">//设置代码段其实地址为0，</span><br>    sregs.cs.base = <span class="hljs-number">0</span>;<br>    sregs.cs.selector = <span class="hljs-number">0</span>;<br>    ret = ioctl(vcpufd,KVM_SET_SREGS, &amp;amp;sregs);<br>    <span class="hljs-comment">//设置通用寄存器，如指令指针寄存器为0，这样就直接从精简内核第一行代码开始执行</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_regs</span> <span class="hljs-title">regs</span> =</span>&#123;<br>        .rip =<span class="hljs-number">0</span>,<br>    &#125;;<br>    ret = ioctl(vcpufd,KVM_SET_REGS, &amp;amp;regs);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">//将VCPU调度到物理CPU上运行</span><br>        ret = ioctl(vcpufd, KVM_RUN, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>( ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(&amp;quot;<span class="hljs-built_in">exit</span> unknown\n&amp;quot;);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">//在VCPU运行过程中遇到敏感指令会退出，KVM不能处理会交给用户态的Qemu处理，此时ioctl系统调用就会返回，并且将一些信息保存到kvm_run结构中</span><br>        <span class="hljs-comment">//这样用户程序就可以分析虚拟机退出的原因，然后根据原因进行处理。</span><br>        <span class="hljs-keyword">switch</span> (run-&amp;gt;exit_reason)&#123;<br>            <span class="hljs-comment">//本例中，精简内核执行hlt会产生KVM_EXIT_HLT推出事件。</span><br>            <span class="hljs-keyword">case</span> KVM_EXIT_HLT:<br>                <span class="hljs-built_in">puts</span>(&amp;quot;KVM_EXIT_HLT&amp;quot;);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">case</span> KVM_EXIT_IO:<br>                <span class="hljs-built_in">putchar</span>(*(((<span class="hljs-type">char</span> *)run)+run-&amp;gt;io.data_offset));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> KVM_EXIT_FAIL_ENTRY:<br>                <span class="hljs-built_in">puts</span>(&amp;quot;entry error&amp;quot;);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">puts</span>(&amp;quot;other error&amp;quot;);<br>                <span class="hljs-built_in">printf</span>(&amp;quot;exit_reason: %dln&amp;quot;, run-&amp;gt;exit_reason);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@test-ubuntu-no-vgpu:~# gcc qemu.c -o light-qemu<br>root@test-ubuntu-no-vgpu:~# ./light-qemu<br>SCU HELLO<br>KVM_EXIT_HLT<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由上述代码可以看出，KVM通过一组ioctl系统调用，向用户空间暴露了接口，这些接口用于创建虚拟机、设置内存、创建VCPU，调度运行等。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>QEMU&#x2F;KVM源码解析与应用-李强</li></ul>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CARSI 教育网联邦认证和资源共享服务</title>
    <link href="/0014.html"/>
    <url>/0014.html</url>
    
    <content type="html"><![CDATA[<h1 id="CARSI-教育网联邦认证和资源共享服务"><a href="#CARSI-教育网联邦认证和资源共享服务" class="headerlink" title="CARSI 教育网联邦认证和资源共享服务"></a>CARSI 教育网联邦认证和资源共享服务</h1><p>之前在超星实习的时候，有帮助一些高校，接入CARSI认证，今天在查论文的时候，发现很多资源提供商也接入了CARSI，我们只需要登录自己学校的统一身份认证账户和密码，就可以方便的访问各个资源网站，不需要重新登录以及注册。当时也没有深究，现在我来看看这个是怎么实现的。</p><h2 id="CARSI-简介"><a href="#CARSI-简介" class="headerlink" title="CARSI 简介"></a>CARSI 简介</h2><p>官网：<a href="https://www.carsi.edu.cn/">https://www.carsi.edu.cn/</a></p><h3 id="什么是CARSI？"><a href="#什么是CARSI？" class="headerlink" title="什么是CARSI？"></a><strong>什么是CARSI？</strong></h3><p>官网解释：CARSI （CERNET Authentication and Resource Sharing Infrastructure）教育网联邦认证和资源共享服务，2008年12月由北京大学计算中心发起建设，在国内高校已经普遍建设完成的<strong>校园网统一用户管理和身份认证系统</strong>基础上，面向中国高校和科研机构提供跨域身份认证和资源共享服务。</p><h3 id="如何访问CARSI资源？"><a href="#如何访问CARSI资源？" class="headerlink" title="如何访问CARSI资源？"></a><strong>如何访问CARSI资源？</strong></h3><p>任何人（已经加入CARSI的高校校园网用户）、任何时间（白天、晚上、平时、节假日）、任何地点（学校、家里、出差路上、野外）、任何联网形式（手机4G、咖啡店Wi-Fi）、访问线下已经获取权限的应用系统&#x2F;服务。比如：学校购买某个学术数据库后，在校外无需连接校内VPN，直接通过Shibboleth方式就可以访问该学术数据库。 就拿超星数据库举例，当学校购买了超星的数据库后，超星和学校都已经接入CASRI，那么当学生访问超星网站时，超星需要提供对应的CARSI登录入口，如下图： <img src="/wp-content/uploads/2023/05/image-20230327175500458.png" alt="image-20230327175500458.png"> 从这个入口进入，就可以找到该学校的入口，登录后即可访问超星数据库资源。</p><h3 id="什么是Shibboleth？"><a href="#什么是Shibboleth？" class="headerlink" title="什么是Shibboleth？"></a>什么是Shibboleth？</h3><p>Shibboleth 是一种基于开放标准的身份认证和授权系统，旨在为各种类型的应用程序提供安全的、单点登录（Single Sign-On，SSO）的访问控制。Shibboleth 的设计理念是“分离身份认证和授权”，它采用了基于属性的访问控制（Attribute-Based Access Control，ABAC）模型，可以将用户身份和属性信息传递给不同的应用程序，从而实现对应用程序的不同资源和服务的访问控制。 Shibboleth作为开源软件开发，在Apache 软件许可证下发布。关于个别部件的更多信息详见官方网站。 参考链接：<a href="https://www.shibboleth.net/index/">https://www.shibboleth.net/index/</a></p><h2 id="CARSI的角色"><a href="#CARSI的角色" class="headerlink" title="CARSI的角色"></a>CARSI的角色</h2><ul><li>身份提供者（IdP，Identity Provider）：主要就是各个高校，从CARSI的官网可以看出，他负责提供Web单点登录功能，对用户进行身份认证并向服务提供商（SP，Service Provider）提供身份数据</li><li>服务提供商（SP，Service Provider）：主要是提供各种资源，在idp的用户（例如学生）经过身份认证后，支持用户访问某些限制访问的资源，比如图书馆资源，数据库访问权限等。</li></ul><h2 id="单点登录认证流程"><a href="#单点登录认证流程" class="headerlink" title="单点登录认证流程"></a>单点登录认证流程</h2><p>在 CASRI 系统中，一个 IdP（Identity Provider，身份提供者）用户访问 SP（Service Provider，服务提供者）服务的流程如下：</p><ol><li><ol><li><ol><li><ol><li>用户通过 IdP 登录，向 IdP 提供用户名和密码等凭证信息进行身份验证。</li></ol></li><li><p>IdP 通过 CAS（Central Authentication Service，中央认证服务）或 SAML（Security Assertion Markup Language，安全断言标记语言）等协议向 SP 发送身份认证请求。</p></li><li><p>SP 接收到身份认证请求后，通过 SAML 协议向 IdP 发送身份认证响应，包含认证成功的信息和用户的属性信息。</p></li><li><p>SP 在接收到身份认证响应后，根据用户属性信息进行资源访问控制，决定是否授权用户访问所请求的服务资源。</p></li><li><p>如果用户被授权访问服务资源，则 SP 提供所请求的服务资源给用户。</p></li></ol><p>总之，CASRI 系统采用了基于 SAML 协议的身份认证和授权机制，实现了单点登录和资源访问控制的功能，可以确保用户访问资源的安全性和可靠性。 <img src="/wp-content/uploads/2023/05/image-20230327181216015.png" alt="image-20230327181216015.png">可以查看：<a href="/wp-content/uploads/2023/05/1-CARSI%E6%9C%8D%E5%8A%A1%E5%8F%8AShibboleth%E7%AE%80%E4%BB%8B.pdf">1-CARSI服务及Shibboleth简介.pdf</a></p><h2 id="那为什么我们可以访问类似IEEE他们这些国外的网站呢？eduGAIN"><a href="#那为什么我们可以访问类似IEEE他们这些国外的网站呢？eduGAIN" class="headerlink" title="那为什么我们可以访问类似IEEE他们这些国外的网站呢？eduGAIN"></a>那为什么我们可以访问类似IEEE他们这些国外的网站呢？eduGAIN</h2><h3 id="什么是eduGAIN？"><a href="#什么是eduGAIN？" class="headerlink" title="什么是eduGAIN？"></a>什么是eduGAIN？</h3><p>eduGAIN是由欧盟发起的全球身份认证联盟，整合各个国家教育科研网已经建设的<strong>国家级身份认证联盟</strong>，实现全球教育科研资源共享。它是欧洲教育网GEANT项目开发的网络服务之一，目标是在促进欧盟和欧洲各国NREN（National Research and Education Network）合作的同时，实现世界各地身份联盟的互联，简化全球教育科研资源的共享和访问。eduGAIN的成员机构用户只需要提供一个可信的身份，使用本机构的SSO（Single Sign On，单点登录）账号即可方便地访问所有联盟成员的资源。 2019年5月，CARSI联盟加入eduGAIN，成为full member。CARSI成功加入全球身份联盟eduGAIN，为<strong>国外资源提供商</strong>在疫情防控期间快速面向中国高校师生提供服务奠定了技术基础，并有效支撑了国外资源的快速部署和国内资源的快速推进。</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CARSI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次jenkins修改root权限的问题</title>
    <link href="/0034.html"/>
    <url>/0034.html</url>
    
    <content type="html"><![CDATA[<h1 id="记一次jenkins修改root权限的问题"><a href="#记一次jenkins修改root权限的问题" class="headerlink" title="记一次jenkins修改root权限的问题"></a>记一次jenkins修改root权限的问题</h1><p>有时候jenkins执行脚本会说权限不够，于是想着直接给他root权限吧。 网上很多博客，很多都说改 <code>vim /etc/sysconfig/jenkins</code></p><ul><li>修改 <code>JENKINS_USER=&quot;root&quot;</code></li><li>然后修改三个文件路径的权限分别是<code>/var/lib/jenkins</code>、<code>/var/cache/jenkins</code> 、<code>/var/log/jenkins</code></li></ul><p>但是依然不行，包括该端口也不行。 最后发现需要改下面这个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /usr/lib/systemd/system/jenkins.service<br></code></pre></td></tr></table></figure><p>修改其中的用户和用户组为<code>root</code> ，即可。   还有修改端口，在配置文件中修改同样无效，甚至会导致jenkins启动失败，启动卡住，可以参考：<a href="https://blog.csdn.net/Lifereunion/article/details/123430619">Jenkins : jenkins 修改端口问题 （已解决）_jenkins 端口_ZC~Reunion的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Halo joe2.0 文章嵌入pdf 解决跨域问题-腾讯云对象存储</title>
    <link href="/0033.html"/>
    <url>/0033.html</url>
    
    <content type="html"><![CDATA[<hr><h1 id="在文章中预览pdf文件"><a href="#在文章中预览pdf文件" class="headerlink" title="在文章中预览pdf文件"></a><strong>在文章中预览pdf文件</strong></h1><p>版本情况：</p><ul><li>halo 1.5.3</li><li>joe 2.0</li><li>pdf附件位置：腾讯云对象存储</li></ul><p>主题仓库：<a href="https://github.com/qinhua/halo-theme-joe2.0">https://github.com/qinhua/halo-theme-joe2.0</a></p><blockquote><p>该主题已集成 PDF.js，可以渲染 pdf 文件，只需要在编辑文章时使用 joe-pdf 标签插入即可（切记前后要空一行），它接受如下属性：</p></blockquote><ul><li>src：PDF 文件地址（必传），不要过长，且不能包含 &amp;、? 等特殊字符</li><li>width：阅读器宽度，默认为 100%</li><li>height：阅读器高度，默认 500px</li></ul><p><code>&lt;joe-pdf src=&quot;https://xxx.pdf&quot; width=&quot;100%&quot; height=&quot;500px&quot;&gt;&lt;/joe-pdf&gt;</code> 使用这个标签可能会出现跨域问题，我用的是腾讯云对象存储。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h1><p>使用这个标签出现的跨域问题，需要<strong>存储pdf的位置支持跨域</strong>，例如我在腾讯云对象存储存放的该pdf文件。 我需要进入腾讯云对象存储列表管理中，添加跨域规则。以本站为例： <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653622529224.png" alt="image-1653622529224"> 这样就可解决跨域问题。</p>]]></content>
    
    
    <categories>
      
      <category>好用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>halo2.0</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程证明_07_安全即服务:具有策略定制的可信云服务架构</title>
    <link href="/0007.html"/>
    <url>/0007.html</url>
    
    <content type="html"><![CDATA[<h1 id="原文信息"><a href="#原文信息" class="headerlink" title="原文信息"></a><strong>原文信息</strong></h1><ol><li>文章标题：Toward security as a service: A trusted cloud service architecture with policy customization</li><li>文章中文翻译：安全即服务:具有策略定制的可信云服务架构</li><li>文章等级：CCF B</li><li>文章发表时间：2021</li><li>文章作者：De Oliveira Nunes I, Jakkamsetti S, Rattanavipanon N, et al.</li><li>完整引用：De Oliveira Nunes I, Jakkamsetti S, Rattanavipanon N, et al. On the TOCTOU problem in remote attestation[C]&#x2F;&#x2F;Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security. 2021: 2921-2936.</li><li>全文请查看：<a href="https://dl.acm.org/doi/pdf/10.1145/3460120.3484532">全文链接</a></li></ol><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h1><p>随着对云的安全性和私密性的关注，“安全随需应变”服务模式根据云客户的特定安全需求，动态地为其提供可信的计算环境。然而，实现这一目标仍然面临着重大挑战:(1)将可审计的、抗篡改的信任管理机制集成到云基础设施中;(2)构建协议以保证虚拟机(VM)迁移期间客户策略的一致性。本研究开发了一种新的安全按需框架，称为“策略自定义可信云服务”(PC-TCS)架构，由两个核心组件组成:基于属性签名(ABS)的远程认证方案，通过定制安全策略实现可信远程认证;基于ABS和区块链的虚拟机迁移协议，支持策略自定义可信迁移。为了证明该体系结构的有效性，我们实现了一个基于Xen Hypervisor的PC-TCS原型，结果表明:(1)PC-TCS可以作为可信计算基础的一部分集成到云基础设施中;(2)云用户可在PC-TCS支持下定制计算环境安全策略，并在整个服务生命周期内验证其实施;(3) PC-TCS可以支持策略自定义的远程认证和策略自定义的迁移，对性能的影响最小。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a><strong>1 介绍</strong></h1><p>越来越多的公司和个人正在将他们的数据和计算迁移到云上，以利用其按需使用的特性[20,24]。不幸的是，这种便利的代价是失去对数据和计算环境的控制，这导致了安全事件，限制了云服务的广泛采用和接受[33,36]。安全随需应变服务(security- demand service，简称[17])是针对云客户的特定安全需求，动态地为其提供可信的计算环境。 云客户的安全需求是对应于不同应用环境的各种安全属性，是与云服务主体和对象安全相关的约束或配置。典型的安全属性包括访问者身份、提供者信任级别、操作系统安全性、数据中心位置等。云客户的安全属性需求构成了云客户的安全策略。安全的计算环境与可靠的服务提供者和安全、可信的云基础设施有关。到目前为止，云基础设施中还没有任何标准化的、可审计的、防篡改的信任管理机制供客户评估服务提供商、虚拟机和物理主机。 然而，安全计算平台的可用性只是说服云客户将他们的敏感数据和代码转移到云[48]的必要而不是充分的解决方案。云客户往往需要进一步的保证，以使他们相信安全措施确实部署了，并且工作正常。 新的密码算法和机制的发展使这个问题有了新的解决方案。例如，牛津myTrustedCloud项目[39]和策略密封的数据抽象[34]开辟了构建可信云服务的新途径。属性加密(Attribute-based encryption, ABE)通过密钥策略属性加密(key-policy Attribute-based encryption, KP-ABE)[47]，密文策略属性加密(CP-ABE)[5,13,44]和属性签名(Attribute-based signature, ABSs)[16,26,35]保护数据和安全策略。完全同态加密保证了数据所有者的隐私，并支持多方计算[11,23]。区块链技术以其可审计性、可追溯性和不可抵赖性在云安全中被用于审计、计费、数据共享等领域[2,22,43]。然而，到目前为止，这仍然是一个有待学者和开发人员探索的开放问题。 综上所述，实现安全随需应变的目标仍面临重大挑战:(1)将可审计的、抗篡改的信任管理机制集成到云基础设施中;(2)构建协议以保证虚拟机(VM)迁移期间客户策略的一致性。 在本文中，我们将区块链技术和ABS引入到我们之前在[13]中使用ABE进行远程认证的工作中，提出了一种基于ABS和区块链的策略定制可信云服务(PC-TCS)体系结构，ABS的匿名性和不可追踪性优于KP-ABE和CP-ABE，更适合云计算。云客户可以自定义计算环境的安全策略，通过ABS验证是否满足安全策略，在PC-TCS中通过区块链技术对整个VM生命周期内云服务提供商的行为和信誉进行审计，主要集中在以下三个方面：</p><ul><li>可用性：云客户可以自定义计算环境的安全策略，云提供商可以对不同安全级别的虚拟机和物理服务器进行分区和配置。云客户可以在可信的云基础设施的支持下，自定义和强制执行计算环境的安全属性，如中央处理器(CPU)、内存、磁盘、服务提供商信任级别、操作系统安全、数据中心位置等。</li><li>可信性：云客户可以验证当前的计算环境是否满足定制的安全策略。云基础设施中需要一种可审计的、抗篡改的信任管理机制。同时也要考虑到双方的隐私，云平台的具体配置或属性不能在认证阶段过度暴露。</li><li>一致性：虚拟机迁移操作满足客户的安全策略要求。与物理机器不同，虚拟机可能会在物理节点之间迁移，改变物理主机和虚拟机，并可能破坏计算环境的安全属性。因此，为了保证客户在虚拟机迁移过程中策略的一致性，需要建立可信的虚拟机迁移协议。</li></ul><p><strong>为了实现第一个目标</strong>，我们在PC-CTS中引入了定制化的安全策略，将用户的安全期望与云服务的安全属性联系起来。PC-TCS通过增加接口，为云客户定制安全策略。通过改进虚拟机调度器，支持安全策略与虚拟机的匹配，以及基于安全策略的部署。ABSs增强了可信计算技术[27]的核心——远程认证机制，成为将可信计算机制集成到云计算体系结构中的有效方案，为云客户提供远程验证云服务可靠性的能力[34,39]。它们还减少了当前远程认证机制中的信息泄漏，如平台配置信息和属性信息。 <strong>为了实现第二个目标</strong>，我们在远程认证领域引入了ABSs和区块链机制，这样客户就可以通过验证计算环境的属性签名来评估云服务的可信性。同时，所有客户的安全政策和服务提供商的行为都会在区块链的生命周期内进行审计，以便在此基础上建立声誉系统。然而，客户在认证阶段能够获得的信息仅是当前计算环境的安全属性是否满足其自定义安全策略。当自定义安全策略或物理节点的安全属性发生变化时，或者由于负载均衡的原因导致虚拟机迁移。虚拟机迁移操作对客户是透明的，特别是实时迁移。现有的虚拟机迁移认证由云管理员进行，其可信性无法满足客户的需求。 <strong>为了实现第三个目标</strong>，我们提出了一个vm迁移协议，它支持定制的迁移策略和迁移认证。为了证明PC-TCS架构的可用性，我们设计并实现了一个原型，该原型支持定制的安全策略和VM-migration协议，该协议支持定制的迁移策略和基于开源Xen Hypervisor的验证。我们通过实验对迁移延迟进行了评估，结果表明，该认证方案在保持客户安全需求的同时，不会明显降低虚拟机迁移性能。 本文的主要贡献如下:</p><ul><li>PC-TCS体系结构，支持定制的安全策略和远程认证;</li><li>支持定制安全策略的远程认证方案;</li><li>支持定制迁移策略的虚拟机迁移协议;</li><li>开源Xen Hypervisor中远程认证和虚拟机迁移协议的原型实现。</li></ul><p>我们的实现和实验结果表明:(1)PC-TCS可以作为可信计算基础的一部分集成到云基础设施中;(2)云用户可在PC-TCS支持下定制计算环境安全策略，并在整个服务生命周期内验证其实施;(3) PC-TCS可以支持策略自定义的远程认证和策略自定义的迁移，对性能的影响最小。 本文的其余部分组织如下。第2节介绍了远程认证和ABS的背景，第3节介绍了PC-TCS体系结构。第4节描述了PC-TCS体系结构的实现。第5节介绍安全性和初步性能。最后，第六部分总结并指出了未来研究的重点。</p><h1 id="2-背景及相关工作"><a href="#2-背景及相关工作" class="headerlink" title="2 背景及相关工作"></a><strong>2 背景及相关工作</strong></h1><h2 id="2-1-远程证明"><a href="#2-1-远程证明" class="headerlink" title="2.1 远程证明"></a><strong>2.1 远程证明</strong></h2><p>云服务提供商的成功取决于客户是否愿意将自己的数据委托给云服务。加强客户信任的一个关键因素是提供云基础设施完整性的强有力保证。可信计算技术可以在提供这些保证方面发挥基本作用。为此，它为云客户提供了“远程验证”的能力，这被定义为允许远程客户根据其完整性哈希测量测试目标系统的完整性。 基于TPM (Trusted platform module)的认证是由TCG (Trusted Computing Group)提出的，可以验证远程服务器平台的完整性。目标服务器使用TPM来计算平台配置的二进制散列值，并将它们发送给客户。客户将这些值与参考配置进行比较(可能通过可信的第三方评估器)，并确定平台的状态是否未被修改(良好)。在虚拟化平台环境中，虚拟可信平台模块(vTPM)[28]被设计用于向vm提供与硬件TPM相同的使用模型和服务，允许通过vTPM实例直接在客户和他们的vm之间进行远程认证。然而，基于vtpm的认证[12,21,40]可能会过度暴露云平台的特定配置，从而产生安全问题。 理论上，基于属性的认证是为了验证系统[31]的各种属性、功能和行为。它引入了一个可信的第三方来将平台的安全度量转换为属性，反之亦然，并确定平台的条件是否满足一组给定的属性。但是，基于属性的认证不支持客户的自定义安全策略。本文通过引入ABSs来解决这些问题，它使客户能够定义一组安全属性，并且不会过度暴露属性信息。</p><h2 id="2-2-基于属性的加密和区块链"><a href="#2-2-基于属性的加密和区块链" class="headerlink" title="2.2 基于属性的加密和区块链"></a><strong>2.2 基于属性的加密和区块链</strong></h2><p>ABE最初由Sahai和Waters[32]提出，是实现细粒度访问控制和高效加密数据共享[10]的一种有用的密码原语。区块链是日本学者中本聪在2008年创立的开源项目“比特币”中开发出来的，其价值远远超过了比特币。区块链技术具有去中心化、安全性和信任等优点，已被广泛应用于[1]应用中。由于ABE和区块链技术的优点，许多人将它们结合起来，以增强它们的优点，克服它们的缺陷。在[45]中，将区块链技术与ABE方案相结合，既保证了数据的完整性和不可否认性，又实现了密文的快速生成和属性不可见性。在[30]中，将区块链和CP-ABE加密技术结合在并行市场和假冒问题上，帮助中小企业保护自己的品牌。reference .[14]提出了一个基于私有-公共区块链方法的ABE安全解决方案，以解决对私有区块链解决方案的过度依赖和公共块解决方案的利用不足。其他研究人员利用ABE方案和区块链技术实现了细粒度的访问控制，增强了物联网[29]、云计算[18,37,46]、电子健康记录[19,42]、自动驾驶汽车[4]和大数据[6,7,41]中的可追溯性和可视性。</p><h2 id="2-3-基于属性的签名Attribute-based-signatures"><a href="#2-3-基于属性的签名Attribute-based-signatures" class="headerlink" title="2.3 基于属性的签名Attribute-based signatures"></a><strong>2.3 基于属性的签名Attribute-based signatures</strong></h2><p>ABS是一种通用原语，它允许一方对标识信息[25]进行细粒度控制来签名消息。在ABS中，拥有来自某个机构的一组属性的签名者可以用该机构属性所满足的谓词对消息进行签名。签名只显示一个签名者用户，其某些属性满足谓词和关于签名者的任何标识信息。图1给出了多属性权威的通用ABS结构。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655637630001.png" alt="image-1655637630001"></p><blockquote><p>图1所示。基于属性的签名(ABS)构造。属性权威(aa)监督属性集和私钥之间的转换，以签署消息。证明者可以通过使用私钥签署消息来证明自己(即满足挑战者的策略)。挑战者可以通过验证签名来验证验证方是否满足策略。</p></blockquote><p>ABS的构建涉及四个实体:注册中心、挑战者、验证者和属性权威(AA)。在ABS构建方案中，注册中心是受信任的管理器。AAs监督属性集和私钥之间的转换以签署消息。验证者可以通过使用私钥签署消息来证明自己(即满足挑战者的策略)。挑战者可以通过验证签名来验证验证方是否满足策略。ABS的构建包括系统初始化和签名两个阶段。 <strong>第一阶段:系统初始化</strong> (1)注册中心运行ABS.RSetup算法，输出一对密钥(PK, RSK); $$(PK, RSK ) ← ABS.RSetup$$ (2) AA运行ABS.ASetup算法，分别输出一对密钥(APKi、ASKi); $$(APK_i, ASK_i) ← ASetup$$ (3)挑战者向注册中心发送唯一标识ID; (4)注册中心运行ABS.Register算法，输出唯一的token τ; $$τ ← TRegister(id, TSK )$$ (5)验证方发送待应用于对应AA的属性µ; (6) AA接收到属性µ后，运行ABS.AttrGen算法，输出私钥Kµ; $$K_µ ← AttrGen(ASK, τ , µ)$$ <strong>第二阶段:签名</strong> (7)挑战者生成一个nonce和policy Υ，发送给验证者; (8)验证者运行ABS.Sign功能，输出签名σ，发送给挑战者; $$σ←Sign(PK, APK_i, K_µ，nonce， σ)$$ (9)挑战者运行 ABS.Verify 功能，接收到签名σ后输出签名是否有效; $$Y&#x2F;N ← Verify(PK, APK_i, nonce, Υ , σ )$$</p><h1 id="3-策略自定义可信云服务-PC-TCS-架构"><a href="#3-策略自定义可信云服务-PC-TCS-架构" class="headerlink" title="3 策略自定义可信云服务(PC-TCS)架构"></a><strong>3 策略自定义可信云服务(PC-TCS)架构</strong></h1><p>在本节中，我们将介绍PC-TCS体系结构。首先，3.1节讨论了PC-TCS的威胁模型。第二，3.2部分通过分析涉及的实体及其之间的关系概述了体系结构。第三，VM生命周期中的三个关键操作说明了PC-TCS的细节:初始VM部署、客户认证和VM迁移。 第3.3节说明了初始VM部署。第3.4节介绍了云客户进行远程认证的过程，以及提出的策略定制的远程认证(PC-RA)协议。虚拟机迁移和策略自定义虚拟机迁移协议请参见3.5节。最后，第3.6节展示了客户如何从区块链审计员的信任管理中获益。</p><h2 id="3-1-威胁模型"><a href="#3-1-威胁模型" class="headerlink" title="3.1 威胁模型"></a><strong>3.1 威胁模型</strong></h2><p>威胁模型是运行在同一云服务器上的恶意虚拟机或运行在虚拟机内部的恶意应用程序或服务，以破坏其数据或代码的保密性或完整性。它们还可能试图破坏其可用性，尽管云提供商已将其请求的资源分配给VM。我们假设云管理器、注册中心和AA是可信的，因为它们是通过安全的启动正确实现的，并且在运行时受到保护。但是，除了每个服务器中的TPM硬件和vTPM外，服务器集群不需要被信任。请注意，受信任的服务器、云管理器和AA可以通过冗余保护来保证可靠性和安全性，它们只占云数据中心所有服务器的一小部分。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655637671553.png" alt="image-1655637671553"> 表1显示了云服务的可能对手，它们利用两个维度来利用云服务。一种是计算环境的类型，包括VM、服务器和云。每个人都可能成为被剥削的目标。另一个维度是每个计算环境中受到威胁的对象。在VM级别，对手可以危害应用程序、其他应用程序，甚至操作系统。在服务器层，完全控制VM的对手可以在逃离VM后进一步利用其他VM和VMM (Virtual Machine Monitor)，甚至攻击同一服务器中的硬件。在云级别上，如果云基础设施受到威胁，对手可以威胁云管理器、同一云中的其他服务器，甚至云之外的实体。 我们关注两种类型的对抗能力：</p><ul><li>(1)利用客户虚拟机中的漏洞，无论是来自虚拟机内部还是来自同一服务器上的其他恶意虚拟机：</li><li>(2)完全控制不同服务器之间的网络，如标准的Dolev-Yao威胁模型[3]。</li></ul><p>在后一种情况下，对手可以窃听和伪造认证消息，向客户发送伪造的认证报告，而客户没有发现任何可疑的东西。</p><h2 id="3-2-体系结构概述"><a href="#3-2-体系结构概述" class="headerlink" title="3.2 体系结构概述"></a><strong>3.2 体系结构概述</strong></h2><p>PC-TCS旨在保证客户安全策略的可用性、可靠性和一致性。如图2所示，PC-TCS的架构基于IaaS云计算范式，将虚拟机出租给云客户。这包括6个实体:云客户、云管理器、注册中心、AA、服务器集群和区块链审计器。注册表和AA的存在是为了构造ABS方案。</p><ul><li>云客户：云客户可自定义计算环境的安全策略和物理资源需求，然后向云管理器申请，实现物理资源和安全的双重需求。客户请求被记录在区块链审计器中，客户可以通过访问区块链审计器中的信任管理模块来监督整个过程。</li><li>云管理器：云管理器相当于云管理员；也就是说，它们负责处理来自云客户的请求。策略验证模块根据客户请求选择合适的VM和物理节点来构建计算环境。计算环境应同时满足物理资源和安全性的要求。部署模块将选定的虚拟机部署在物理服务器上，然后启动虚拟机。在适当的服务器上部署VM之后，每个部署的VM都进入一个安全生命周期。云管理器的每个操作都要求记录在区块链审计器中，并且可以在区块链审计器中访问服务器的可信性和历史记录。</li><li>属性权威：AAs是ABS构建的组成部分，它将服务器和虚拟机的测量值转换为定义良好、有意义的安全属性信息。首先，提供属性信息供策略验证模块检索。其次，将属性信息转换为签名私钥，并反馈给服务器或VM。注意，TPM可以提供硬件和管理程序的测量值，vTPM可以提供整个计算环境的测量值，其中包括硬件、管理程序和VM。</li><li>注册中心（registry）：注册中心是ABS构建的一部分。它接收来自服务器和VM的注册。</li><li>服务器集群：每台服务器基于可信任的云架构，TPM。每个虚拟机都基于vTPM的可信计算架构。改进后的vTPM还提供了定制安全策略的接口，包括客户认证和虚拟机迁移认证。改进后的vTPM可以保证定制安全策略的保密性和完整性。服务器集群的每个操作都被请求记录在区块链审计器中，并且每个服务器或VM的可信性和历史都可以在区块链审计器中访问。</li><li>区块链auditor：区块链auditor用于审计PT-CTS中的所有操作，管理所有实体的可信性，包括一个审计模块和一个信任管理模块。审计模块为每个用户的请求保留一个操作链，记录所有相关实体的不可否认日志。信任管理模块支持从统计历史记录中查询每个操作的过程和每个实体的信誉。</li></ul><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655637793567.png" alt="image-1655637793567"></p><blockquote><p>图2所示。策略定制可信云服务(PC-TCS)架构概述。PC-TCS基于IaaS云计算范式，在这种范式中，虚拟机出租给云客户。PC-TCS包括6个实体:云客户、云管理器、注册中心、AA、服务器集群和区块链审计器。注册表和AA的存在是为了构造ABS方案。</p></blockquote><h2 id="3-3-初始部署"><a href="#3-3-初始部署" class="headerlink" title="3.3 初始部署"></a><strong>3.3 初始部署</strong></h2><p>如图3所示，初始部署包括三个阶段。(1)注册表和AA初始化，就像在ABS构造中一样。(2) AA收集各服务器基于TPM的测量值，并转换为签名密钥。签名密钥反馈到对应的服务器。(3)当云客户首次请求VM时，云管理器会构建一个合适的计算环境和一个安全策略，该策略定义了VM请求的期望安全级别。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655638286531.png" alt="image-1655638286531"></p><blockquote><p>图3所示。初始化部署分为三个阶段:(1)在初始化阶段，注册表和AA初始化;(2)在属性授权阶段，AA收集每个服务器基于tp的测量值并转换为签名密钥，然后将签名密钥反馈给相应的服务器;(3)在VM部署阶段，当云客户首次请求VM时，云管理器构建一个合适的计算环境和一个安全策略，该策略定义了VM请求的期望安全级别。</p></blockquote><p>第一阶段:初始阶段</p><ul><li>(1)注册中心运行ABS.RSetup算法，输出一对密钥(PK, RSK);</li><li>(2) AA运行ABS.ASetup算法，输出一对密钥(APKi, ASKi)。</li></ul><p>第二阶段:属性授权</p><ul><li>(3)服务器向注册中心发送唯一标识vID;</li><li>(4)注册中心运行ABS.Register算法，将唯一的token τ输出到对应的服务器;</li><li>(5)服务器将由TPM通过AIK签名的平台配置寄存器(PCR)值、存储测量日志(SML)和token τ发送给每个AA;</li><li>(6)每个AA首先通过PCR值验证SML的完整性，将SML中的测量值转换为属性信息，根据通用标准将属性信息转换为评估值µ，运行ABS.AttrGen算法，输出私钥Kµ，最后通过基于TPM的密封功能将Kµ与PCR值绑定，根据通用标准输出加密的密钥值µ，运行ABS.AttrGen算法。将私钥EKµ输出到对应的服务器;</li><li>(7) AA将每个服务器的属性评估值发送给云管理器中的策略验证模块。</li></ul><p>第三阶段:VM部署</p><ul><li>(8)云客户根据定制的物理资源需求和安全策略请求VM，并在区块链审计员中记录请求;</li><li>(9)策略验证模块选择合适的VM和服务器构建计算环境，分配定制的物理资源，最终启动计算环境。云管理器的所有操作都同步记录在区块链审计器中。</li></ul><p>虚拟机部署在适当的服务器上，每个部署的虚拟机都进入一个安全生命周期，支持来自云客户的基于 vTPM 的证明。</p><h2 id="3-4-策略定制的远程证明"><a href="#3-4-策略定制的远程证明" class="headerlink" title="3.4 策略定制的远程证明"></a><strong>3.4 策略定制的远程证明</strong></h2><p>为了在远程认证中实现客户定制策略，我们提出了策略定制远程认证(policy-customized remote authentication, PC-RA)，如图4所示。我们假设云客户已经定义了存储在vtpm中的安全策略，这些策略可以保证vtpm的完整性。PC-RA由两个阶段组成：(1)AA会收集每个虚拟机基于vtpm的测量值，然后将属性签名密钥反馈给对应的虚拟机；(2)虚拟机验证当前的计算环境满足客户定制的策略。第一阶段发生在VM的启动阶段。第二个阶段由云客户在vm运行阶段启动。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655638214976.png" alt="image-1655638214976"></p><blockquote><p>图4所示。策略自定义远程认证(PC-RA)。PC-RA由两个阶段组成:(1)在属性授权阶段，AA收集每个VM基于vtpm的测量值，然后将属性签名密钥反馈给对应的VM;(2)在验证-实现阶段，虚拟机证明当前的计算环境满足客户定制的策略。</p></blockquote><p>第一阶段：属性授权</p><ul><li>(1)VM向注册中心发送唯一标识vID;</li><li>(2)注册中心运行ABS.Register算法，将唯一的token τ输出到对应的VM;</li><li>(3) VM将vAIK、SML和token τ签名的vTPM的PCR值发送给每个AA;</li><li>(4)每个AA首先通过PCR值验证SML的完整性，将SML中的测量值转换为属性信息，根据通用标准将属性信息转换为评估值µ，运行ABS.AttrGen算法，输出私钥Kµ，最后通过基于vtpm的密封功能将Kµ与PCR值绑定，输出加密后的密钥EKµ到VM。</li></ul><p>第二阶段：认证实施</p><ul><li>(5)云客户发起认证；</li><li>(6)首先，VM 通过基于 vTPM 的 unseal 函数将 EKµ 与当前 PCR 值解除绑定，如果 PCR 值没有变化，则输出 Kµ，然后 VM 在 vTPM 中运行 ABS.Sign 算法，该算法输出签名 σ 并馈送签名 σ 返回给云客户。 最后，客户运行 ABS.Verify 算法来验证签名 σ，其输出结果“是”或“否”。</li></ul><p>与传统的TPM 2.0远程认证相比，PC-RA有两个优点:一是通过对PCR值进行ABS加密，避免了远程认证过程中平台配置的泄露；二是支持PCR值以外的复杂属性信息的认证，如安全配置等。</p><h2 id="3-5-策略定制的迁移协议"><a href="#3-5-策略定制的迁移协议" class="headerlink" title="3.5 策略定制的迁移协议"></a><strong>3.5 策略定制的迁移协议</strong></h2><p>与物理机不同，基于 vTPM 的 VM 可以在物理节点之间迁移。现有的基于 vTPM 的 VM 迁移方案通常由云管理员采用基于 TPM 的远程证明，如第 2.1 节所述，因为 VM 迁移对云用户是透明的。这引发了云用户对虚拟机迁移是否符合定制策略的担忧。为了保证VM迁移的可信度，我们提出了一种策略定制迁移协议（PC-MP），如图5所示。迁移协议发生在以下几个阶段：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655638247201.png" alt="image-1655638247201"></p><blockquote><p>图5所示。策略定制迁移协议(Policy-customized migration protocol, PC-MP)。为了保证虚拟机迁移的可靠性，提出了PC-MP算法。当客户虚拟机接收到迁移请求时，会通过ABS检查目标服务器的可靠性，只有在验证目标服务器的安全属性完全满足客户虚拟机的安全请求时，才允许迁移。</p></blockquote><ul><li>(1)源服务器从云管理器（Cloud Manager）接收迁移命令;</li><li>(2)源服务器向对应的guest VM发送迁移请求；</li><li>(3)guest VM生成nonce η，然后将η和policy ρ发送给目标服务器；</li><li>(4) 首先，目的服务器通过基于TPM的解封函数将EKµ与当前PCR值解绑，如果PCR值没有变化则输出Kµ，然后运行ABS.Sign算法，输出签名σ。最后，目的服务器将签名σ发送给guest VM；</li><li>(5)guest VM运行ABS.Verify算法来验证签名。如果签名有效，则允许迁移；否则，拒绝；</li><li>(6) 源服务器获得迁移许可后，与目的服务器进行迁移；</li><li>(7) 迁移完成后，源服务器将迁移结果反馈给云管理器；</li><li>(8) 云管理器在区块链审计器中记录迁移动作。该记录包含来宾 VM 和目标服务器的签名，以保持安全属性的一致性，防止云管理器的不当行为。</li></ul><h2 id="3-6-基于区块链的信任管理"><a href="#3-6-基于区块链的信任管理" class="headerlink" title="3.6 基于区块链的信任管理"></a><strong>3.6 基于区块链的信任管理</strong></h2><p>在PC-TCS中，区块链审计器被设计为信任管理组件，它记录客户和云管理器的所有请求和操作。为了更好地服务于云客户和云管理人员的信任管理目的，我们在设计中采用了被授权的区块链模型(如超账本结构)，整个被授权的区块链网络充当受信任的第三方。在我们看来，受许可的区块链对于大多数私有云服务和混合云服务而言，就其性能和可管理性而言是一个更好的选择。 PC-TCS中的每个审计事件都可以视为区块链中的一个事务。由于作为VM部署和VM迁移的可审计事件通常保持较低的速率，因此在可接受的成本下，一个有权限的区块链的性能足以满足企业级审计[38]。除了使用分布式账本来跟踪用户和云提供商的历史活动外，智能合约还可以用于声明和执行安全性和VM迁移策略，从而实现自动化和可信的管理。PC-TCS中的信任关系如图6所示。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655638367308.png" alt="image-1655638367308"></p><blockquote><p>图6所示。PC-TCS中的信任关系。主要的信任实体是云客户、云管理器、基于ABS的云基础设施和区块链审计员。实线说明了它们之间的信任关系和行动。虚线表示功能模块之间的内部关系。</p></blockquote><ul><li>存在四个信任实体：云客户、云管理器、基于ABS的云基础设施和区块链审计器。实线说明了它们之间的信任关系和行动。区块链审计员：区块链审计员是信任管理机制的核心。它被设计为受可信第三方监督的公共区块链或区块链。分布式账本用于为云客户和云基础设施提供审计和信誉信息。</li><li>云客户：默认情况下，云客户信任区块链审计员，它提供审计事件、服务提供商声誉和云基础设施属性。然而，云管理器却不受客户的信任。通过与云管理器设置自定义的安全策略和智能合约，保证云管理器的任务可信执行。</li><li>云管理器：云管理器代表受信任管理机制限制和激励的云服务提供商。它应该遵循为客户提供可信服务的规则，并审计对区块链的操作。其不当行为可由区块链审计员进行审计，降低其可信度。</li><li>基于ABS的云基础设施：基于ABS的云基础设施是可信云计算的基础。TPM可以保证平台和ABS相关属性的完整性，PC-RA和PC-MP支持可信迁移和远程认证。</li></ul><p>通过对区块链审计器的信任管理，客户可以从以下两个方面受益:</p><ul><li>(1)对当前请求和历史请求进行监控和审计，验证虚拟机在整个生命周期内是否实现了安全策略。一方面，云客户可以通过ABS验证当前的计算环境是否满足安全策略，另一方面，通过访问区块链审计器中的信任管理模块，可以对VM请求、分配、迁移的所有当前和历史操作的完整性和可靠性进行监控和审计。</li><li>(2)对云管理或服务提供商进行评估和排名。随着历史记录的积累，区块链审核员的信任管理模块可以在PC-TCS中建立信誉和排名系统。已有许多成熟的算法和解决方案[8,9]，用户可以根据自己的需求，量化评估云管理人员的可信度和排名。</li></ul><h1 id="4-实现和案例研究"><a href="#4-实现和案例研究" class="headerlink" title="4 实现和案例研究"></a><strong>4 实现和案例研究</strong></h1><h2 id="4-1-实现"><a href="#4-1-实现" class="headerlink" title="4.1 实现"></a><strong>4.1 实现</strong></h2><p>我们在 Xen 4.7 管理程序 [3] 上实现了我们的 PC-RA 和 PC-MP。 我们修改并添加了一些关键模块和数据路径，如图 7 所示，以支持 PC-RA 和 PC-MP。 原型实现指的是四种虚拟机：host、guest、vtpm-stubdom 和 vtpmmgr-stubdom。基于mini-OS内核的Stubdom（’’stub domain’’）可以看作是一种轻量级的’’service’’或’’driver’’ domain来运行设备模型和实现dom0的技术 分解。 XenBus 描述了 XenStore 的接口，XenStore 是 Xen 来宾之间共享的存储系统。 在更一般的情况下，它描述了一种用于连接到构建在 XenStore 之上的设备驱动程序的协议。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655638551580.png" alt="image-1655638551580"></p><blockquote><p>图 7. 证明和迁移的实现。 原型实现涉及四种虚拟机：host、guest、vtpm-stubdom 和 vtpmmgrstubdom。 基于mini-OS内核的Stubdom（’’stub domain’’）可以看作是一种轻量级的’’service’’或’’driver’’ domain来运行设备模型和实现dom0的技术 分解。 XenBus 描述了 XenStore 的接口，Xen 来宾之间共享的存储系统</p></blockquote><ul><li>主机：主机是面向管理员的管理平台，以XL 作为Xen 管理工具。我们修改了迁移控制模块 (MCM) 以在迁移之前添加一个证明阶段。迁移证明服务 (MAS) 可以在成为目标服务器时通过运行签名算法来证明其自身的安全属性满足客户的策略。</li><li>来宾VM：来宾VM 是面向客户的计算平台。我们添加了 PCS，为客户提供自定义安全策略的接口。我们还添加了 CAS 以使客户能够执行 CPBA。 MAE 通过 XenBus 与 MCM 通信从主机接收 VM 迁移请求，然后通过套接字与 MAS 通信验证目标服务器。Xen&#x2F;tpmback 是 Linux 内核虚拟 TPM 前端驱动程序。此驱动程序提供对来宾 VM 的 vTPM 访问。</li><li>vtpm-stubdom：实现vTPM 的mini-OS 存根域。在系统上运行的 vtpm-stubdom 实例和逻辑 vTPM 之间存在一对一的映射。策略存储处理存储来自客户的定制策略。 ABS引擎提供ABS构造的签名和验证算法。 mini-OS&#x2F;tpmback 是 mini-OS TPM 后端驱动程序。 Linux 前端驱动程序连接到此后端驱动程序，以促进 Linux 客户机与其 vTPM 之间的通信。 vtpmmgr-stubdom 也使用此驱动程序与 vtpm-stubdom 进行通信。 Xen&#x2F;tpmfront 是 mini-OS TPM 前端驱动程序。 vtpm-stubdom 使用此驱动程序与 vtpmmgr-stubdom 进行通信。</li><li>vtpmmgr-stubdom：实现vTPM 管理器的mini-OS 域。只有一个 vTPM 管理器，它应该在机器的整个生命周期内运行。此域管理对系统上物理 TPM 的访问，并保护每个 vTPM 的持久状态。</li></ul><h2 id="4-2-虚拟机迁移的案例研究"><a href="#4-2-虚拟机迁移的案例研究" class="headerlink" title="4.2 虚拟机迁移的案例研究"></a><strong>4.2 虚拟机迁移的案例研究</strong></h2><p>我们使用云中的一个典型的vm迁移案例来演示PC-MP的实现。如图8所示，4个虚拟机运行在一个数据中心上，云管理器试图将运行中的虚拟机迁移到空闲服务器node，这是云中的典型负载均衡场景。一旦一个新节点被添加到云中，它就会共享其他节点的负载以获得更好的性能。在传统云环境下，所有迁移都能成功，而PC-MP环境下，只有满足定制策略的迁移才能成功，这说明了PC-TCS的有效性。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655638702284.png" alt="image-1655638702284"></p><blockquote><p>图 8. 策略定制的 VM 迁移场景。 假设四个虚拟机在五个服务器节点上运行，并且云管理器正在尝试根据使用 PC-MP 定制的用户策略将虚拟机迁移到免费 Noded</p></blockquote><p>首先，云管理器或服务提供商向云客户提供可能的服务器属性来配置迁移策略，如表2所示。其次，云客户可以根据服务器属性为其虚拟机定义安全策略。表3显示了相应的定制策略。表4根据表2中的云管理器数据显示了源节点的状态。表5显示了目标节点的状态。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655638822455.png" alt="image-1655638822455"><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655638747928.png" alt="image-1655638747928">根据上文定义的自定义策略和服务器属性，对图8中的四种迁移操作进行如下分析: (1) 如果云客户设置了迁移控制策略‘‘P1:migration_allow &#x3D; N’’，即不允许VM迁移，则VM1从Node1到Noded的迁移操作失败。 (2) 如果云客户设置出迁移控制策略’’Pout : cpu_load_degree &gt; 2 OR memory_load_degree &gt; 2’’，则VM2从Node2迁移到Noded的操作失败，因为Noded的属性’’PT src: cpu_load_degree &#x3D; 1; memory_load_degree &#x3D; 1’’ 不满足自定义策略。 (3) 如果云客户设置传入的迁移控制策略’’Pin: security_level &gt;&#x3D; 3’’，那么VM3从Node3到Node4的迁移操作失败，因为Noded的属性’’PT dst: security_level &#x3D; 2’’ 不满足自定义策略 P3。 (4) 从Node4到Noded的迁移操作成功，因为定制的策略P4得到满足。</p><h1 id="5-评价"><a href="#5-评价" class="headerlink" title="5 评价"></a><strong>5 评价</strong></h1><p>本节在改变属性数量时评估PC-TCS的安全性和性能。在第5.1节和第5.2节中，我们分别讨论了其安全问题的两个方面：保护PC-TCS本身免受可能的威胁，以及提高云安全以应对使用PC-TCS的典型攻击。第5.3节评估了虚拟机迁移的性能开销。</p><h2 id="5-1-安全分析"><a href="#5-1-安全分析" class="headerlink" title="5.1 安全分析"></a><strong>5.1 安全分析</strong></h2><p>通过PC-TCS框架，客户可以自行选择安全选项，为租用的虚拟机定制安全策略，同时验证当前计算环境与定制策略是否一致。但是，重要的是框架的操作是安全的，关键模块是受保护的。 根据第3节的线程模型，需要考虑对手的攻击和服务提供商的恶意行为。我们的PC-TCS与传统的可信计算共享相同的安全模型。在可信计算基础(Trusted Computing Base)中增加了ABS和Migration相关模块。传统的远程认证协议用我们的PC-RA协议进行了更新。在这种情况下，PC-TCS的安全性与传统可信计算相同。因此，云[15]中的平台安全机制和信任管理框架可以无缝地应用到PC-TCS中。 对于线程模型中的威胁，平台安全机制可以抵御针对VM和VMM的攻击，ABS等网络安全机制可以抵御对网络的攻击，如冒充攻击、中间人攻击等。对于服务提供商的恶意行为，PC-TCS能够监控和遏制风险。一方面，基于ABS的远程认证和虚拟机迁移可以加强用户安全策略的部署和实施。另一方面，区块链审计将对服务提供者的操作进行审计，以降低风险。 该框架需要在三个方面进行安全保护：</p><ul><li>(1)安全收集和服务客户的虚拟机请求；</li><li>(2)可信的认证机制和协议；</li><li>(3)安全迁移虚拟机。</li></ul><p><strong>对客户的VM请求进行安全收集和服务</strong>。攻击者可能试图收集或更改客户非法定制的策略。所以VM请求的收集必须是安全的，可以通过云客户的认证和授权来实现。VM安全请求存储在区块链Auditor中，它能够阻止未经授权的访问和修改。此外，负责处理和执行VM安全请求的控制模块(即Nova-Schedule模块)受到可信计算技术的保护，以保证其代码的完整性。 <strong>可信的认证机制和协议</strong>。攻击者可能会从两个方面对系统进行攻击：(1)对虚拟机或物理节点等云服务器进行攻击和破坏；(2)破解远程认证机制，为客户提供虚假的认证报告。PC-TCS中的ABS签名和验证算法是在vtpm-stubdom中进行的，可以保证认证机制和协议的可信性。同时，采用提供的PCR值对签名密钥进行密封操作，保证了认证特性和计算环境的一致性。 <strong>安全的虚拟机迁移</strong>。在虚拟机迁移时，攻击者可能试图侵入系统篡改代码或收集敏感数据。为此，我们提出了PC-MP来保证安全策略的一致性和云计算平台的完整性，并对敏感数据进行加密，以抵御迁移过程中攻击者的篡改。</p><h2 id="5-2-安全案例研究"><a href="#5-2-安全案例研究" class="headerlink" title="5.2 安全案例研究"></a><strong>5.2 安全案例研究</strong></h2><p>在本节中，我们将通过三个案例研究简要分析架构构造的安全性: <strong>案例研究I:控制平面</strong> 示例攻击:攻击者可能会将许多来宾vm迁移到合法的受害VMM中，从而导致中断或拒绝服务。攻击者还可能将客户vm迁移到攻击者的机器上，并获得对它们的完全控制。攻击者通过虚假地发布可用资源，可以影响控制平面，将来宾虚拟机迁移到攻击者的机器上。 安全分析：基于区块链的信任管理和PC-MP可以有效防止控制平面的攻击，如恶意的流出和流入迁移。基于vTPM的信任链可以保证用户策略的安全性和执行。当且仅当源节点和目标节点的指定属性满足云用户的策略时，开始迁移。基于区块链的信任管理可以帮助客户选择可信的服务，并监督服务提供商的行为，以获得更好的可信性。 <strong>案例II:数据平面</strong> 攻击示例：攻击者通过监控迁移的传输路径和相关的网络流，从迁移虚拟机的内存中提取密码、密钥、应用程序数据和其他受保护的资源等信息。 安全分析：迁移过程中传输的数据使用会话密钥K进行加密，策略迁移认证可以保证会话密钥K的保密性。 <strong>案例研究III:迁移控制模块</strong> 示例攻击：通过利用MCM漏洞(如堆栈、堆和整数溢出)，攻击者可以破坏VMM，在VMM中运行的任何来宾虚拟机也可能受到攻击。 安全分析：TPM可以为云客户提供VMM和vTPM完整性的硬件级保障。vTPM可以保证云客户虚拟机的完整性。</p><h2 id="5-3-性能评估"><a href="#5-3-性能评估" class="headerlink" title="5.3 性能评估"></a><strong>5.3 性能评估</strong></h2><p>我们考虑VM迁移的性能开销，同时改变云节点属性的数量。我们的实验场景是源节点和目标节点之间基于NFS共享存储的实时迁移。每个节点配置一个3.40 GHz的4核CPU和8G的RAM。每个虚拟机配置1核的vCPU和1024m的RAM。VM-migration时延包括认证阶段和数据传输阶段的时间。我们的评估不计算初始部署的时间，因为初始化只需要运行一次。该阶段的主要成本是为ABS生成签名密钥的时间，随着属性的增加，签名密钥的生成时间呈线性增长；例如，生成一个具有10个属性的签名密钥大约需要0.12秒。在我们的设计中，签名密钥被缓存并重用以提高总体性能。总的来说，与云服务的长期运行相比，这是微不足道的。 表6显示了远程认证的时延和VM迁移的传输时延。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655639093291.png" alt="image-1655639093291"> 图9显示VM迁移的延迟与属性的数量成比例地增加。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655639103110.png" alt="image-1655639103110"></p><blockquote><p>图9所示。策略自定义可信云服务(PC-TCS)迁移操作延迟。结果表明，与传统的虚拟机迁移相比，新的认证方案几乎没有明显的性能开销。</p></blockquote><p>数据传输阶段的持续时间通常大于12s，但认证阶段的持续时间小于1s；也就是说，与传统的VM迁移相比，新的认证方案几乎没有明显的性能开销。</p><h1 id="6-结论与未来工作"><a href="#6-结论与未来工作" class="headerlink" title="6 结论与未来工作"></a><strong>6 结论与未来工作</strong></h1><p>在本文中，我们提出了一种新的基于ABS和区块链的PC-TCS体系结构，其中包括基于ABS的远程认证方案和定制的虚拟机迁移协议。 PC-TCS为云客户提供三大功能:</p><ul><li>定制和执行云计算环境的安全策略;</li><li>验证当前的计算环境或虚拟机迁移操作是否满足其自定义安全策略;</li><li>在VM 的整个生命周期中使用区块链中的不知名记录器审计其当前和历史请求的安全性。</li></ul><p>为了证明PC-TCS架构的可用性，我们在开源Xen Hypervisor的基础上实现了PC-TCS原型，包括PC-RA和PC-MP组件。我们的评估表明，PC-TCS能够满足设计目标，其对性能的影响是可以接受的。 PC-TCS可以在TPM 2.0中补充和增强传统的远程认证。配置PC-TCS的节点既可以实现PC-RA认证，也可以实现传统的远程认证，而没有PC-TCS的节点只能通过交换PCR值进行传统的远程认证。 尽管我们的框架有很多优点，但是在实际的云计算中应用PC-TCS仍然面临着技术上的困难。需要升级云基础设施，在硬件层支持TPM。然后VMM需要打补丁以支持PC-RA和PC-MP，这可能涉及到更新到流行的VMM工具，如Xen、KVM等。需要向云基础设施引入可信的区块链。最后，需要在应用层更改使用云服务的方式。 未来，我们计划进一步优化PC-TCS中ABS和区块链机制的性能，并将其重新设计为OpenStack的服务级协议。也可以对Docker这样的容器应用基于ABS的远程认证。在容器中设计虚拟可信计算之后，可以使用PC-TCS这样的设计。</p>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>远程证明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程证明_06_论远程证明中的TOCTOU问题</title>
    <link href="/0006.html"/>
    <url>/0006.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 远程证明_06_论远程证明中的TOCTOU问题 date: 2022-06-12 18:56:32.249 updated: 2022-06-13 00:22:53.942 url: &#x2F;archives&#x2F;yczm06 categories:</p><ul><li>远程证明 tags:</li><li>可信计算</li><li>远程证明</li></ul><hr><h1 id="原文信息"><a href="#原文信息" class="headerlink" title="原文信息"></a><strong>原文信息</strong></h1><ol><li>文章标题：On the TOCTOU Problem in Remote Attestation</li><li>文章中文翻译：论远程证明中的TOCTOU问题</li><li>文章等级：CCF A</li><li>文章发表时间：2021</li><li>文章作者：De Oliveira Nunes I, Jakkamsetti S, Rattanavipanon N, et al.</li><li>完整引用：De Oliveira Nunes I, Jakkamsetti S, Rattanavipanon N, et al. On the TOCTOU problem in remote attestation[C]&#x2F;&#x2F;Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security. 2021: 2921-2936.</li><li>全文请查看：<a href="https://dl.acm.org/doi/pdf/10.1145/3460120.3484532">全文链接</a></li></ol><h1 id="1-TOCTOU"><a href="#1-TOCTOU" class="headerlink" title="1 TOCTOU"></a><strong>1 TOCTOU</strong></h1><p>Time-Of-Check-Time-Of-Use (TOCTOU)，指的是远程证明中存在的一个尚未解决的问题，如果短暂的恶意软件感染了一个设备(通过修改它的二进制文件)，执行它的恶意任务，并在下一次认证之前删除自己，它的临时存在将不会被检测到。</p><blockquote><p>就是利用远程证明中，认证的间隙，来进行攻击。远程证明无法发现这种攻击。</p></blockquote><p>这篇文章提出了一种RATA：一种可证明安全的方法来解决TOCTOU问题，使得即使是在执行下一次RA之前删除自己的恶意软件，也无法隐藏其短暂的存在。 RAT A针对低端嵌入式设备的混合 RA 架构，提出了两种RAT AA和RAT AB，分别适用于有无实时时钟，但是他们都被证明是安全的。 Hybrid RA(基于软硬件协同)。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a><strong>1 介绍</strong></h1><p>认证的完整性检查需要某种类型的完整性保证功能，通常实现为消息认证代码 (MAC)，在 Prv 认证的内存区域上计算。计算 MAC 需要 Prv 具有唯一的密钥，用 K 表示 - 与共享的对称密钥Vrf 或 Vrf 已知对应公钥的私钥。 K 必须驻留在安全存储中，并且在 Prv 上运行的任何软件都无法访问，但特权和不可变的证明代码除外。由于通常的 RA 威胁模型假定 Prv 上的软件状态完全受损，因此安全存储意味着一定程度的硬件支持。混合 RA（基于硬件&#x2F;软件协同设计）[7-10] 是一种特别适用于低端的方法嵌入式设备。在混合 RA 设计中，完整性确保功能在软件中实现，而硬件控制该软件的执行，检测可能导致意外行为或 K 泄漏的任何违规行为。简而言之，混合 RA 提供与（更昂贵的）基于硬件的 RA 方法（例如，基于 TPM [11] 或其他独立硬件模块的方法）相同的安全保证，同时最大限度地减少对底层硬件平台的修改。我们在 3.2 节中概述了一个具体的混合 RA 架构。 尽管取得了很大的进展，但目前的混合RA架构有一个共同的限制:它们度量Prv执行RA时Prv可执行文件的状态。在RA测量之前，它们不提供关于Prv可执行文件的信息，也不提供在两个连续RA测量之间的状态信息。我们将这个问题称为检查时间使用时间(Time-Of-Check Time-Of-Use)。虽然在此之前已经讨论过该问题的变体[12-16]，但在混合RA中仍未得到解决。 我们强调，RA-TOCTOU 问题（如本文所述）不应与确保证明和二进制执行之间的时间一致性问题混淆或混为一谈，这是通过运行时证明方法解决的，例如，[3-6 ]。 尽管如此，二进制文件的 RA（即静态 RA）在这种情况下仍然相关，因为大多数低端设备的运行时证明技术都依赖于静态 RA 作为构建块（一个例外是 [17]，相反，它假设二进制文件 永不改变 4). 事实上，正如我们在第 8 节中讨论的那样，针对 TOCTOU 的安全 RA 架构使得依赖静态 RA 的运行时证明技术更加高效。 在实践中，TOCTOU 问题使设备容易受到临时恶意软件的攻击，这些恶意软件在完成任务后会擦除自身（其可执行文件）。这在大量 MCU 报告长时间收集的测量值的环境中是有害的。例如，考虑在智能城市中测量能源消耗的几个基于 MCU 的传感器，其中大规模错误测量可能导致断电。如果在这种情况下使用对 TOCTOU 不安全的常规 RA 方案（例如，通过每天执行一次 RA，或每个计费周期执行一次），则可以通过以下方式破坏安全性：（i）在常规使用期间将传感器软件更改为欺骗测量，以及 (ii) 使用预期的可执行文件重新编程传感器，其中 (i) 和 (ii) 都发生在连续 RA 实例之间的时间段内。特别是，由于必须通过不受信任的通信通道接收 RA 请求，因此恶意软件可能会在检测到传入的证明请求时简单地擦除自身，即使 RA 调度是先验未知的。如前所述，在还需要检测运行时违规（例如，代码重用和数据损坏攻击）的环境中（例如，MCU 代码是用内存不安全的语言编写的），底层静态 RA 的 TOCTOU-Security 使整体运行时证明更高效；见第 8 节。 我们缓解TOCTOU问题的方法是基于以下观察，即当前的混合RA技术只使用可信硬件来检测危及RA软件本身执行的安全违规，并在检测到此类违规时采取行动(例如，重置设备)。然而，RAT A 的主要新特性是使用最小（正式验证）硬件组件来额外提供有关 Prv 程序内存状态的历史上下文。这是通过在受保护的内存区域中安全记录程序内存修改的最新时间来实现的，该区域也被RA完整性确保功能覆盖。这使得Vrf可以稍后检查Prv内存修改的真实性和完整性。这个新特性被无缝集成到底层RA架构中，并且该组合被证明是安全的。我们相信这将带来以下贡献:</p><ul><li>RA TOCTOU-Security制定:我们在RA的背景下激励并正式化TOCTOU。我们使用安全游戏(参见定义4.1)定义RA TOCTOU - security，并讨论为什么当前基于连续自我测量的RA技术不满足这一定义。我们认为我们的工作是对这一问题的第一次正式处理。此外，我们评估了基于连续自我测量的RA技术的实用性，并认为使用它们来获得TOCTOU-Security会引起极高的运行时开销，可能会使Prv上的良性应用程序极度匮乏。</li><li>设计、实施和验证：我们提出了两种技术：RAT AA 和 RAT AB。前者假设 Prv 有一个与 Vrf 同步的安全只读实时时钟 (RTC)。由于这个假设对于许多低端 Prv-s 来说是不现实的，RAT AB 权衡了对安全 RTC 的需求验证传入的证明请求；事实上，这个特性已经是几种混合 RA 架构的一部分。我们表明，这两种技术都满足 TOCTOU-Security 的正式定义，假设它们的实现遵循线性时序逻辑 (LTL) 中所述的一组正式规范。 最后，实现本身经过形式验证以符合这些 LTL 规范，从而在设计和实现层面产生安全性。 我们的实现在 [18] 上是公开的。 它在现实世界的低端 MCU (TI MSP430) 上实现，并使用商用 FPGA 进行部署。 实验结果表明硬件开销低，即使对于成本敏感的低端设备也是可以承受的。</li><li>RA 和相关服务的增强：我们讨论 RATA 对 RA 和 TOCTOU-Security 之外的相关服务的影响。 特别是，我们表明，在大多数情况下，RAT A 可以将 RA 计算复杂度从线性（就证明的内存大小而言）降低到恒定时间，从而显着节省。 我们还讨论了 RAT A 对专业 RA 应用程序的好处：(i) 实时系统； (ii) 运行时完整性&#x2F;控制流证明； (iii) 集体 RA，需要同时证明多个证明者。</li></ul><h1 id="2-Scope"><a href="#2-Scope" class="headerlink" title="2 Scope"></a><strong>2 Scope</strong></h1><p>本节根据目标设备和期望的安全属性描述了本文的范围。 <strong>低端设备</strong>：这项工作侧重于计算能力较低的 CPS&#x2F;IoT 传感器和执行器（或其混合体）。 这些是一些基于低功耗单核 MCU 的最小和最弱的设备，只有几 KB 的程序和数据存储器。 两个突出的例子是： Atmel AVR ATmega 和 TIMSP430：8 位和 16 位 CPU，通常以 1-16MHz 时钟频率运行，可寻址内存约为 64 KB。 SRAM 用作数据存储器，大小通常在 4 到 16KBytes 之间，而其余地址空间可用于程序存储器。 此类设备通常在“裸机”上运行软件并就地执行指令（物理上来自程序内存），并且没有内存管理单元 (MMU) 来支持虚拟内存。 我们的实现基于MSP430。这个选择是由于开放核心中维护良好的开源MSP430硬件设计的公开可用性。然而，我们的机器模型和本文开发的整个方法适用于同级别的其他低端mcu，如Atmel AVR ATmega。<strong>RAT A的主要实现是由VRASED组成的</strong>，它是一个公开可用的经过验证的混合RA架构，它允许我们演示安全性。尽管我们有特定的实现选择，但我们相信RAT A概念也适用于其他RA架构。为了支持这一声明，附录D描述了在SANCUS之上的RAT A实现：一种基于硬件的RA架构，也针对低端设备。参见第9节，了解各种RA架构的概述。 <strong>检测、预防和内存不可变性</strong>：作为一个面向检测的安全服务，RA不会阻止未来的二进制修改。因此，TOCTOU一词应考虑具有追溯效力。特别是，本文提出的技术允许Vrf理解“从什么时候开始”Prv记忆保持与目前RA结果报告的相同。 虽然可以通过将所有可执行内存设为只读（例如，将代码存储在 ROM 中）来轻松防止恶意软件感染，但这种激进的方法会因无法进行合法软件更新而牺牲可重构性，并且实质上会将 MCU 转变为专用集成电路 （ASIC）。 然而，可重构性是 MCU 最重要的特性之一，甚至可能是它的全部“存在理由”。 一种不那么激烈的方法是防止在运行时发生的程序内存修改。这种方法容易受到物理攻击，即对手直接重新编程Prv。更重要的是，(即使我们排除了物理攻击)它使远程更新变得不可能，只要设备软件需要更新，就需要物理访问。由于这些设备通常是远程的或物理上不可访问的(在一个更大的系统内，如车辆)，低端mcu(包括前面提到的MSP430和ATMega)通常不阻止程序内存的修改。我们基于检测的方法符合这一点，允许对二进制文件进行更改并将其报告给Vrf：即使它们发生在连续的RA实例之间。<strong>由于Vrf知道Prv上所有的二进制修改，所以它可以区分非法修改和预期修改</strong>。</p><h1 id="3-背景和定义"><a href="#3-背景和定义" class="headerlink" title="3 背景和定义"></a><strong>3 背景和定义</strong></h1><h2 id="3-1-设备模型和MCU假设"><a href="#3-1-设备模型和MCU假设" class="headerlink" title="3.1 设备模型和MCU假设"></a><strong>3.1 设备模型和MCU假设</strong></h2><p>我们现在概述与RAT A相关的MCU假设，它们反映了第2节中讨论的低端嵌入式系统的行为，并与之前关于确保低端MCU的工作一致。特别地，我们假设MCU硬件正确地实现了它的规格，如下:</p><ul><li>A1 -程序计数器(PC): PC总是包含在给定的CPU周期内执行的指令的地址。</li><li>A2 -内存地址：无论何时读取或写入内存，数据地址信号(Daddr)包含相应内存位置的地址。对于读访问，必须设置数据读使能位Ren；对于写访问，必须设置数据写使能位Wen。</li><li>A3 - DMA：当直接内存访问(DMA)控制器试图访问主系统内存时，DMA地址信号(DMAaddr)反映正在访问的内存位置的地址，并设置DMA使能位(DMAen)。如果没有设置DMAen, DMA就不能访问内存。</li><li>A4 -单片机复位:在一个成功的复位程序结束时，所有寄存器(包括PC机)都被置零，然后恢复正常的软件执行流程。硬件上的复位由单片机处理。因此，不能修改复位处理例程。当复位发生时，设置相应的复位信号。在MCU第一次初始化时也设置相同的信号。</li><li>A5 -无数据执行：指令必须驻留(物理上)在程序内存(PMEM)中才能执行。它们没有加载到DMEM来执行。数据执行在大多数低端设备中是不可能的，包括我们原型中使用的OpenMSP430。例如，在基于哈佛的低端设备(如VR Atmega)中，没有硬件支持从数据存储器(DMEM)中获取&#x2F;执行指令。在默认情况下不阻止数据执行的其他低端设备中，这通常是由底层混合RA架构强制执行的。因此，即使恶意软件驻留在DMEM中，也必须在执行之前将其复制到PMEM中，从而驻留在PMEM中。</li></ul><h2 id="3-2-RA定义，架构和对抗模型"><a href="#3-2-RA定义，架构和对抗模型" class="headerlink" title="3.2 RA定义，架构和对抗模型"></a><strong>3.2 RA定义，架构和对抗模型</strong></h2><p>正如第1节所讨论的，RA通常被实现为Vrf和Prv之间的挑战响应协议。这个概念被定义3.1中的RA协议通用语法捕获。 定义3.1(语法)。RA是一个元组(请求，证明，验证) (<strong>Request, Attest, Verify</strong>) 算法:<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655026933113.png" alt="image-1655026933113">定义3.1将RA指定为一个元组(Request, Attest,Verify)。 Vrf计算请求生成挑战Chal并发送给Prv。Prv通过使用Chal在被验证的内存范围(由AR表示)上计算一个经过验证的完整性保证函数(例如MAC)，并产生H来执行验证，H被发送回Vrf进行验证。例如，如果使用MAC实现作证，H计算为: $$H &#x3D; HMAC(KDF(K, Chal), AR) ——(1)$$ 其中KDF表示一个密钥推导函数，K是Prv和Vrf共享的对称密钥。Vrf收到H后，执行算法Verify，检查H是否对应某个期望值M的MAC。 虽然本文中讨论的技术与特定的RA架构无关，但我们选择了用VRASED[10]组成RAT A。 我们的选择的动机是VRASED正式的安全定义，它允许推理RAT A与底层RA架构的安全组合；参见定理5.1和6.1。接下来我们概述VRASED。 VRASED是一种经过正式验证的基于软硬件协同设计的混合RA架构。它被构建为一组子模块，每个模块保证一组特定的子属性。每个子模块(硬件或软件)都要单独验证。最后，证明了所有子模块的组成满足RA的稳健性和安全性的形式化定义。非正式地说，RA的可靠性保证了完整性保证函数(VRASED中的HMAC)在经过验证的内存范围(AR)上被正确地计算出来。它还保证了AR在RA计算开始后不会被修改，从而加强了时间一致性，并在RA计算[22]期间防止“躲猫猫”攻击。<strong>RA安全性确保RA执行生成一个不可伪造的经过身份验证的内存测量值，并且用于计算该测量值的K不会在认证之前、期间或之后泄露</strong>。 为了实现上述目标，VRASED软件部分(SW-Att)驻留在只读存储器(ROM)中，并依赖于来自HACL密码库[23]的经过正式验证的HMAC实现。典型的SW-Att执行过程如下:</p><ol><li>从MR表示的固定内存区域读取挑战Chal。</li><li>使用密钥推导函数(KDF)从Chal和认证主密钥K中导出一次性密钥：$KDF(K, MR)$(其中MR &#x3D; Chal)。</li><li>验证实现(SW-Att)通过在被验证的内存区域AR上使用新衍生的密钥计算HMAC生成验证令牌H: $H &#x3D; HMAC (KDF(K, MR)， AR)$</li><li>用结果H重写MR，并返回执行到非特权软件，即正常的应用程序。</li></ol><p>VRASED硬件(HW-Mod)监测7个不同的MCU信号：</p><ol><li>PC:当前程序计数器值;</li><li>Ren:指示MCU是否从内存中读取的信号(1位);</li><li>Wen:指示MCU是否写入内存的信号(1位);</li><li>Daddr: MCU存储器访问地址;</li><li>DMAen:表示是否直接内存访问(DMA)当前正在访问内存(1位)的信号;</li><li>DMAaddr:被DMA访问的内存地址。</li><li>irq:表示中断是否正在发生的信号(1位)</li></ol><p>这些信号确定一个位复位信号输出，当设置为1时，立即触发系统范围的MCU复位，即在执行下一个指令之前。当VRASED硬件检测到任何违反安全属性的情况时，会触发复位输出。VRASED硬件是用有限状态机(FSMs)在寄存器传输层(RTL)中描述的。然后，使用NuSMV Model Checker[24]自动证明FSMs实现了声明的安全子属性。最后，使用一个<strong>LTL定理证明器</strong>来证明硬件和软件子属性的结合意味着端到端可靠性和安全性。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655027182327.png" alt="image-1655027182327"> 更正式地说，VRASED的端到端安全证明保证了在定义3.2的RA安全博弈中，没有一个概率多项式时间(PPT)的对手能够以不可忽略的概率在安全参数l上获胜，即Pr[Adv, RA-game]≤negl(l)。 备注1：虽然上述保证确保了认证计算期间被验证内存的一致性，VRASED或任何之前的低端RA方案都不是TOCTOU-Secure的，因为在认证之前的修改是不被检测到的。 <strong>敌对的模型</strong>。我们考虑一个相当强大的对手Adv，它控制着Prv的整个软件状态，包括代码和数据。Adv可以修改任何可写内存，也可以读取任何没有受到可信硬件显式保护的内存(包括机密内存)。此外，如果在Prv上存在任何DMA控制器，Adv可以完全访问所有DMA控制器。回想一下，DMA允许直接访问和修改内存，而不需要经过CPU。 虽然Adv可能会通过有线连接flash的方式对Prv软件进行物理重编程，但侵入性&#x2F;篡改性硬件攻击不在本文的研究范围之内:我们假设Adv不能:(1)改变硬件组件，(2)修改ROM中的代码，(3)诱发硬件故障，(4)通过物理侧通道获取Prv机密。针对物理硬件攻击的保护与我们的目标是正交的，可以通过防篡改技术[25]实现。</p><h2 id="3-3-线性时间逻辑-LTL"><a href="#3-3-线性时间逻辑-LTL" class="headerlink" title="3.3 线性时间逻辑(LTL)"></a><strong>3.3 线性时间逻辑(LTL)</strong></h2><p>计算机辅助形式化验证通常包括三个基本步骤：首先，使用形式化模型(如有限状态机，FSM)描述感兴趣的系统(如硬件、软件、通信协议)。第二，正式指定了模型应该满足的属性。第三，根据正式指定的属性检查系统模型，以确保保留它们。这可以通过定理证明或模型检查来实现。在本工作中，我们使用后者来验证系统模块的实现。 在模型检查的一个实例中，使用线性时间逻辑(Linear Temporal Logic, LTL)将属性指定为公式，系统模型表示为FSMs。因此，一个系统由一个三元组(S, S0,T)表示，其中S是状态的有限集合，$S0⊆S$ 是可能初始状态的集合，$T⊆S ×S$ 是转移关系集-它描述了从每个状态可以在一个单一步骤到达的状态集。使用LTL指定属性允许表示预期的系统行为。 除了命题连接词，如连接(∧)、分离(∨)、否定(¬)和蕴涵(→)，LTL还包括时间连接词，因此可以进行顺序推理。在本文中，我们对下列时态连接词感兴趣:</p><ul><li>$Xϕ$ - neXt ϕ ：如果ϕ 在下一个系统状态为true，则成立。。</li><li>$Fϕ$ -Future ϕ: 如果存在ϕ 为true的未来状态，则成立。</li><li>$Gϕ$ -Globally ϕ：如果对于所有未来状态ϕ 为true，则成立。</li><li>$ϕ U ψ$ - ϕ Until ψ：如果存在一个未来状态 ψ 成立并且 ϕ 对于之前的所有状态都成立，则成立。</li><li>$ϕ W ψ$ - ϕ Weak until ψ：如果假设 ψ 成立的未来状态，则 ϕ 对于之前的所有状态都成立。 如果 ψ 永远不会变为true，则 ϕ 必须永远成立。 更正式地说： $ϕWψ ≡ (ϕUψ ) ∨ G(ϕ)$</li></ul><h1 id="4-RA-TOCTOU"><a href="#4-RA-TOCTOU" class="headerlink" title="4 RA TOCTOU"></a><strong>4 RA TOCTOU</strong></h1><p>本节定义了 TOCTOU-Security for RA 的概念。 我们首先使用安全游戏将这个概念正式化。 接下来，我们考虑这个问题的实用性并概述现有机制，认为它们没有实现TOCTOU-Security（既不根据TOCTOU-Security定义，也不在实践中）并且产生相对较高的开销。</p><h2 id="4-1符号"><a href="#4-1符号" class="headerlink" title="4.1符号"></a><strong>4.1符号</strong></h2><p>我们总结了表 1 中的符号。它与 VRASED [10] 中的符号基本一致，并添加了一些额外的元素来表示 RAT A 特定的内存区域和信号。 为了简化符号，当给定信号（例如，Daddr）的值在一定范围内（例如，$AR &#x3D; [AR_{min}, AR_{max}]$）时，我们写出 $D_{addr} ∈ AR$，即： $$D_{addr} ∈ AR ≡ AR_{min} ≤ D_{addr} ≤ AR_{max} —- (2)$$ 根据3.1节讨论的公理，我们使用$Mod_Mem(x)$表示对内存地址x的修改。给定我们的机器模型，如下逻辑等价： $$Mod_Mem(x) ≡ (W_{en} ∧ D_{addr} &#x3D; x) ∨ (DMA_{en} ∧ DMA_{addr} &#x3D; x) ——–(3)$$ 这捕捉了一个事实，即内存修改可能是由CPU(反映在信号Wen &#x3D; 1和Daddr &#x3D; x)或DMA(信号DMAen &#x3D; 1和DMAaddr &#x3D; x)引起的。我们也用这个表示法来表示连续内存区域R内某个位置的修改： $$Mod_Mem(R) ≡ (W_{en} ∧ D_{addr} ∈ R) ∨ (DMA_{en} ∧ DMA_{addr} ∈ R) ——–(4)$$ <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655028194335.png" alt="image-1655028194335"></p><h2 id="4-2-TOCTOU-Security定义"><a href="#4-2-TOCTOU-Security定义" class="headerlink" title="4.2 TOCTOU-Security定义"></a><strong>4.2 TOCTOU-Security定义</strong></h2><p>定义 4.1 抓住了 TOCTOU-Security 的概念。 在其中，游戏形式化了第 3.2 节中讨论的威胁模型，其中 Adv 控制 Prv 整个软件状态，包括随意调用 Attest 的能力。 游戏从挑战者 (Vrf) 选择时间 t0 开始。 在稍后的时间（tatt），Adv 收到 Chal 并赢得游戏，如果它可以产生被验证接受为对预期 AR 值 M 的有效响应的 HAdv，实际上，在 t0 和 tatt 之间存在时间 当AR≠M。 这个定义增强了RA的安全性(定义3.2)，通过允许Adv在产生预期响应时成功，即使在t0之后的任何一点AR被修改，而t0是由Vrf选择的。例如，如果Vrf想知道AR在过去两小时内是否保持有效状态，Vrf选择t0为t0 &#x3D; tatt−2h。注意，这个定义还捕获了针对暂时性攻击的安全性，其中Adv将修改过的内存更改回其预期状态并离开设备，从而试图对即将到来的认证请求隐藏其短暂的修改。这种攻击是不可检测的所有RA方案，不是TOCTOU-Secure。 备注2：回想一下，AR对应于Prv存储器的可执行部分，即程序存储器。由于数据内存是不可执行的(参见3.1节)，定义4.1没有考虑对数据内存的更改。在8.4节中讨论了运行时&#x2F;数据-内存攻击的关系。</p><h2 id="4-3-TOCTOU-Secure-RA-vs-连续自我测量"><a href="#4-3-TOCTOU-Secure-RA-vs-连续自我测量" class="headerlink" title="4.3 TOCTOU-Secure RA vs. 连续自我测量"></a><strong>4.3 TOCTOU-Secure RA vs. 连续自我测量</strong></h2><p>基于连续的自我测量[12,26]的RA方案试图检测两个连续的RA测量之间的短暂恶意软件。<strong>策略是让Prv间歇性地(基于周期性或不可预测的时间表)并单方面调用其RA功能。然后，要么Prv自连接到Vrf[26]，要么在本地累积测量值，等待Vrf显式地请求[12]。在收到RA响应后，Vrf在每次RA测量时检查恶意软件的存在</strong>。图2描述了这些RA方案中使用的时间间隔。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655028450745.png" alt="image-1655028450745"> 显然，所有自我测量方案总是在连续的 RA 实例之间留出一些时间，在此期间不会检测到短暂的恶意软件存在。 使用自我测量方案检测所有瞬态恶意软件的唯一方法是在 Prv 上以足够高的频率调用 RA 功能，这样可能最快的瞬态恶意软件就不会出现和消失。 然而，即使确定如此“足够高的频率”很容易（事实并非如此），这样做的成本也会非常高，如下所示。 我们将连续方案中的 CPU 利用率 (U) 定义为常规应用程序 (Capp) 可以使用的 CPU 周期的百分比，即除了用于自我测量 (CRA) 的周期之外的周期： $$ U &#x3D; \frac{C_{app}}{C_{app} + C_{RA}} ——-(7) $$ 如上所述，通过连续的自我测量来保证瞬时恶意软件的检测需要: $$C_{app} &lt; C_{Adv} ———-(8)$$ 其中，CAdv是最快的瞬时恶意软件使用的指令周期数，它可以感染Prv，执行它的任务，并清除自己。为了说明这一点，我们假设CAdv &#x3D; 10^6^个周期的保守值，在这种情况下： $$C_{Adv} &#x3D; 10^6 ⇒ C_{app} &lt; 10^6 ⇒ U &lt; \frac{10^6}{ 10^6 + C_{RA}}—– (9)$$ 例如，对于CRA，考虑VRASED(其他混合RA架构，例如[7]，也有类似的成本)所需的CPU周期数，以证明4KB的程序内存:CRA &#x3D; 3.6 × 10^6^个CPU周期(在典型的8MHz低端MCU中大约半秒)。 $$U &lt; \frac{10^6} {10^6 + 3.6 × 10^6} ⇒ U &lt; 21.74% ——-(10)$$ 为了检测暂时的恶意软件，很大一部分CPU周期(在这个玩具例子中几乎是80%)花费在RA计算上。在实践中，很难确定CAdv，在某些情况下(例如，改变一个通用的输入&#x2F;输出值来触发驱动)，它可能远远小于10^6^个周期，导致在Prv上运行的合法应用程序的CPU利用率更低。 因此，使用连续的自测来检测所有瞬态恶意软件是不切实际的。这也适用于连续测量之间的间隔是可变的和&#x2F;或从范围[0,tmax]随机选择的情况。正如在[26]中所讨论的，这是因为tmax &lt; CAdv才能达到可以忽略的恶意软件规避概率。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655028947606.png" alt="image-1655028947606"> 如图 3 所示，TOCTOU-Secure RA（根据定义 4.1）允许 Vrf 独立于连续 RA 测量之间的时间确定内存完整性，而与瞬时恶意软件速度无关。 在接下来的部分中，我们提出了两种 TOCTOU-Secure 技术，并根据定义 4.1 展示它们的安全性。</p><h1 id="5-RAT-AA-RTC-BASED-TOCTOU-SECURE技术"><a href="#5-RAT-AA-RTC-BASED-TOCTOU-SECURE技术" class="headerlink" title="5 RAT AA - RTC-BASED TOCTOU-SECURE技术"></a><strong>5 RAT AA - RTC-BASED TOCTOU-SECURE技术</strong></h1><p>在混合式RA中，可信软件(SW-Att)通常负责生成经过验证的RA响应(H)及其所有语义信息。同时，可信硬件(HW-Mod)负责：(i)确保SW-Att按预期执行，(ii)防止其密码机密泄露，以及(iii)处理执行期间的意外或恶意行为。为了解决TOCTOU，我们提出了一个范式转变，允许(正式验证的)HW-Mod也提供一些关于Prv内存状态的上下文。 我们现在概述RAT AA，一个简单的技术，<strong>需要Prv有一个可靠的只读实时时钟(RTC)与Vrf同步</strong>。然而，RTC在低端MCU上并不容易获得，而且分布式系统中的安全时钟同步具有挑战性[27-29]，尤其是对低端设备[30,31]。尽管如此，我们还是从这个简单的方法开始，以展示TOCTOU-Secure RA背后的主要思想。接下来，第6节提出了一种替代变体，只要Vrf请求通过Prv验证，就可以删除RTC要求。(请注意，Vrf认证已经是一些混合RA架构的一部分，包括VRASED。)</p><h2 id="5-1-RAT-AA-设计与安全"><a href="#5-1-RAT-AA-设计与安全" class="headerlink" title="5.1 RAT AA 设计与安全"></a><strong>5.1 RAT AA 设计与安全</strong></h2><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655029692616.png" alt="image-1655029692616"> RAT AA 如图 4 所示； 它被设计为一个<strong>经过验证的硬件模块</strong>，其行为如下：</p><ol><li>它监控一组 CPU 信号，并检测 AR 中的任何位置何时被写入。 这是通过检查信号 Daddr、Wen、DMAaddr 和 DMAen 的值来实现的（参见第 3.2 节）。这些信号允许通过 CPU 或 DMA 检测内存修改。</li><li>每当检测到 AR 中的修改时，RAT AA 通过从 RTC 读取当前时间并将其存储在称为最新修改时间 (LMT) 的固定内存位置来记录时间戳。</li><li>在内存布局中，LMT ∈ AR。 此外，RAT AA 强制 LMT 对于在 MCU 上执行的所有软件和 DMA 始终是只读的。</li></ol><p>请注意，通过强制执行 LMT ∈ AR，证明结果 $H &#x3D;HMAC(KDF(K, MR), AR)$包括 LMT 的认证值 - 与 AR 的最新修改对应的时间。作为验证算法的一部分，Vrf 将此信息与 AR 的最后一次授权修改时间（定义 4.1 的 t0）进行比较，以检查此后是否发生了任何未经授权的修改。构造 1 中进一步详细说明了总体思路，它显示了 RAT AA 如何无缝集成到 VRASED 中，在硬件中强制执行两个附加属性以获得 TOCTOU-Security。这些属性在构造 1 的公式 11 和 12 中以 LTL 形式化。 我们证明，只要 RAT AA 实现遵循公式 11 和 12 中的 LTL 语句，构造 1 就是安全的。该验证在第 5.2 节中讨论。密码证明是通过将结构 1 的 VRASED 安全性（根据定义 3.2）简化为 TOCTOU-Security（根据定义 4.1）。就其本身而言，只要 HMAC 是安全的，即存在性，VRASED 就根据定义 3.2 显示为安全的不可伪造的[32]，MAC（详见[10]）。定理 5.1 的证明见附录 B。 定理 5.1： 根据定义 4.1，只要 VRASED 根据定义 3.2 是安全的，构造 1 就是 TOCTOU-Secure。</p><h2 id="5-2-RAT-AA：实施与验证"><a href="#5-2-RAT-AA：实施与验证" class="headerlink" title="5.2 RAT AA：实施与验证"></a><strong>5.2 RAT AA：实施与验证</strong></h2><p><strong>构造1(以及相应的安全性证明)假设公式11和12中的属性是由RAT AA强制执行的</strong>。图5显示了与此实现相对应的正式验证的FSM。它实现了方程11和12的两个性质。这个FSM被实现为一个Mealy机器，它的输出会根据当前状态和当前输入值随时变化。FSM以信号子集作为输入，如图4所示，并产生两个1位输出：reset触发立即复位，setLMT控制LMT内存位置的值(参见Construction 1)。当FSM转换到reset状态并保持在该状态时，reset为1;否则它将保持0。当FSM切换到MOD状态时，setLMT为1，当FSM切换到MOD状态时，setLMT为0。在所有其他情况下setLMT &#x3D; 0。 <strong>FSM的工作原理是监控LMT的写访问，并在出现这种情况时切换到RESET</strong>。当系统运行时(例如，reset &#x3D; 0)， FSM也会监控AR的写访问，并在它发生时转换到MOD状态。如果AR未被修改，FSM将返回NotMOD状态。采用Verilog2SMV[33]语言设计了FSM，并使用Verilog2SMV[33]语言自动转换为SMV。最后，我们使用NuSMV模型检查器[24]证明该FSM符合不变量11和12。实现和相应的验证可在[18]中获得。 备注3：由于删除是一种“写”操作，恶意软件无法在运行时清除自身而不被RAT A检测到。相反，任何通过有线连接直接重编程flash (AR)的尝试都需要设备重新初始化。RAT AA&#x2F;RAT AB总是更新LMT在初始化&#x2F;重置&#x2F;重启。因此，这些修改也会被检测到。 备注4：通过尝试写入LMT来引起复位的能力对Adv没有任何好处，因为任何裸金属软件(包括恶意软件)总是可以在未修改的低端设备上触发复位，例如，通过诱导软件故障。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655029924631.png" alt="image-1655029924631"> <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655029944750.png" alt="image-1655029944750"></p><h1 id="6-RAT-AB-CLOCKLESS-TOCTOU-SECURE-RA-TECHNIQUE"><a href="#6-RAT-AB-CLOCKLESS-TOCTOU-SECURE-RA-TECHNIQUE" class="headerlink" title="6 RAT AB: CLOCKLESS TOCTOU-SECURE RA TECHNIQUE"></a><strong>6 RAT AB: CLOCKLESS TOCTOU-SECURE RA TECHNIQUE</strong></h1><p>我们现在描述 RAT AB：<strong>一种 TOCTOU-Secure 技术，不需要 Prv 上的时钟</strong>。 我们应用来自 RAT AA 的想法，通过使用硬件来传达有关最新内存修改时间的经过身份验证的信息，作为证明结果的一部分。 然而，缺乏 RTC 排除了 Prv 上的任何“时间”概念。 为了解决这个问题，<strong>我们依靠 Vrf 来传达与给定时间点相关的信息，根据 Vrf 自己的本地时钟</strong>。 这是作为 <strong>RA 请求算法的一部分完成的</strong>。 事实上，RAT AB 在此任务中使用证明挑战 (Chal) 本身，利用 Chal 每个请求都是唯一的这一事实，并且在任何 RA 技术中都可用，因此不会产生额外的通信开销。 RAT AB 的安全性与 Vrf 请求的身份验证紧密结合，这已经是 VRASED 架构的一部分 [10]； 详见附录 A。</p><h2 id="6-1-RAT-AB-设计和安全性"><a href="#6-1-RAT-AB-设计和安全性" class="headerlink" title="6.1 RAT AB 设计和安全性"></a><strong>6.1 RAT AB 设计和安全性</strong></h2><p>RAT AB的设计与图4保持一致。RAT AB监控与RAT AA相同的一组MCU信号，也通过覆盖特殊的内存区域$LMT∈AR$工作。然而，它不是记录RTC时间戳到LMT，而是记录Chal，它是由Vrf作为请求的一部分发送的，并作为输入证明(Chal，…)。<strong>当且仅当AR自上一个Attest 实例以来发生修改时，LMT将被当前接收到的Chal覆盖</strong>。总之，RAT AB的安全性依赖于以下属性，由其经过验证的硬件实现强制执行(见章节6.2):</p><ol><li>与RAT AA类似，在Prv上运行的任何软件都不能覆盖LMT，即LMT只能由RAT AB硬件修改。</li><li>只有在 <strong>Attest</strong> 过程中验证成功后才会立即触发对LMT的更新。</li><li>修改AR后的第一次成功验证总是会导致LMT更新为存储在MR中的Chal的当前值(回想一下表1，MR是<strong>Attest</strong>读取Chal值的内存位置)。</li></ol><p>设Chal1和H1表示在给定的RA交互中Vrf成功发送&#x2F;接收的认证挑战和响应。Vrf对RA结果的解释如下：如果H1是一个有效响应，即对应一个期望的AR值，则收到该响应的t1时间由Vrf本地保存，与Chal1相关。在随后的认证结果(H2, H3，…)中，Vrf检查LMT的值是否与Chal1对应。如果LMT≠Chal1, Vrf得知AR在t1后被修改。这源于这源于 RAT AB 验证模块，该模块保证如果在对 Attest 的连续调用之间发生 TOCTOU，LMT 总是被新收到的质询覆盖。 在此设计中，我们强调以下几点:</p><ul><li><strong>Vrf请求的认证对RAT AB的安全性非常重要</strong>。没有它，Adv可以简单地选择ChalAdv，并在未经授权的AR修改后调用作证(ChalAdv)，从而设置LMT &#x3D; ChalAdv的选择。通过选择ChalAdv作为Vrf之前使用的值，Adv可以很容易地使Vrf相信在两次测量之间没有发生TOCTOU。换句话说，缺少请求认证使得Adv可以随意修改LMT，使LMT的写保护失效。</li><li><strong>LMT的唯一性必须强制执行</strong>，例如，通过Vrf从足够大的空间随机抽样Chal或使用Chal作为单调递增的计数器，这取决于请求算法的细节。如果Chal在n个请求实例之后被重用，Adv可以等待第n个真实请求完成，感染Prv，执行它的任务，并在(n + 1)-st请求发生(重用Chal)之前离开Prv，导致有效的响应和损害TOCTOU-Security。例如，如果我们使用LMT作为一个脏位(而不是Chal)，安全性可以在两个请求中被破坏，即使它们是正确的身份验证。</li></ul><p>RAT AB在<strong>Construction 2</strong>中指定。Prv硬件模块控制1位信号UPLMT的值。当设置为1时，UPLMT用MR的当前值更新LMT；否则，LMT将保持当前值。RAT AB硬件通过检查程序计数器PC是否指向认证成功后立即到达的指令来检测Vrf认证是否成功。注意，除非身份验证成功，否则永远不会到达位置CRauth的指令。<strong>与RAT AA不同的是，RAT AB中的Vrf可以了解到在先前成功的认证响应之后是否发生了修改，但不知道修改的确切时间</strong>。RAT AB的安全性在定理6.1中说明，证明递延到附录C。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655030088281.png" alt="image-1655030088281"> 定理 6.1：根据定义 4.1，只要 VRASED 根据定义 3.2 是安全的，构造 2 就是 TOCTOU-Secure。</p><h2 id="6-2-RAT-AB：实施与验证"><a href="#6-2-RAT-AB：实施与验证" class="headerlink" title="6.2 RAT AB：实施与验证"></a><strong>6.2 RAT AB：实施与验证</strong></h2><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655030323738.png" alt="image-1655030323738"> 定理6.1的证明假设RAT AB硬件遵循公式15到17中的性质。图6显示了RAT AB的实现，它是一个经过正式验证的FSM，符合这些属性。它以一个信号子集作为输入，如图4所示，并输出两个1位信号:复位触发立即系统范围的复位，UPLMT控制LMT区域的更新。当FSM转换到状态UPDATE时，UPLMT &#x3D; 1，并且在所有其他状态下的值为0。当FSM转换到状态reset时，reset &#x3D; 1，并且状态保持不变;否则它将保持0。FSM执行如下操作:</p><ol><li>如果尝试修改LMT软件，无论处于什么状态，FSM都会立即触发复位。</li><li>如果AR自上次计算Attest以来没有任何修改，则FSM保持NotMOD状态。</li><li>在任何时间点，如果检测到AR的修改，FSM转换到状态MOD。这个转换表明修改发生了，尽管它没有改变任何输出，也没有改变LMT。这是因为写入LMT的信息(下一个请求中Chal的值)此时不可用。</li><li>当调用Attest时，可能会发生两种操作：<ol><li>如果FSM处于NotMOD状态，则证明正常计算，并且FSM保持相同的状态。</li><li>否则，FSM一直处于MOD状态，直到满足条件PC &#x3D; CRauth，表示Vrf请求认证成功。然后，FSM转换到状态UPDATE，导致在转换期间设置UPLMT。因此，LMT被Chal覆盖，Chal作为参数传递到当前的<strong>Attest</strong>调用。注意，对LMT的更新发生在AR上完整性保证函数(HMAC)计算之前，它发生在ATTEST状态。因此，认证结果H将反映LMT &#x3D; Chal作为AR的一部分。一旦认证完成(PC &#x3D; CRmax)， FSM转换回NotMOD。</li></ol></li></ol><p>在5.2节中讨论的相同的验证工具链被用来证明这个FSM遵守公式15、16和17中的LTL语句。</p><h1 id="7-评估"><a href="#7-评估" class="headerlink" title="7 评估"></a><strong>7 评估</strong></h1><p>我们的原型是建立在低端设备的代表- TI MSP430 MCU家族[34]。它扩展了VRASED(本身建立在OpenMSP430的[19]之上——MSP430的一个开源实现)，使TOCTOU检测成为可能。采用Basys3商用FPGA原型板进行合成和实现。 <strong>硬件开销</strong>。表2反映了RAT A验证的硬件开销的分析。与一些相关的工作[1,5,6,10,35,36]类似，我们根据额外的查找表和寄存器来考虑硬件开销。LUT数量的增加可以用来估计组合逻辑所需的额外芯片成本和大小，而额外寄存器的数量提供了RAT A FSMs中顺序逻辑所需的状态寄存器的估计。与VRASED相比，经过验证的RAT AA模块增加了4个额外的寄存器和13个额外的LUT，而RAT AB则分别增加了57个LUT和27个寄存器。至于未修改的OpenMSP430架构，这意味着1.4%的LUT和1.4%的RAT AA寄存器以及3.8%的LUT和4.8%的RAT AB寄存器的开销。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655030421599.png" alt="image-1655030421599"> <strong>运行时开销</strong>。<strong>RAT A不需要对RA执行进行任何修改。它只确保关于验证内存的最新修改的信息被纳入验证结果</strong>。因此，在VRASED架构之上，它不需要额外的运行时周期或额外的RAM分配。事实上，正如我们接下来在第8节中讨论的那样，可以将运行时时间减少到只用于验证LMT的时间。图8显示了运行时的缩减。这表示与验证大小为4K Bytes的AR所需的周期数相比，减少了约10倍。运行时节省随AR的大小线性增加。 <strong>内存开销</strong>。RAT AA需要128位额外存储：64位用于RTC和64位用于LMT。RTC是使用一个以每个时钟周期递增的64位存储单元来实现的。这保证了RTC在Prv的生命周期内不会缠绕，因为它将花费超过70000年的时间在运行在8MHz的MSP430上发生，并在每个周期增加RTC。在RAT AA中，LMT被实现为64位内存存储，并在setLMT位打开时用RTC值更新其内容。对于RAT AB，内存开销增加到总共512位。实现VRASED认证模块需要256位内存，而另外256位内存用于实现LMT，在适用的时候用Chal更新它的内容(如第6节所述)。这一小块预留内存对应于MSP430内存地址空间的0.1%(总共64K Bytes)。 <strong>验证资源</strong>。我们在运行在3.40GHz的Ubuntu 18.04机器上验证RAT A。结果如表2所示。RAT AA在VRASED之上增加了127行经过验证的Verilog代码。在公式11和12中，这两个变量需要强制使用。RAT AB增加了182行经过验证的Verilog代码，需要强制公式15、16和17中的3个不变量。此外，RAT A验证需要检查现有的VRASED不变量。整个验证过程耗时不超过1秒，最多消耗26MB内存。 <strong>比较</strong>。我们比较了RAT A与两种最新的自测量RA技术:SeED[26]和ERASMUS[12]的硬件开销。即使，正如在4.3节中所讨论的，这些技术没有实现TOCTOU - Security(按照定义4.1)，我们相信它们是RAT A . SeED扩展了32位Intel架构，这是比我们的目标设备，即16位TI MSP430更高端的方法。而ERASMUS是在MSP430上实现的。图7比较了RAT A与SeED和ERASMUS的附加LUT和寄存器的数量。与SeED和ERASMUS相比，RAT AA需要更少的LUT。然而，与ERASMUS相比，RAT AB需要更多的寄存器，它比两种自我测量技术使用更少的lut。总之，两个RAT A-s都招致较低的开销：lut和寄存器都增加了&lt; 5%。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655030511026.png" alt="image-1655030511026"></p><h1 id="8-使用RATA增强RA及相关服务"><a href="#8-使用RATA增强RA及相关服务" class="headerlink" title="8 使用RATA增强RA及相关服务"></a><strong>8 使用RATA增强RA及相关服务</strong></h1><p>我们现在讨论RAT A如何使RA和相关服务更简单、更高效。</p><h2 id="8-1-Constant-Time-RA"><a href="#8-1-Constant-Time-RA" class="headerlink" title="8.1 Constant-Time RA"></a><strong>8.1 Constant-Time RA</strong></h2><p>RAT A的一个显著和有益的特点是，大多数时候，RA不再需要在整个AR上计算，这大大减少了RA在Prv上的执行时间。 如果Vrf已经从之前的认证结果中知道AR内容，则足以表明AR自那时以来没有改变。这可以通过对LMT本身进行验证来实现，而不是对AR进行整体验证，从而使计算时间从AR大小的线性大幅减少到常数：$LMT$，即32字节。因此，在两种可能的情况下，RA的执行方式不同:</p><ul><li>情况1：如果自上次验证(以tatt表示)以来没有对AR进行修改，只调用验证LMT区域。验证检查$H≡H MAC(KDF(K, Chal)， LMT)$。然后Vrf仅基于LMT来学习AR自上次测量以来是否被修改。通过检查LMT对应的t0 &lt; tatt，这个结果确认AR在过渡期间保持相同。因此，再次测量AR是没有必要的，这样做是多余的。</li><li>情况2：如果AR自最后一次验证以来被修改，调用涵盖整个AR的证明。验证通常按照结构1或2中描述的计算，取决于实现，即RAT AA或RAT AB。</li></ul><p>备注5：注意Prv RA功能可以通过检查LMT的值很容易地检测AR是否被修改(以便决定用Case-1还是Case-2验证)，LMT在软件中是可读的(虽然不是可写的)。 大多数时候，Prv被期望处于良性状态(即，没有恶意软件)，特别是如果Adv知道它的存在是保证可检测到的。在这种情况下，验证内存的大小可以从几个KBytes(例如，当AR是低端Prv上的整个程序内存时)减少到仅仅32 Bytes (LMT大小)，图8描述了MSP430 MCU上的经验结果，显示了这种优化如何可以显著降低RA运行时开销。 在本节的其余部分中，我们将讨论这种优化的一些含义，以及RAT A提供的对RA和相关安全服务的不同分支的安全性改进。</p><h2 id="8-2-原子性和实时设置"><a href="#8-2-原子性和实时设置" class="headerlink" title="8.2 原子性和实时设置"></a><strong>8.2 原子性和实时设置</strong></h2><p>混合RA架构的安全性通常取决于验证内存的时间一致性。简单地说，时间一致性意味着“在RA计算期间不修改AR”。由于缺乏这一特性，自我重新定位的恶意软件会在认证期间移动自己在Prv内存中，以避免检测，例如，如果恶意软件中断认证执行，将自己重新定位到已被完整性保证功能(在我们的例子中是HMAC)覆盖的AR部分，并重新启动认证。 在更高端的设备中，可以使用内存锁定防止在验证结束之前进行修改，如[22]中所讨论的那样。然而，在低端设备中，应用程序运行在裸金属上，没有内存锁定的架构支持，通过强制认证软件(SW-Att)原子地运行来实现时间一致性：一旦启动，它就不能被运行在Prv上的任何软件中断，从而防止恶意软件中断RA并重新定位自己。虽然对于安全目的有效，但如果Prv服务于安全关键和时间敏感的功能，则这一需求与实时需求相冲突。 一些先前提出的补救技术可以在保持时间一致性的同时启用中断，概率很高。SMARM[37]就是这样一种方法。([38]中讨论了其他类似的技术)。SMARM将验证内存(AR)分成一组块，这些块以随机顺序进行验证。对一个块的验证仍然是原子的。但是，允许在两个块验证之间中断。假设恶意软件无法猜测下一个被验证区块的索引，即使允许中断，恶意软件也只有一定的概率避开检测。如果整个认证过程重复多次，这个概率可以变得任意小。 我们注意到，考虑到第8.1节中讨论的RAT A优化，可以更快地计算验证。特别是，由于大多数伪随机函数(PRF)实现使用至少32字节的块大小，smarm类型策略中一个块的原子认证不能比RAT a中的LMT上的认证快(LMT &#x3D; 32字节)。此外，LMT的认证提供了AR内容的完整信息，不存在漏报的可能性。我们相信这使得RAT A对安全关键操作比现有方法更友好。 在这样的设置中，我们设想AR将在系统启动时被完整地验证(案例2在8.1节)，而随后的RA将只在LMT上计算(案例1在8.1节)。我们注意到，如果AR最终被修改，Prv将需要回到Case-2进行下一次RA计算，这需要原子运行的时间。<strong>然而，在未经授权修改了Prv内存之后，我们还不清楚为什么还想为被入侵的软件提供实时保证</strong>。</p><blockquote><p>被入侵了 不需要提供实时性保证</p></blockquote><h2 id="8-3-RA集体协议和设备到设备恶意软件迁移"><a href="#8-3-RA集体协议和设备到设备恶意软件迁移" class="headerlink" title="8.3 RA集体协议和设备到设备恶意软件迁移"></a><strong>8.3 RA集体协议和设备到设备恶意软件迁移</strong></h2><p>集体RA协议(CRA)(又名群体认证)[13,39 - 44]是一组技术，用于验证作为一个更大系统的一部分一起运行的大量设备。CRA方案通常在单个设备上采用混合RA架构，并研究如何有效地验证许多设备。一个安全问题通常超出单设备RA的范围，在CRA设置中变得相关，它是由迁移恶意软件引起的。这是一个类似于在集体设置中出现的设备内自我重新定位恶意软件(在第8.2节中讨论)。<strong>具体来说，它不是在同一设备的内存中移动，而是从一个设备迁移到另一个设备，以避免被检测到</strong>。 为了保证迁移恶意软件的检测，<strong>CRA结果必须使Vrf相信所有设备在同一时间窗口内都处于安全状态，这意味着恶意软件没有目标设备进行迁移和躲避检测</strong>。因此，如果单台设备的验证结果只在请求和验证算法执行之间的某个点传达安全状态，那么几乎不可能(特别是在网络延迟的情况下)得出迁移恶意软件不存在于群中的结论。虽然CRA文献中讨论了这个问题，但现有的方法要么将其置于对抗性模型[13,39,40,43]之外，要么对群中所有设备的时钟同步做一个强烈的假设[26,41,42,44]，这样所有设备都可以被安排在同一时间运行作证。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655030753804.png" alt="image-1655030753804"> 我们声称，通过解决单设备设置中的TOCTOU问题，RAT AB可以用来构建第一个不依赖整个蜂群同步的安全的抗迁移恶意软件的CRA协议。要了解为什么会出现这种情况，请考虑Construction 3。在这种构造中，单个设备上的TOCTOU - Security允许Vrf得出每个Prv在固定的时间间隔内处于有效状态的结论。因此，Vrf可以通过检查所有Prv-s 有效区间内的重叠情况，来学习整个蜂群安全的时间窗口，或者在不存在这种时间窗口的情况下检测迁移恶意软件。定理8.1阐明了Construction 3所提供的具体保证。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1655030777814.png" alt="image-1655030777814"></p><h2 id="8-4-运行时认证"><a href="#8-4-运行时认证" class="headerlink" title="8.4 运行时认证"></a><strong>8.4 运行时认证</strong></h2><p>运行时认证侧重于检测运行时&#x2F;数据-内存攻击，提供软件在Prv上执行的认证信息。虽然它似乎与检测回溯程序内存修改无关，但我们认为RAT A还可以改进运行时验证技术。 嵌入式系统的执行证明(PoX)最近在<a href="https://www.landery.cn/console/APEX">6</a>中得到了探索。PoX证明对Prv的给定操作是通过执行预期的代码来执行的，并验证此执行确实产生了输出。[3] (C-FLAT)中引入的控制流认证(CFA)允许Vrf还验证在Prv上执行的软件是否采取了特定(或一组)有效的控制路径，从而能够检测代码重用攻击。 我们注意到，常规(或静态)RA是这些功能的常见垫脚石。在C-FLAT、OAT[45]和Tiny-CFA[4]中，可执行文件必须使用特定的指令来实现CFA，并使用RA来验证这些指令没有被删除或修改。此外，即使使用相同的控制流执行，如果它们的指令不同，在行为或输出方面也可能不同。同样，在APEX中，Vrf的执行证明是通过执行元数据的验证来获得的。然而，如果不验证相应的可执行文件(在程序内存中)，这样的证明将没有任何意义，只有“某些代码成功执行”。 在许多应用程序中，相同的可执行文件预计会在内存中保留很长一段时间，而对于每个安全关键嵌入式操作[45]，必须反复验证它的正确执行(或控制流)。在8.1中讨论的优化可以最小化这种连续的运行时验证的开销。 为了说明这个概念，我们将RAT A与APEX和在APEX上实现的Tiny-CFA结合起来。在APEX中，在没有向Vrf证明它成功执行的情况下执行同一软件的所有运行时开销都是由静态RA的开销造成的。由于APEX是在VRASED之上实现的，所以我们在不改变RAT A硬件模块和APEX硬件模块本身内部行为的情况下实现了一个RAT A -compliant版本的APEX。因此，这种方法大大降低了PoX和CFA的计算成本(节省的成本与图8一致)，同时需要与表2中报告的相同的额外硬件成本。</p><h1 id="9-相关工作"><a href="#9-相关工作" class="headerlink" title="9 相关工作"></a><strong>9 相关工作</strong></h1><ul><li>RA (Remote authentication)：远程认证技术可以分为基于硬件、基于软件和混合三种。基于硬件的技术[11,21,46,47]要么使用专用的自主硬件组件(如TPM[11])执行RA，要么需要对底层指令集架构进行实质性的更改，以支持可信软件的执行(如SGX[48])。这样的改变对于成本敏感的低端嵌入式设备来说太昂贵了。另一方面，基于软件的技术[49-51]不需要硬件安全特性；它们使用完全在软件中实现的自定义校验和函数来执行RA。基于软件的技术的安全性依赖于精确的测量计时，这只适用于Vrf和Prv之间的通信延迟可以忽略和&#x2F;或恒定的设置，例如，外设和主机CPU之间的通信。因此，基于软件的RA不适合必须通过internet执行RA的环境。然而，混合RA特别适合低端嵌入式设备。它提供了与基于硬件的RA相同的安全保证，同时最小化对底层MCU硬件的修改。目前的混合RA技术[7 - 10,14,52]在软件中实现完整性保证功能(例如MAC)，并使用可信的硬件来控制该软件的执行，防止任何可能导致RA安全问题的违反，例如，基于小工具的攻击[53]或密钥泄漏。本文提出了一种混合式RA的范式转换，通过可信硬件附加提供一些关于Prv内存状态的上下文。</li><li>RA的时间方面：除了TOCTOU，其他两个时间方面对RA的安全性至关重要:第一，时间一致性[22]意味着保证RA结果反映了RA期间某个时间点的Prv验证内存的瞬时快照。缺乏它允许自我重新定位的恶意软件在RA期间通过复制和&#x2F;或删除自己来逃避检测。时间一致性是通过强制执行认证代码的原子(不可中断)执行，或通过在RA执行期间锁定认证内存(即使其不可修改)来实现的。其次，当RA用于安全临界和&#x2F;或实时设备[38]时，原子性要求可能会干扰Prv应用程序的实时性。为了解决这个问题，SMARM[37]通过使用概率恶意软件检测放宽了这一要求。同时，ERASMUS[12]和SeED[26]基于Prv的自我测量，用于检测感染Prv并在下一个RA实例之前离开的瞬时恶意软件。关于这些类型的技术的进一步讨论，请参阅第4.3节。Atrium[35]处理物理-硬件对手，当指令在认证期间被提取到CPU时，它们会拦截指令。中庭将这个问题称为toctu。尽管有术语，但这个问题明显不同于RAT A目标。</li><li>形式化验证和RA：形式化验证提供了更高水平的保证，为协议规范及其实现提供了可证明的安全性。最近，一些工作集中在安全关键服务和系统的正式验证上[23,54-58]。vrased[10]实现了一个正式验证的针对低端设备的RA架构。通过扩展VRASED，获得软件更新、内存擦除和全系统MCU复位[1]的远程证明，从而获得其他经过正式验证的安全服务。APEX[6]构建在VRASED之上，为低端设备[6]上的远程软件执行的证明开发了一个经过验证的架构。RAT A还建立在VRASED之上，扩展它以提供TOCTOU安全，同时保留原来的经过验证的保证。基于VRASED，我们可以对RAT A设计进行推理，并正式验证其安全性能。尽管如此，RAT A的主要概念适用于其他混合(可能是基于硬件的，如[20])RA架构。</li></ul><h1 id="10-总结"><a href="#10-总结" class="headerlink" title="10 总结"></a><strong>10 总结</strong></h1><p>在本文中，我们设计、证明并正式验证了两种设计(RAT AA和RAT AB)，以确保RA在连续的RA实例之间免受TOCTOU相关的攻击，这些攻击在一个低端嵌入式系统上执行非法的二进制修改。RAT AA和RAT AB模块使用模型检查器正式指定和验证。它们还由VRASED -经过验证的RA架构组成。我们使用基于约简的密码证明证明这个组合是TOCTOU-Secure的。我们的评估表明，TOCTOU安全设计即使对于成本敏感的低端嵌入式设备也是负担得起的。此外，在大多数情况下，在验证内存的大小方面，它将RA时间复杂度从线性降低到常数。</p>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>远程证明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程证明_05_物联网远程认证技术综述:攻击、对策与展望</title>
    <link href="/0005.html"/>
    <url>/0005.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 远程证明_05_物联网远程认证技术综述:攻击、对策与展望 date: 2022-06-05 19:44:21.133 updated: 2022-06-06 00:54:01.347 url: &#x2F;archives&#x2F;yczm05 categories:</p><ul><li>远程证明 tags:</li><li>可信计算</li><li>远程证明</li></ul><hr><h1 id="原文信息"><a href="#原文信息" class="headerlink" title="原文信息"></a><strong>原文信息</strong></h1><ol><li>文章标题：A survey of remote attestation in Internet of Things: Attacks, countermeasures, and prospects</li><li>文章中文翻译：物联网远程认证技术综述:攻击、对策与展望</li><li>文章等级：CCF B</li><li>文章发表时间：2022</li><li>文章作者：Kuang B, Fu A, Susilo W, et al.</li><li>完整引用：Kuang B, Fu A, Susilo W, et al. A survey of remote attestation in Internet of Things: Attacks, countermeasures, and prospects[J]. Computers &amp; Security, 2022, 112: 102498.</li><li>全文请查看：<a href="https://www.sciencedirect.com/science/article/pii/S0167404821003229">全文链接</a></li></ol><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a><strong>1 介绍</strong></h1><p>针对近年来的IoT方面提出的远程证明进行了比较全面总结，然后指出：<strong>现有的调查都没有对攻击进行深入的研究，也没有全面和精细的对抗模型作为分类的指导</strong>。随着新的攻击的提出（如运行时攻击），攻击的类型变得更加多样化、精确和隐蔽。RA方案也更加多样化和复杂。此外，RA的应用范围也在扩大（例如，可验证的更新、重置和内存清除）。一些新技术在RA中的应用和结合（例如，机器学习），给RA带来了更多的可能性。此外，一些新的RA架构（例如，形式上验证的架构）被提出来，以实现更丰富的安全功能。 在这种情况下，我们的目标是<strong>提出一个通用的对抗模型来支持RA分类</strong>。在设计RA方案时，对抗性模型是一个普遍的要求。然而，<strong>几乎每一种方案都有一个特定的对抗性模型，这使得它们之间的关系和组合极其复杂</strong>。 主要贡献：</p><ul><li>提出了一个基本的RA模型，并进一步通过抽象现有攻击特征建立了一个针对物联网设备的精密对抗模型。</li><li>从保护能力、性能、网络适应性和认证质量等方面提出了评价标准。</li><li>基于对抗性模型，将现有的RA方案分为5类，并对每一类方案进行分析，并比较了其优缺点。</li><li>在此基础上，总结了研究中存在的问题和挑战，并展望了今后的研究方向</li></ul><h1 id="2-远程证明"><a href="#2-远程证明" class="headerlink" title="2 远程证明"></a><strong>2 远程证明</strong></h1><h2 id="2-1-基本的远程证明"><a href="#2-1-基本的远程证明" class="headerlink" title="2.1 基本的远程证明"></a><strong>2.1 基本的远程证明</strong></h2><p>基本的RA模型是单认证模型，即一个verifier对应一个prover，但是随着网络规模的增加，变了一个verifier需要对应多个prover，也就是群认证方案。</p><h2 id="2-2-安全属性"><a href="#2-2-安全属性" class="headerlink" title="2.2 安全属性"></a><strong>2.2 安全属性</strong></h2><p>安全健壮的RA服务需要包含如下属性：</p><ol><li><strong>真实性</strong>。验证方必须保证挑战是由授权的verifier生成的，从而防止验证方冒充拒绝服务(DoS)。此外，验证者还需要确保被验证者的回应是忠实可信的。这意味着攻击者不能伪造一个被验证者接受的响应。</li><li><strong>原子性</strong>。认证方案必须防止攻击者阻碍认证过程的执行。因此，认证过程不能被中断，以防止攻击者修改当前内存，在执行期间移动恶意软件。</li><li><strong>时效性</strong>。验证响应必须反映prover的当前状态，以防止重复攻击。换句话说，当收到来自verifier的挑战时，prover必须执行一个新的过程来产生一个新的验证响应。此外，挑战必须刷新。</li><li><strong>确定性</strong>。对于每一个挑战，相应的响应是确定的。这使得verifier能够准确地预测prover的响应内容。</li></ol><p>此外，随着新兴的应用，更多的认证方案被提出，更多的目标被要求。下面我们列出了最常见的几种。请注意，这些要求是特定于特定的认证协议，为不同的应用程序定制，而不是任何认证协议。</p><ol><li>可伸缩性。针对大规模网络，提出了一些认证方案。因此，认证协议需要对大量设备具有可扩展性。</li><li>非均质性。一些复杂的网络由许多异构设备组成。因此，认证方案需要适应不同的软件和硬件。</li><li>动态性。设备的移动和网络拓扑结构的变化是一个值得注意的问题。因此，认证方案必须适应网络的动态特性。</li></ol><h2 id="2-3-敌手模型"><a href="#2-3-敌手模型" class="headerlink" title="2.3 敌手模型"></a><strong>2.3 敌手模型</strong></h2><p>对手的主要目标是破坏物联网设备(证明者)执行一些恶意操作或阻碍其正常执行。对RA的不同攻击类型的概述见图2。 考虑两种攻击者：</p><ul><li><strong>普通攻击者</strong></li><li><strong>知识攻击者</strong></li></ul><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654430348772.png" alt="image-1654430348772"> <strong>普通攻击者</strong>主要是缺乏对RA认证机制缺乏足够了解的攻击者，他们可以在任意时间去攻击设备，常见的攻击方式包括软件攻击、运行时攻击和物理攻击。</p><ol><li>软件攻击：攻击者替换或者添加恶意代码，并根据需要执行他们。这种攻击通过软件入侵来篡改设备的内部内存，从而危及设备</li><li>运行时攻击：攻击者通过操作数据变量、循环计数器或代码指针，（如图2中的①，②，③）来改变设备的行为。代码重用攻击(CRA)是一种典型的运行时攻击，主要包括面向返回编程(ROP)攻击和面向跳跃编程(JOP)攻击。这种攻击可能导致恶意执行流或非法执行特权路径。</li><li>物理攻击：这是通过物理访问的方式对设备进行攻击。物理攻击可以分为非侵入式、半侵入式和侵入式物理攻击。半侵入式和侵入式物理方法都需要物理地捕获设备，以便在受保护的内存中提取敏感信息或修改硬件组件。非侵入性攻击，如侧通道攻击，可以在正常操作期间偷偷地推断设备的私人数据。非侵入性攻击通常通过一些物理手段来抵抗，例如屏蔽电路，而远程证明并不能防止这些攻击。因此，本文提到的物理攻击都是半侵入式和侵入式攻击。</li></ol><p>相比之下，如果<strong>利用RA机制</strong>，<strong>知识攻击者</strong>可能会利用这些机制的一些弱点来达到目的。最常见的方法是verifier-impersonation DOS攻击和transient &amp; self-relocating malware。</p><ul><li>Verifier-impersonation DoS攻击。研究人员发现，攻击者可能会伪装成verifier，通过频繁发送伪造请求，迫使prover执行验证程序。不受限制的认证过程可能妨碍正常任务的执行，导致DoS攻击。</li><li>瞬态和自定位恶意软件。对手在验证过程中移动恶意软件的位置，并将它们放入已验证或未验证的区域。请注意，这种攻击与远程认证的原子性属性相冲突，我们将在第8节详细说明原因和缓解方法。</li></ul><p>此外，对手也试图通过一些传统的方法来绕过RA机制，如预计算、重放、共谋等。对于这些攻击，大多数RA方案都采用了加密技术来抵抗。</p><h1 id="3-远程证明协议评价指标"><a href="#3-远程证明协议评价指标" class="headerlink" title="3 远程证明协议评价指标"></a><strong>3 远程证明协议评价指标</strong></h1><p>评估一个给定的认证协议有不同的关注点。接下来，我们从<strong>防护能力、精度、成本、网络拓扑和群认证质量(QoSA)</strong> 等方面讨论了如何评估群认证方案，是否可行，是否能被广泛采用和部署。特别对保护进行了分类总结。在查阅文献的过程中总结了精度和网络拓扑结构。成本是大多数文献常用的重要评价标准。QoSA的概念最初由Carpent et al.(2017)提出，我们在总结现有文献的基础上对其进行了进一步的扩展。</p><h2 id="3-1-防护能力"><a href="#3-1-防护能力" class="headerlink" title="3.1 防护能力"></a><strong>3.1 防护能力</strong></h2><p>其防护能力取决于所采用的防护策略和设计目标。通常，<strong>我们根据RA能够检测或阻止的攻击来评估RA方案，就像我们在对抗性模型中描述的那样</strong>。</p><h2 id="3-2-准确性"><a href="#3-2-准确性" class="headerlink" title="3.2 准确性"></a><strong>3.2 准确性</strong></h2><p><strong>对于大多数RA协议不考虑验证准确率</strong>。即使只有一个prover，大多数RA方案针对的都是单一类型的攻击，因此在严格的认证过程中出错也在所难免。因此，在不考虑网络不稳定性的情况下，这些方案的准确率几乎为1。 <strong>对于某些具有共同特征（即概率或不确定性）的特殊RA方案，准确率是至关重要的</strong>。主要包括两类：验证区域的随机化和验证设备在验证场景下的概率。对于这些方案，准确性在很大程度上指的是假阴性，因为RA会输出一个决定性的结果，几乎不会出现假阳性。</p><blockquote><p>当你真的没有的时候，别人却说你有—假阳性(false positive) 当你真的有的时候，别人却说你没有—假阴性(false negative)<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654433634080.png" alt="image-1654433634080"></p></blockquote><h2 id="3-3-代价、成本"><a href="#3-3-代价、成本" class="headerlink" title="3.3 代价、成本"></a><strong>3.3 代价、成本</strong></h2><ul><li>内存开销：RA方案的内存开销主要来自密钥的存储、认证过程和一些协议参数。虽然内存成本仍然是一个评价因素，但随着存储成本的降低，它已不再是一个关键因素时间成本。</li><li>时间成本：时间成本是评估RA方案的一个重要因素。RA机制的原子性会在认证过程中影响设备的正常工作，这在群认证方案中表现得更为突出。在大多数群体认证方案中，只有当所有节点都完成认证后，整个群体才能正常运行。但是，每个节点的通信时间和计算时间的叠加导致了显著的总时间开销。</li><li>能源成本。RA机制的最初目的之一是节约资源受限设备的成本，因此能源成本是一个必不可少的评价因素。能源成本<strong>主要包括计算开销和通信开销</strong>。其中，由于提出了群认证方案，单个设备需要与相邻节点进行交互，通信开销受到关注。此外，现有方案的计算结果表明，计算开销占能量消耗的比例较大。这是因为计算开销包括一些沉重的加密操作的成本，如MAC或签名，特别是对于物联网设备。</li><li>硬件成本：研究人员发现纯软件RA方案不能再提供足够的安全能力时，他们开始寻求硬件的支持。在相同的安全级别下，研究人员总是希望将硬件成本降到最低。硬件成本主要包括两个方面。<strong>一个是对现有硬件单元的利用</strong>，如可信平台模块(TPM) (Arbaugh等人，1997年)，物理不可克隆函数(PUFs) (Gao等人，2020年)，软件保护扩展(SGX) (Costan和Devadas, 2016年)，以及任何可信硬件组件。<strong>二是采用现场可编程门阵列(FPGA)对系统结构进行了重新设计</strong>，这种RA方案通常通过额外需要的查找表(LUT)、寄存器和逻辑门的数量来评估其硬件成本。</li></ul><p>注意RA方案的时间和能量成本通常高度依赖于设备的硬件架构(例如，带有TPM的设备通常计算更快)。 因此，只有在相同的硬件架构设置下比较时间和能量成本才有意义。 以下两个评价标准是群认证所特有的。</p><h2 id="3-4-网络拓扑结构"><a href="#3-4-网络拓扑结构" class="headerlink" title="3.4 网络拓扑结构"></a><strong>3.4 网络拓扑结构</strong></h2><p>群认证特有的评价指标。 设备的移动性是一种固有的群体特性。然而，<strong>许多群RA方案要求群网络拓扑保持静态，在认证过程中设备不能移动</strong>。由于RA是通过挑战-响应方式完成的，因此它需要一个固定的通信信道。一些RA方案放宽了这一限制，设备只需要在自己的认证过程中保持静态，而无需等待整个认证过程的结束。</p><h2 id="3-5-QoSA"><a href="#3-5-QoSA" class="headerlink" title="3.5 QoSA"></a><strong>3.5 QoSA</strong></h2><p>Carpent等人(2017)提出了<strong>群认证质量(Quality of Swarm authentication, QoSA)</strong> 的概念。在前人工作的基础上，我们进行了进一步的总结，并将群体认证分为五类，以评估verifier接收到的群体信息的粒度。</p><ul><li>B-QoSA(Binary QoSA)。verifier可以得到一个布尔值来表示整个群体的可信度。对于这种认证结果，验证者不需要对群体中的每个设备进行详尽的验证。一旦检测到被入侵的节点，它可以立即确定群的最终结果，并终止对其他设备的认证。</li><li>C-QoSA (Count QoSA)。verifier可以获得群体中正常&#x2F;恶意设备的数量，但不知道被攻击的具体设备。</li><li>L-QoSA (List QoSA)。verifier可以得到正常设备的标识符列表。这是目前<strong>群认证方案中最常见的QoSA</strong>。</li><li>F-QoSA (Full QoSA)。verifier可以知道群中每个设备的确切认证结果和它们的连通性，即群拓扑。</li><li>N-QoSA (None QoSA)。被验证群体有能力自动排除受损设备。也就是说，verifier不需要知道群中所有被入侵设备的标识符。</li></ul><p>对于B-QoSA和C-QoSA，verifier只能将被验证群体作为一个整体来判断其安全性，无法对特定受损设备进行检查和采取行动来维护群体的安全性。 <strong>对于F-QoSA和L-QoSA，验证者可以移除或修复被泄露的设备，以保证安全性。但是对于F-QoSA和L-QoSA，通常需要更详细的汇总报告，这意味着通过网络传输更大的消息大小</strong>。 N-QoSA结合了自我修复和群算法。因此，支持N-QoSA认证的群认证对攻击具有较强的鲁棒性。代价就是群中的单个设备为了协同监视其相邻设备的安全性会产生额外的开销。</p><h1 id="4-软件攻击的认证"><a href="#4-软件攻击的认证" class="headerlink" title="4 软件攻击的认证"></a><strong>4 软件攻击的认证</strong></h1><p>之前提到了普通攻击者的3中攻击方式中的软件攻击。</p><h2 id="4-1-单prover认证"><a href="#4-1-单prover认证" class="headerlink" title="4.1 单prover认证"></a><strong>4.1 单prover认证</strong></h2><p>单prover认证方案关注verifier和prover之间严格的交互过程，以及设备上的认证过程。根据RA方案体系结构，主要有三种方法:基于软件的、基于硬件的和混合的。表1列出了不同的单证明者认证方案的体系结构，硬件成本的评估标准，以及它们是否基于正式验证的RA体系结构，分类如下。注意，非特定的硬件组件(如随机访问存储器(RAM)和闪存)不在表中列出。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654435182722.png" alt="image-1654435182722"></p><ul><li>基于软件的RA方案(Choi等人，2007;Seshadri等人，2005;2004;Steiner and Lupu, 2019)通常不需要精致的硬件安全组件，这有更广泛的应用，特别是对于资源受限的物联网设备。伪随机内存遍历(PMT)、严格响应时间和空内存空间填充是实现基于软件的认证的常用方法。</li><li>尽管基于软件的解决方案可以降低成本并被广泛采用，因为它依赖于非特定的硬件支持，但大多数解决方案都建立在强大的假设基础上。假设和对手的能力之间存在差距。例如，SWATT假设对手不能伪造比认证原型更快的有效认证响应，但是在实践中很难被接受。在这种情况下，需要基于硬件的认证，以更合理的假设来增强安全性。基于硬件的认证方案需要一些抗篡改的硬件模块，如TPM、puf、SGX。</li><li>基于硬件的认证可以提供比基于软件的建议更高的安全性，因为抗篡改的硬件可以确保认证响应的正确性。但是，对于在生产阶段没有提供定制硬件组件的物联网设备，基于硬件的解决方案是不适用的。混合认证方案同时利用了基于硬件和基于软件的认证方案的优点。</li></ul><h2 id="4-2-群认证-（swarm-认证）"><a href="#4-2-群认证-（swarm-认证）" class="headerlink" title="4.2 群认证 （swarm 认证）"></a><strong>4.2 群认证 （swarm 认证）</strong></h2><p>在5G技术引领下的大规模物联网设备中，<strong>单prover认证方案效率低下</strong>，因此，群认证方案近年来引起了广泛关注。<strong>群指的是一组具有潜在异构硬件和软件配置的物联网设备</strong>。在拓扑结构和成员关系方面，群可能是动态的。在群体认证协议中，验证者希望通过一次交互来验证整个群体。 与单prover认证不同，<strong>群认证结构专注于聚合群中所有设备的认证响应</strong>。在群体认证中，由于网络的复杂性(网络拓扑结构、消息传递方式、认证模式、聚合模式等)，需要对一个方案进行多角度的分析，从而产生不同的分类。接着，我们从聚合模式和认证模式两个方面分析了经典群认证方案的特点，并对这两类方案的其他特点进行了讨论。最后，我们按照时间顺序对不同的群认证方案进行了比较，如表2所示。我们采用了下面讨论的分类法以及第3节中提到的QoSA、网络拓扑和硬件成本的评估标准。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654435992594.png" alt="image-1654435992594"></p><h3 id="4-2-1-聚合模式-Aggregate-pattern"><a href="#4-2-1-聚合模式-Aggregate-pattern" class="headerlink" title="4.2.1 聚合模式 Aggregate pattern"></a><strong>4.2.1 聚合模式 Aggregate pattern</strong></h3><p>在群体认证中，每个设备都会产生一个响应，需要verifier进行有效的聚合。主要有三种聚合模式:生成树(spanning tree)、广播(broadcasting)和层次结构(hierarchy)。</p><ol><li>生成树。<strong>最常见的聚合模式是基于生成树结构的</strong>。我们以第一种群体认证方案SEDA (Asokan et al.， 2015)为研究案例，如图5所示。verifier随机选择一个设备作为启动设备(图5中的d1)，发送认证挑战启动群认证。初始设备将挑战传递给相邻设备，相邻设备再将挑战转发给其他节点，最终生成树型结构网络(如图5中的绿线所示)。然后，父设备等待子设备的响应。下层节点不断地将当前的计数数和自己的测试结果返回给上层节点。最后，作为生成树的根，初始设备可以获取整个群体的状态并发送给verifier。<strong>但是，这种聚合模式通常要求在验证期间拓扑是静态的。此外，多跳通信所带来的不可预测的网络延迟也给认证时间的估计带来了挑战</strong>。因此，它不适用于严格的响应时间策略。在这种情况下，确定性通信路径(Kumar et al.， 2021)利用IEEE 802.15.4时间槽跳(TSCH)链路层协议来解决这个问题。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654436179061.png" alt="image-1654436179061"></li><li>广播。<strong>通过广播聚合认证报告适用于在认证过程中设备可以移动的高动态网络</strong>。当一台设备收到其他设备的认证报告时，它会将这些报告与自己的认证报告聚合在一起，然后广播给通信范围内的所有设备。最后，任意一个设备可以聚合群中所有设备的认证报告。我们选择了SALAD(Kohnhäuser et al.， 2018)作为代表，它是第一种用于高动态网络的群体认证方案，如图6所示。verifier通过向其通信范围内的设备(即图6中的d5)发送起始消息来验证该验证。然后，接收设备传播发起消息并检查其软件完整性，以确定它们是否处于健康状态(即，由下一小节中的邻居验证的模式)。然后接收到的设备将向邻近设备(如d5和d2之间的通信)广泛传播认证报告。经过一段时间后，verifier可以连接到任意一台设备，获得包含所有健康设备列表的认证结果。几种高动态网络的RA方案都采用了广义铸造模式(Ambrosin等人，2017;2018年)或选择一个设备子集进行认证(Ammar等人，2018a)(而不是群体中的所有设备)。然而，它带来了<strong>巨大的通信开销</strong>。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654436539343.png" alt="image-1654436539343"></li><li>层次结构。<strong>这种层次结构适用于设备具有不同资源能力的网络</strong>，如图7所示。在这样的网络中，可以选择计算能力更强或安全特性级别更高的设备作为簇头节点(即图7中的Ci)。这样簇头节点就可以与簇内的设备(即图7中的Di)进行通信。不同的方案会选择不同的设备特性作为分类标准，如设备的安全性或性能。我们选择了三个代表性方案(Ammar et al.， 2021;Gong等人，2018;Tan等人，2019)来演示层次结构。根据职责，Gong等(2018)将设备分为三类:普通设备、簇头设备和数据聚合设备。普通设备向簇头设备上报认证响应，簇头设备向数据聚合设备上报认证响应。根据硬件资源，MART (Tan et al.， 2019)将设备分为三种类型：完全信任的设备(如基站)、配备TPM的设备和资源有限的设备。前两种设备用于验证最后一种设备的状态。DA(委托认证)(Ammar等人，2021年)使网关连接到认证代理(基于PoX体系结构Nunes等人，2020年)，然后在图6中充当集群头。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654436611648.png" alt="image-1654436611648"></li></ol><p>值得注意的是，<strong>层次结构也适用于高度动态的网络</strong>(例如，SHeLA Rabbani等人，2019年)。移动prover的验证响应可以通过一些静态边缘设备转移到原始注册的边缘verifier上。 然而，层次结构可能会带来一些冗余设备(例如，SHeLA需要在群中引入一些边缘设备)，或者导致更高的硬件要求只在高级设备中可用。此外，层次结构模式通常假设相邻层的节点可以在一跳内通信，这可能不是实际情况。</p><h3 id="4-2-2-认证模式-Attestation-modes"><a href="#4-2-2-认证模式-Attestation-modes" class="headerlink" title="4.2.2 认证模式 Attestation modes"></a><strong>4.2.2 认证模式 Attestation modes</strong></h3><p>当认证从个体设备扩展到群体设备时，提出了不同的认证模式。根据哪一方评估目标prover的状态，模式可以分为三类:<strong>邻居验证、验证者验证和设备本身验证</strong>。</p><ol><li>由邻居验证。邻居是设备的直接观察者。因此，一个设备的状态可以被它的相邻设备证明。<strong>这种认证模式广泛应用于生成树结构中</strong>(Asokan et al.， 2015;Carpent等人，2017)。一个设备的直接认证结果由其生成树中的父设备给出。由于邻居设备只提供认证结果，不需要传递详细的信息(如二进制码的哈希值)，因此认证报告很小，大大降低了通信开销。 此外，该认证模式也适用于某些有特殊目的、有兴趣的方案。US-AID (Ibrahim等人，2018)利用这种模式进行物理攻击检测，详见第6.1节。healing (Ibrahim et al.， 2019)是一种修复协议，可以恢复被入侵设备的恶意软件块，确保整个网络的安全。ESDRA (Kuang et al.， 2019)提出了一种分布式认证方案，使用<strong>多个邻居同时验证一个节点</strong>，然后通过基于权重的计算计算出最终的认证结果。其基本原理是，基于单个邻居的认证结果来确定验证方的状态太粗糙了，特别是考虑到这样的邻居设备不是完全可信的设备。</li><li>由verifier验证。为了减少认证报告的规模，集群认证大多采用邻居认证的方式。但这种方式存在安全漏洞，可能会影响邻居。因此，只有验证者给出的评估才被认为是可信的。这种认证方式的难点在于每台设备都需要详细的认证报告，使得认证报告的尺寸非常大。需要一种精确的聚合算法来克服上述问题。 在这种情况下，乐观聚合签名(OAS) (Ambrosin等人，2016)协议通过生成树结构保证聚合认证报告的安全性。父设备聚合子设备的认证响应，在最小化报告大小的同时增加了认证结果的可信度。相比之下，发布&#x2F;订阅协议(Dushku et al.， 2020)按照发布者和订阅者的顺序不断积累认证响应，既可以检测物联网设备的软件完整性，也可以检测与恶意设备的非预期交互。但是这种机制不能减少报告的大小。</li><li>由设备本身验证。在一些群体认证方案中(Ambrosin等人，2017;2018;Kohnhäuser等，2018;Nunes等人，2019a)，评估由证明者自己完成。在这些方案中，被证明者需要额外的硬件(例如，可信执行环境(TEE))来确保评估的可信性。因此，他们可以通过将测量值与期望状态进行比较来判断自己的可靠性。预期状态可以是verifier发送的有效软件配置(Kohnhäuser等，2018)，或预存储在设备内的一个(Ambrosin等，2017;2018;Nunes等人，2019a)。然后prover将评估结果转发给verifier。这种认证方式减少了设备迁移对RA进程的影响，适用于动态程度较高的网络。 在此基础上，进一步提出了自测量(Carpent et al.， 2018d)。prover不是直接将结果转发给verifier，而是验证他们自己，并在本地临时存储结果。经过几轮验证后，verifier会向prover发送请求，收集所有的验证结果。自我测量可以限制verifier-impersonation DOS攻击者的能力(在第7.2节中讨论)，也可以减少瞬态和自我重新定位恶意软件逃避认证(在第8.3节中讨论)的概率。</li></ol><h2 id="4-3-讨论"><a href="#4-3-讨论" class="headerlink" title="4.3 讨论"></a><strong>4.3 讨论</strong></h2><p>单prover认证方案通常采用移动verifier或多verifier来确保verifier在prover的通信范围内。不幸的是，当需要对多台设备进行认证时，单prover在认证方案中通常表现出较低的效率。随着物联网设备数量的爆炸式增长，对群认证方案提出了更高的要求。与单认证相比，群认证具有以下优点。(1)verifier可以验证群体作为一个整体的完整性。(2)群体认证在群体中效率更高。但是，在集群场景中需要考虑：</p><ul><li>如何从不同的设备安全有效地聚合认证报告?根据网络拓扑结构的不同特点，应采用不同的聚合模式和验证模式。</li><li>如何有效识别特定的受损设备?一些群认证方案只能确定群的完整性，而不能指出特定的被承诺的设备。然而，其他L-QoSA群体认证方案可以识别受损设备，使得认证报告非常大。</li><li>如何在一次认证迭代中测量具有不同软件配置的设备的完整性?让verifier知道每个对应设备的预期软件配置是不切实际的，因此解决方案应该与软件配置无关。</li></ul><h1 id="5-运行时攻击的认证"><a href="#5-运行时攻击的认证" class="headerlink" title="5 运行时攻击的认证"></a><strong>5 运行时攻击的认证</strong></h1><p>运行时攻击通常利用编程语言中的漏洞来改变设备的行为或窃取私人信息。运行时漏洞可以分为两类：控制流漏洞(Checkoway et al.， 2010;Snow et al.， 2013)和非控制性数据漏洞(Chen et al.， 2005)。运行时攻击会修改设备内存中的动态部分，如动态数据变量或栈中的值，这给验证这些动态数据的可信性带来了很大的挑战。已经提出了一些缓解运行时利用技术的方法，例如数据执行预防(DEP)(2007)、静态cookie (Cowan等人，1998)、地址空间布局随机化(ASLR) (PaX-Team, 2001)、控制流完整性(CFI) (Abadi等人，2005)、代码指针完整性(CPI)等。然而，由于保护机制在本地执行，它们的实现需要改变语言、编译器或二进制代码。这通常超出了资源受限的物联网设备的能力。因此，提出了动态RA方案。在本节中，我们分析了这种认证响应可以是程序的动态完整性证据或控制流路径的方案。</p><h2 id="5-1-动态完整性的证据"><a href="#5-1-动态完整性的证据" class="headerlink" title="5.1 动态完整性的证据"></a><strong>5.1 动态完整性的证据</strong></h2><p>虽然内存中的动态数据是不可预测的，但它们往往满足一些动态特性。verifier可以通过这些动态属性检测运行时的完整性(例如，ReDAS Kil等人，2009)。ReDAS确定了两种类型的动态属性：<strong>结构完整性和全局数据完整性</strong>。一个具有结构完整性的应用程序意味着它在运行时满足所有的结构约束。结构约束是应用程序二进制代码必须满足的属性，例如堆栈约束和返回地址约束。同样，全局数据完整性指的是满足所有的数据不变量。数据不变量是指数据变量的值或它们之间的关系。完整性度量组件在运行时检查各种应用程序中的这些动态特性，并提供完整性证据。 然而，识别和收集所有的动态属性并不容易。此外，寻找动态属性与各种运行时攻击之间的相关性，以及检测所有类型的攻击，是一项艰巨的任务。</p><h2 id="5-2-控制流路径"><a href="#5-2-控制流路径" class="headerlink" title="5.2 控制流路径"></a><strong>5.2 控制流路径</strong></h2><p>目前，针对运行时攻击，最常用的RA方法是基于控制流图(Control Flow Graph, CFG)，又称控制流认证。CFG是程序流程的抽象。在CFG中，节点表示代码块，边表示控制流转换。运行时攻击的主要目的是滥用现有代码来改变设备的行为，从而从本质上改变控制流。 我们以C-FLAT (Abera et al.， 2016)为例，介绍控制流认证的基本原理，这是第一种针对运行时攻击的控制流认证方案。如图8所示，运行时攻击者可以在第3行更改控制流，(i)将控制流更改为恶意代码，或(ii)将非特权路径更改为特权路径(即控制流攻击)。他还可以(iii)修改一些关键数据以影响控制流(即非控制数据攻击)。C-FLAT的关键洞察是验证verifier的控制流路径。verifier首先进行离线预处理，通过静态分析生成应用模块的CFG。然后，verifier测量每个可能的控制流路径，并通过测量函数-累积哈希函数存储它们，如图9所示。累积哈希函数H以节点id Ni和之前的哈希结果Hprev为输入输出一个新的哈希值，即Hi &#x3D; H(Hprev;Ni)。最后，它输出一个Auth，它可以被视为执行路径的标识。 在认证过程中，prover也使用相同的方法计算当前的控制流路径值。因此，verifier可以确定prover是否按预期执行。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654439589584.png" alt="image-1654439589584"></p><h2 id="5-3-讨论"><a href="#5-3-讨论" class="headerlink" title="5.3 讨论"></a><strong>5.3 讨论</strong></h2><p>如何收集一套完整的动态特性来精确测量运行装置是一个挑战。<strong>现有的动态完整性证据只能检测到部分运行时攻击</strong>。因此，控制流认证似乎是一个更好的选择。然而，(1)目前大多数控制流认证方法只能检测到控制流攻击，仍然存在非控制数据漏洞。在这种情况下，LiteHAX (Dessouky等人，2018)、OAT (Sun等人，2020)和不(Nunes等人，2021c)提出了数据流验证(DFA)来检测仅数据攻击，而它们不能保证数据机密性。(2)目前的控制流认证方法主要基于程序分段，这是一项非常复杂的操作，特别是对一些复杂的结构。如果没有适当的程序分割，verifier就无法得到设计良好的检测CFG。表3按时间顺序总结并比较了不同认证方案对抗运行时攻击的硬件成本和认证方法。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654439785979.png" alt="image-1654439785979"></p><h1 id="6-物理攻击的认证"><a href="#6-物理攻击的认证" class="headerlink" title="6 物理攻击的认证"></a><strong>6 物理攻击的认证</strong></h1><p>无论是半侵入式的还是侵入式的物理攻击，都需要在一段特定的时间内(从几小时到几周)捕获设备。群认证方案中采用的捕获检测方法主要有<strong>心跳技术和会话密钥更新技术</strong>两种。 可以通过检测方式防止物理攻击（离线），检测时间需要小于攻击成功时间。</p><h2 id="6-1-心跳技术"><a href="#6-1-心跳技术" class="headerlink" title="6.1 心跳技术"></a><strong>6.1 心跳技术</strong></h2><p>心跳技术的核心思想是，<strong>设备定期发出心跳信息，以证明自己在线</strong>。每台设备在收到来自邻居的新的心跳消息时都会发出一个心跳消息，或者时间已经过去了。心跳消息包括时间戳、计数器和设备标识符。然后，心跳消息可以由其他群中设备(Ibrahim et al.， 2016)或邻居设备(Ibrahim et al.， 2018)验证。 与其他攻击相比，物理攻击的认证可能需要更高的认证频率来检测设备的持续存在。因此，在评估认证方案时，时间开销是一个重要的因素。例如，DARPA (Ibrahim et al.， 2016)，第一个使用心跳技术的物理攻击认证方案，利用广播交换任意两个节点的心跳信息。因此，其时间成本较高，认证时间复杂度为O(n2)，其中n为群中设备数量。相比之下，US-AID (Ibrahim et al.， 2018)只与相邻节点交换心跳消息，因此其认证时间复杂度降低到O(1)。</p><h2 id="6-2-会话密钥更新技术"><a href="#6-2-会话密钥更新技术" class="headerlink" title="6.2 会话密钥更新技术"></a><strong>6.2 会话密钥更新技术</strong></h2><p>会话密钥更新技术可以很自然地排除离线设备(被视为物理攻击)。我们以第一个采用会话密钥更新技术的群认证方案SCAPI (Kohnhäuser et al.， 2017)为研究案例。它通过会话密钥sk和通道密钥ck之间的异或操作在两个设备之间设置一个对称加密密钥。 通道密钥建立后，通道密钥ck是静态的。会话密钥sk是动态的，由群中所谓的leader设备每隔的△T时间更新一次。将当前的sk记为skcur，然后将新生成的sk记为sknext。然后，领导设备对使用skcur加密sknext，并将密文传输给其他设备。然后，只有拥有正确skcur的设备才能正确地检索到最新的sknext。由于受到物理攻击的设备将在Tcap时间内离线，它不能再使用错误的会话密钥与网络中的其他设备通信。由于群中的所有设备都需要更新会话密钥，SCAPI的认证时间复杂度为O(n)，其中n为群中的设备数量。基于类似的思想，slimIoT (Ammar et al.， 2018b)提出了另一种针对物理攻击的基于高效广播认证方法的认证方案，其认证时间复杂度也是O(n)。EAPA (Yan et al.， 2019)将心跳技术与会话密钥更新技术相结合，使得交互仅限于邻居节点，认证时间复杂度为O(1)。</p><h2 id="6-3-讨论"><a href="#6-3-讨论" class="headerlink" title="6.3 讨论"></a><strong>6.3 讨论</strong></h2><p>与心跳技术相比，<strong>定期更新会话密钥可以自然地排除离线设备</strong>。然而，会话密钥更新技术会导致更高的计算开销，因为它依赖于更多的加密操作。从本质上讲，定期心跳消息和会话密钥更新策略在检测物理攻击方面有着相同的概念。<strong>它们都利用周期性信息来确定目标设备的存在，以反映物理攻击的发生</strong>。因此，周期性消息的校验和传输需要耗费大量的计算量和时间，可能会影响设备的正常运行。另外，会话密钥更新技术容易受到去同步攻击。如果攻击者阻止(通过，例如通道模糊或假中继)包含sknext的消息，由于不同的会话密钥，设备将在接下来的回合中无法与其他设备通信。表4比较了评估标准的能源成本、时间成本、网络拓扑、和不同QoSA——证人计划按时间顺序对物理攻击,在美国国防部高级研究计划局(Ibrahim et al ., 2016), SCAPI (Kohnhauser et al ., 2017),和silmIoT (Ammar et al ., 2018 b)利用广播提供的消息,他们的能源成本是不可估量的。此外，这些方案对硬件成本的评价标准都是相同的，即主控板、ROM和安全时钟。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654442223448.png" alt="image-1654442223448"></p><blockquote><p>N表示群中设备的数量，g表示邻居的数量。Ei、Emac、Esend、Erecv、Eenc、Edec分别表示一个设备、计算或校验一个mac、发送一个字节、接收一个字节、加密和解密的能量消耗。</p></blockquote><h1 id="7-verifier-impersonation-DoS-attack（验证者模拟DoS）的认证"><a href="#7-verifier-impersonation-DoS-attack（验证者模拟DoS）的认证" class="headerlink" title="7 verifier-impersonation DoS attack（验证者模拟DoS）的认证"></a><strong>7 verifier-impersonation DoS attack（验证者模拟DoS）的认证</strong></h1><p>在大多数传统的认证方案中，verifier总是可信的。然而，攻击者确实可以模拟verifier，然后发送一些虚假的验证请求，这些请求可能会触发prover中潜在的昂贵的验证过程，从而发起一种DoS攻击。我们将这种攻击称为验证者模拟DoS攻击。<strong>现有的认证方案通常检查认证请求的有效性，以防止verifier模拟DoS攻击</strong>。此外，<strong>非交互式认证方法</strong>被认为对验证者模拟DoS攻击具有天然的弹性。此外，<strong>自我测量</strong>可以通过减少挑战的数量来减轻验证者模拟DoS在关键时刻的影响。本节分别介绍上述三种策略的代表性认证方案。</p><h2 id="7-1-检查认证请求"><a href="#7-1-检查认证请求" class="headerlink" title="7.1 检查认证请求"></a><strong>7.1 检查认证请求</strong></h2><p>在对抗<strong>验证者模拟DoS攻击</strong>时，<strong>验证认证请求的真实性是一种直接的方法</strong>。最常见的方法是使用一些密码学方法，如公钥或对称密码学。其中，PUF已被多个RA方案聘用(Aman and Sikdar, 2018;Feng et al.， 2018)，因为它的随机性、独特性和易用性。它利用半导体制造过程中不可克隆的物理变化，生成“数字指纹”作为设备的唯一身份。 另一种方法是利用单向哈希链(Tan et al.， 2019)来验证认证请求。单向哈希链是一组哈希值，例如(V0, V1，…， Vi，…， Vk)，其中Vi &#x3D; hash (Vi−1)。每个请求包含一个散列值Vi。verifier在本地存储一个值Vj。只有当i &lt; j时，prover接受请求并将Vj替换为Vi。因此，恶意验证者很难找到或伪造有效的挑战码。 然而，<strong>仅仅验证请求的真实性并不总是足够的。攻击者可以通过转发被窃听的请求或重放之前的请求来通过真实性验证</strong>。因此，可以考虑Brasser等人(2016)采用挑战刷新机制来如下加强验证者模拟DoS攻击：</p><ul><li>Nonces。prover记录了所有nonces的历史。但是这种方法需要大量的存储空间，只能识别之前收到的挑战，无法识别其他设备转发的挑战。</li><li>Counters。verifier设置一个单调递增的计数器。每个验证请求必须包含计数器的当前值。只有当新请求的值大于上一个请求的值时，验证方才会接受新请求。</li><li>TimeStamp。将当前时间戳添加到请求中以提供新鲜度。但是它需要在verifier和prover上部署同步的时钟，这将导致额外的硬件开销。</li></ul><h2 id="7-2-非交互式认证"><a href="#7-2-非交互式认证" class="headerlink" title="7.2 非交互式认证"></a><strong>7.2 非交互式认证</strong></h2><p>另一种抵制验证者模拟DoS的选择是非交互认证模式(Ibrahim等人，2017)，它消除了在认证方案中发送挑战的过程。换句话说，<strong>prover的认证过程不再由verifier触发，而是由prover的计时程序自动触发</strong>。通过这种方式，它对验证者模拟DoS攻击具有固有的弹性。作为非交互认证方案的前提，<strong>verifier和prover都有一个松散同步的时钟</strong>。</p><h2 id="7-3-Self-measurement-自我度量"><a href="#7-3-Self-measurement-自我度量" class="headerlink" title="7.3 Self-measurement 自我度量"></a><strong>7.3 Self-measurement 自我度量</strong></h2><p>与非交互式认证类似，ERASMUS (Carpent等人，2018d)利用自我度量来减少挑战过程的数量，这迫使每个prover基于预先建立的时间表来验证自己。证明程序将结果存储在本地。然后verifier偶尔联系自我测量，收集所有存储的结果，验证设备在此期间的状态。因此，它可以在很大程度上防止验证者模拟DoS攻击。</p><h2 id="7-4-讨论"><a href="#7-4-讨论" class="headerlink" title="7.4 讨论"></a><strong>7.4 讨论</strong></h2><p><strong>防止来自未经授权的verifier的虚假验证请求</strong>是避免<strong>验证者模拟DoS攻击</strong>的主要策略。虽然检查认证请求的验证可以有效地抵抗这种类型的攻击，但对prover施加的开销可能很高。同时，大量的认证请求也会迫使prover持续地执行验证，这是另一种DoS攻击。相比之下，非交互式应答对验证者模拟DoS攻击具有固有的弹性。然而，prover的软件配置的测量应该与它的生成时间绑定，以确保新鲜度。因此，需要实时写保护时钟来提供verifier和prover之间的时间同步。此外，自我度量可以缓解验证者模拟DoS攻击，但不能完全抵抗它，因为验证者仍然需要使用挑战-响应机制收集信息。</p><h1 id="8-瞬态和自定位恶意软件的认证"><a href="#8-瞬态和自定位恶意软件的认证" class="headerlink" title="8 瞬态和自定位恶意软件的认证"></a><strong>8 瞬态和自定位恶意软件的认证</strong></h1><p>在现实场景中，认证过程的原子性和紧急操作之间存在重大冲突。一些安全关键的物联网设备必须严格更新数据，以确保一些关键功能的正确性和及时性，如火灾报警应用。正如Carpent等人(2018a)所报道的那样，给定1gb的认证内存，认证过程将花费大约7秒。对于火灾报警，7s的认证过程可能会造成灾难性的后果。然而，大多数现有的RA机制通常需要一个耗时的原子认证过程，以满足安全性要求。一旦原子性被放松，并且允许中断认证过程，瞬态和自我重新定位的恶意软件可能会逃避认证。恶意软件滥用中断在认证过程中战术地重新安置自己，转移自己到未被发现的区域或已被认证的区域。为了减轻<strong>瞬态和自定位恶意软件</strong>，<strong>内存滑动锁定、打乱式度量、自我度量和分布式度量都可以使用</strong>。</p><h2 id="8-1-内存滑动锁定-Memory-sliding-locking"><a href="#8-1-内存滑动锁定-Memory-sliding-locking" class="headerlink" title="8.1 内存滑动锁定 Memory sliding locking"></a><strong>8.1 内存滑动锁定 Memory sliding locking</strong></h2><p>Carpent等人(2018b)从各个方面讨论了“内存锁定”。其中，滑动锁是比较实用的一种思路。 它有两种方式:递减锁和递增锁。递减锁在开始时锁定所有内存模块(即暂时使它们只读)。然后，随着认证过程的执行，它会解锁每个被认证的模组。相反，增加锁不会在一开始锁定任何内存，而在认证期间锁定每个被认证的模块。</p><h2 id="8-2-打乱式度量-Shuffled-measurements"><a href="#8-2-打乱式度量-Shuffled-measurements" class="headerlink" title="8.2 打乱式度量 Shuffled measurements"></a><strong>8.2 打乱式度量 Shuffled measurements</strong></h2><p>打乱的测量方法利用了随机性。SMARM (Carpent等人，2018c)是一个具有代表性的例子。在认证过程中，SMARM采用shuffle测量方式，由prover在无序内存块上计算MAC。这样，攻击者就无法确定哪个内存块是“安全的”，从而无法以目标方式移动恶意软件。</p><h2 id="8-3-自我度量-Self-measurements"><a href="#8-3-自我度量-Self-measurements" class="headerlink" title="8.3 自我度量 Self-measurements"></a><strong>8.3 自我度量 Self-measurements</strong></h2><p>我们已经在第4.2节(证明)讨论过这种方法。由于交互过程复杂且耗时，自我测量可以显著减少认证时间，从而最大限度地减少认证过程对设备常规任务的负面影响。</p><h2 id="8-4-分布式度量-Distributed-attestation"><a href="#8-4-分布式度量-Distributed-attestation" class="headerlink" title="8.4 分布式度量 Distributed attestation"></a><strong>8.4 分布式度量 Distributed attestation</strong></h2><p><strong>一种针对群认证的分布式认证模式</strong>。在集群环境中，由于网络延迟和节点认证时间的叠加，中断和原子性之间的冲突变得更加激烈。因此，分布式认证模式的目标是减少群中每个设备的认证时间。最常见的分布式认证方案是ESDRA (Kuang等人，2019年)和SARA (Dushku等人，2020年)。两者都可以使设备在完成本地的认证任务后立即启动正常操作，而无需等待群中其他设备的认证结果。</p><h2 id="8-5-讨论"><a href="#8-5-讨论" class="headerlink" title="8.5 讨论"></a><strong>8.5 讨论</strong></h2><p>内存滑动锁本质上是在中断和RA原子性之间的一种权衡。它不能完全缓解中断引起的问题。如果紧急任务的代码准确地存储在锁定区域中，则冲突仍然存在。 打乱测量是一种概率方法，需要考虑准确度的评价标准，尤其是假阴性，如3.2节所述。任何试图最小化假阴性的做法都将不可避免地增加时间成本的评价标准。此外，打乱后的测量值需要额外的内存来存储内存块的排列情况。 自我度量和分布式认证都<strong>从减少设备认证时间的角度</strong>来缓解原子性带来的冲突。</p><h1 id="9-未来的研究"><a href="#9-未来的研究" class="headerlink" title="9 未来的研究"></a><strong>9 未来的研究</strong></h1><p>我们讨论了针对不同目标的各种RA方案。同时，分析比较了相应方案的优缺点。根据评价标准在3.1节中,我们总结和比较保护功能(软件攻击,控制流攻击,物理攻击,verifier-impersonation DoS攻击,和瞬态&amp; self-relocating恶意软件)认证计划从2015年开始按时间顺序如表5所示。 对于<strong>软件攻击</strong>，验证方必须生成针对其当前软件配置的测量结果。度量可以是目标内存内容的散列。对于<strong>运行时攻击</strong>，度量必须反映验证者的运行时行为。因此，可以对控制流路径进行哈希测量。<strong>物理攻击</strong>认证的基本观察结果是，受到物理攻击的设备会离线一段时间。此外，攻击者可以利用RA的缺陷来启动恶意操作，包括<strong>验证者模拟DoS和瞬态和自定位恶意软件</strong>。值得注意的是，认证提议可以组合在一起，一个方案可以有效地对抗多种类型的攻击</p><h2 id="9-1-如何检测自删除恶意软件"><a href="#9-1-如何检测自删除恶意软件" class="headerlink" title="9.1 如何检测自删除恶意软件?"></a><strong>9.1 如何检测自删除恶意软件?</strong></h2><p>虽然瞬态和自定位恶意软件已经有了一些解决方案，但它们仍然不能完美地解决这个问题。 更重要的是，它揭示了攻击者有能力知道认证的时间。在这种情况下，自删除恶意软件成为一种更难以检测的攻击方法。远程认证是一个周期性的过程，两次认证之间存在较长的“真空”期。 因此，在此期间，攻击者可以进行恶意操作，然后删除自己的痕迹，<strong>形成所谓的TOCTOU攻击</strong>。现有的方案很难检测到这种自删除恶意软件。RATA (Nunes等人，2021b)利用安全的日志记录机制来记录最新的内存修改。然而，RATA不适合自修改代码和即时(JIT)编译(jp, 2003)。因此，需要建立更可靠、更自动化、更智能的日志认证机制来区分异常修改和正常修改。</p><h2 id="9-2-如何针对高动态网络拓扑设计高效的RA方案"><a href="#9-2-如何针对高动态网络拓扑设计高效的RA方案" class="headerlink" title="9.2 如何针对高动态网络拓扑设计高效的RA方案?"></a><strong>9.2 如何针对高动态网络拓扑设计高效的RA方案?</strong></h2><p>现有的高动态网络拓扑的群认证方案通常采用广播的方式聚合认证报告。然而，这种广播方式大大增加了通信开销。 此外，转发到网络上的认证报告越多，攻击者成功窃取和分析认证报告的几率就越高。如果收到同一台设备的不同认证报告，如何区分正确的认证报告就成为一个难题。因此，需要设计一种更高效、更安全的高动态网络群认证方案。我们认为这个问题在移动通信网络中已经得到了解决。引入一些冗余和固定的“基站”可能是一个很好的选择，但有必要衡量开销是否可以接受。SHeLA (Rabbani et al.， 2019)似乎已经做出了第一次尝试，但仍有一些未解决的挑战，协议可以优化。</p><h2 id="9-3-如何检测非控制数据攻击"><a href="#9-3-如何检测非控制数据攻击" class="headerlink" title="9.3 如何检测非控制数据攻击?"></a><strong>9.3 如何检测非控制数据攻击?</strong></h2><p>攻击者可以操纵一些数据来改变设备的行为，获得高权限，或窃取敏感信息。被篡改的数据变量可以是直接影响控制流的控制数据，例如函数的返回或其他不直接改变控制流的非控制数据。 <strong>大多数运行时认证方案都局限于对控制流的评估</strong>。换句话说，<strong>它们无法检测非控制性数据漏洞</strong>。LiteHAX (Dessouky等人，2018)和DI- ALED (Nunes等人，2021c)建议记录所有经过修改的数据。但这可能会导致认证反应特别大。因此，正如OAT (Sun et al.， 2020)所做的那样，识别关键的非控制数据并在本地保证关键数据的完整性可能是一个更现实的选择。只有这样，成本才能得到控制，解决方案才能在实践中得到落实。 此外，从我们的角度来看，还有另一种可能的解决方案。尽管非控制数据攻击微妙地使程序执行偏离CFG，但它们使程序遍历不同于合法路径的控制流路径。因此，一个有趣的方向是看看是否有可能检测这种偏差，机器学习可以是一个有用的工具。</p><h2 id="9-4-如何针对物理攻击设计有效的RA方案"><a href="#9-4-如何针对物理攻击设计有效的RA方案" class="headerlink" title="9.4 如何针对物理攻击设计有效的RA方案?"></a><strong>9.4 如何针对物理攻击设计有效的RA方案?</strong></h2><p>现有的针对物理攻击的认证方案都是基于这样的假设：<strong>物理攻击需要使目标设备离线一段不可忽略的时间</strong>。然而，它们对网络延迟和包丢失的容忍度几乎为零，因为它们可能错误地认为暂时不可达的设备受到了物理攻击。此外，现有的心跳和会话密钥更新机制会带来显著的开销，因为心跳周期需要小于最小物理攻击时间，而这需要更高的认证频率。因此，从检查和验证设备的硬件配置等新的角度来检测物理攻击是值得考虑的。</p><h2 id="9-5-如何设计智能认证方案"><a href="#9-5-如何设计智能认证方案" class="headerlink" title="9.5 如何设计智能认证方案?"></a><strong>9.5 如何设计智能认证方案?</strong></h2><p>人工智能技术，如机器学习，在广泛的应用中表现出惊人的性能。值得将AI整合到RA服务中。假设验证者可以利用机器学习模型，通过任意的程序验证来判断设备的状态，而不是一个有固定起点和终点的程序。在这种情况下，它可以使攻击者能够预测、伪造或重放验证响应。此外，在运行时攻击检测中实现这种测试时方法更可取。因为这意味着认证程序可以直接对当前正在执行的程序进行验证，不会影响设备的正常运行。 此外，verifier还可以利用机器学习来收集prover的行为来预测prover的状态。这种智能认证方式可以减少prover的开销，降低对prover正常运行的影响。需要注意的是，考虑到各种攻击的复杂性，机器学习方法在确定设备状态方面的准确性需要进一步研究。</p><h2 id="9-6-如何选择群体认证机制"><a href="#9-6-如何选择群体认证机制" class="headerlink" title="9.6 如何选择群体认证机制?"></a><strong>9.6 如何选择群体认证机制?</strong></h2><p>大多数的群认证方案都采用集体认证机制，将整个群的信息收集到verifier那里。这是因为verifier必须确定每个设备的安全状态。虽然详细的报告是可取的，但当必须传输每个设备的详细报告时，它会引起大量的通信开销。另一种认证机制是交流机制(Kuang等人，2019)。它不聚合每个节点的所有状态信息，而是利用邻居节点充当监督者。检举制只要求检举人举报受损节点，而不需要传递良性节点的信息，大大降低了通信成本。然而，<strong>挑战是确保受损设备将被报告和区分恶意报告</strong>。</p><h1 id="10-总结"><a href="#10-总结" class="headerlink" title="10 总结"></a><strong>10 总结</strong></h1><p>本文综述了国内外RA方案的研究现状，提供了一个全面的综述。在对所有对抗性模型进行分析的基础上，我们设计了一个复杂的对抗性模型，将攻击者分为两类:<strong>普通攻击者(包括软件攻击、运行时攻击和物理攻击)和知识攻击者(包括验证者模拟DOS攻击、瞬态和自定位恶意软件)<strong>。然后，在建立对抗模型和评估标准的基础上，从</strong>攻击类型的角度</strong>对各种RA方案进行了分析和比较。</p><ol><li>具体来说，针对<strong>软件攻击的RA包括单prover认证和群认证</strong>。单prover认证时专注于生成一个可信的、可验证的验证响应，而群认证则利用并行计算和设备间交互来检查网络中所有设备的安全状态。</li><li>另外，<strong>大多数针对运行时攻击的RA方案都是基于CFG来记录程序的执行路径</strong>。</li><li>此外，<strong>所有针对物理攻击的RA方案都依赖于捕获检测来验证设备的在线状态</strong>。</li><li>此外，抵御<strong>验证者模拟DOS攻击和瞬态及自我重新定位恶意软件</strong>的策略是对现有RA方案的增强，但它们可能会招致一些额外的开销，如安全时钟。</li></ol><p>最后，我们确定并讨论了当前RA方案面临的多个挑战，这些挑战值得在未来的研究中加以考虑。</p>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>远程证明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程证明_04_虚拟化环境的安全认证</title>
    <link href="/0004.html"/>
    <url>/0004.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 远程证明_04_虚拟化环境的安全认证 date: 2022-05-26 22:07:48.437 updated: 2022-05-29 23:44:45.679 url: &#x2F;archives&#x2F;远程证明04虚拟化环境的安全认证 categories:</p><ul><li>远程证明 tags:</li><li>可信计算</li><li>远程证明</li></ul><hr><h1 id="原文信息"><a href="#原文信息" class="headerlink" title="原文信息"></a><strong>原文信息</strong></h1><ol><li>文章标题：Secure Attestation of Virtualized Environments</li><li>文章中文翻译：虚拟化环境的安全认证</li><li>文章等级：CCF C</li><li>文章发表时间：2020</li><li>文章作者：Eckel M, Fuchs A, Repp J, et al.</li><li>完整引用：Eckel M, Fuchs A, Repp J, et al. Secure attestation of virtualized environments[C]&#x2F;&#x2F;IFIP International Conference on ICT Systems Security and Privacy Protection. Springer, Cham, 2020: 203-216.</li><li>全文请查看：<a href="https://link.springer.com/content/pdf/10.1007/978-3-030-58201-2_14.pdf">全文链接</a></li></ol><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a><strong>1 介绍</strong></h1><ul><li>OPEN CIT</li><li>pTPM vTPM</li></ul><p>本文分析了现有的虚拟环境认证方法。我们对现有的单独认证方法进行了改进，增强了它对中继攻击的抵御能力。我们实现了Lauer和Kuntze提出的基于虚拟机监控程序的认证方法，以及我们改进的独立认证方法。最后，我们通过在生产级硬件上的性能度量来评估这两种方法的可行性。</p><h1 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2 相关工作"></a><strong>2 相关工作</strong></h1><p>现有的关于认证虚拟化环境的研究主要集中在提供虚拟化环境的隔离认证或单个虚拟机的认证。有些人提出了更复杂的解决方案，试图构建一个可信的虚拟机监视器(VMM)。 这些方法之一是来自Garfinkel等人的Terra。Terra通过虚拟机之间的隔离来保护虚拟机。它在加载单个内存块之前测量它们，并允许对外部评估人员进行远程认证。这种内存自省方法是计算密集型的，需要大量的主存。然而，Terra构建了许多其他工作的基础，这些工作进一步阐述了保护VM内存的想法，如Cerberus和TrustVisor。 其他方法，如Azab等人的基于hypervisor的完整性测量代理(HIMA)，测量运行在VM中的程序和服务。在被hypervisor执行之前，VM系统调用和硬件中断被拦截和分析。它需要hypervisor上的NX位(无执行位)支持，以便在测量的内存页执行之前标记它们。HIMA要求将程序的所有内存页加载到内存中。因此，必须对操作系统进行更改。HIMA需要大量的计算能力，必须仔细评估其适用性。 目前已有基于CPU的认证方式实现软件完整性保护，如Bastion、HyperWall等。这些CPU扩展允许在软件模块执行之前测量和验证它们，Zhang等人在中分析了它们对云解决方案的适用性。 由于基于TPM的内存验证技术很慢，因此希望以资源高效的方式为vm提供TPM功能。中的工作在VMM中引入了一个抽象层，在pTPM中添加了上下文切换功能。这给vm提供了一种错觉，即具有对真实pTPM的独占访问权。这种方法的问题是，与多个vm共享一个物理TPM会使pTPM成为瓶颈。随着Berger等人引入vtpm, vm的认证发生了一定的变化。有了vtpm，就可以在软件中为每个VM提供自己的TPM, TPM被安全地固定在pTPM中。自从2006年引入vTPM以来，Berger等人对它的实现做了细微的改变，将它变成了一个hypervisor扩展。因此，不需要额外的管理VM。由于vtpm的有效性，许多研究人员现在关注于集成vtpm来验证运行在vm中的软件。vm和vtpm的迁移是研究的另一个热点。 <strong>现有的大多数研究将vm和hypervisor的认证分开处理，几乎没有将这些认证绑定在一起的研究</strong>。验证者通过远程认证验证虚拟机的完整性后，才会信任虚拟机。但是，如果底层管理程序受到威胁，VM的完整性和可信性也可能受到威胁。如果攻击者设法破坏管理程序，她可能能够提取或操纵敏感信息，例如篡改VM主内存。 TCG (Trusted Computing group)的虚拟化平台工作组定义了一个深度认证方案，用于链接vm和hypervisor的认证。在《Remote and deep attestations to mitigate threats in cloud mash-up services》.中，Celesti等人描述了如何使用远程和深度认证来构建联邦云环境。 Lauer和Kuntze提出了基于hypervisor的认证(HYPA)[12]。它向管理程序添加了一个认证管理器(ATAMAN)，它直接读取运行的vTPM实例的内部状态。该方法属于自底向上的认证方法，目的是在运行数十或数百个虚拟机的情况下提高虚拟机认证的可伸缩性。 在HYPA进程中，验证者向hypervisor发送一个认证请求(参见图1)。作为回报，它接收一个认证响应(9)，包括所有运行的vm(2-7)以及hypervisor本身的认证(8)。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653574885124.png" alt="image-1653574885124"> Attestation Manager直接访问正在运行的vTPM实例以读取其内部状态，即vPCR。此外，它还从每个虚拟机内部读取虚拟存储的测量日志（vSML）。所有的vPCR和vSML被编译成一个数据结构，然后进行散列。由此产生的摘要被作为限定数据（nonce）传递给TPM Quote操作的管理程序证明，使用pTPM。认证管理器在hypervisor的范围内运行，因此，它是hypervisor认证的一部分。整个验证结果包括带有vPCR和vSML的数据结构，以及hypervisor的证明。Verifier同时验证hypervisor和VM的认证。 基于管理程序的证明方法的主要好处是，与单个虚拟机的证明相比，其可扩展性有了巨大的提高。这体现在减少了证明协议的开销，以及减少了I&#x2F;O操作。然而，<strong>它非常具有侵入性，需要访问当前运行的vTPM实例，以及访问虚拟机内部，即vSMLs</strong>。 虚拟机和管理程序的单独认证（SEPA）是Lauer和Kuntze在中描述的另一种方法。验证者向单个虚拟机（参见图2）发送一个验证请求，并收到一个验证结果（2）。然后验证者使用相同的nonce向管理程序发送验证请求（3），并收到验证结果（4）。通过使用相同的nonce，在虚拟机和管理程序之间实现了一个弱层链接。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653575271732.png" alt="image-1653575271732"> 正如作者所述，<strong>SEPA方法不是资源节约的，并使pTPM成为连续VM认证期间的瓶颈</strong>。每个单独的VM认证还需要额外的管理程序认证，这大大降低了这种方法的可伸缩性。<strong>另一个问题是层链接不是很强，Verifier需要不断更新VM运行的管理程序的信息</strong>。由于这种层链接既不是强制的，也不是可验证的，它破坏了pTPM和vTPM的强认证声明。Lauer和Kuntze提出了一种改进VM和hypervisor之间链接的方法，即向VM提供一个秘密值N，用于生成远程认证数据。虚拟机终止后，通过虚拟机与hypervisor之间的安全通道，向hypervisor提供一个秘密值N。然后，系统管理程序使用这个秘密值进行认证。这种方法的缺点是，Verifier不能平等对待VM和hypervisor。它需要更改来宾操作系统和管理程序。因此，使实现复杂化并降低了可伸缩性。 SEPA不需要更改现有的软件组件或协议，因此可以轻松地集成到现有的认证解决方案中。从Verifier的角度来看，可以平等地对待vm和hypervisor。在只运行少量虚拟机的系统中，这种方法代表了一种可行的认证解决方案。然而，我们注意到Lauer和Kuntze提出的单独认证会受到中继攻击。 还有其他更复杂的云完整性验证技术，但它们依赖于前面描述的技术。在下一节中，我们将介绍我们的参考体系结构，我们将使用它进一步评估SEPA和HYPA方法。</p><h1 id="3-参考系统架构"><a href="#3-参考系统架构" class="headerlink" title="3 参考系统架构"></a><strong>3 参考系统架构</strong></h1><p>我们的参考架构是基于英特尔和Hytrust在中提出的架构，该架构将数据分割成工作包来并行处理它们（参见图3）。我们建议使用虚拟机来实现这一目的，它可以根据当前的需求灵活地生成和拆分。工作流编排系统处理工作包的分配和调度。我们假设主机系统和虚拟机是由同一方拥有和运营的。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653575543710.png" alt="image-1653575543710"> 在将可能敏感的工作包委托给VM处理之前，工作流编排确保VM是可信的。这个过程很复杂，需要对特定VM的配置有深入的了解。这就是为什么Verifier专用于这个任务。它对主机和虚拟机进行验证，为工作流业务流程提供最新的完整性信息。<strong>验证者维护一个参考完整性测量(RIMs)数据库，代表已知的良好系统配置</strong>。通过与系统当前的运行状态进行比较，验证者可以判断主机和虚拟机是否可信。</p><blockquote><p>基准库</p></blockquote><p>主机配备pTPM，运行Linux操作系统。它们有一个支持tpm的BIOS和引导加载程序，并支持用于引导时间完整性的Measured boot，以及用于运行时完整性的Linux integrity Measurement Architecture (IMA)。虚拟机管理程序支持分配给虚拟机的vtpm，如QEMU&#x2F;KVM。vTPM在hypervisor上下文中执行，一个vTPM被分配给一个VM。vtpm提供与ptpm相同的功能。然而，他们缺乏真实随机数生成器(TRNG)以及来自TPM制造商的背书密钥证书(EK Cert)。此外，它们不能提供与pTPM相同的安全保证，因为它们只是软件。</p><h1 id="4-认证要求"><a href="#4-认证要求" class="headerlink" title="4 认证要求"></a><strong>4 认证要求</strong></h1><p>Coker等人已经假设了基于远程认证的解决方案的需求。Lauer和Kuntze在中对它们进行了分析和扩展。这些要求中的<strong>第一个是认证信息的新鲜度，这要求保持测量时间和使用时间之间的差距尽可能小，以最大限度地减少使用过时信息的风险</strong>。<strong>下一个要求是认证的全面性，使验证者能够以可复制的、可问责的和全面的方式推断系统的状态</strong>。<strong>认证信息还必须以逻辑形式呈现，以帮助验证者随着时间的推移将多个认证关联起来，从而进一步改进对不当行为的检测</strong>。由于认证公开了关于目标系统的敏感信息，因此它们的公开必须仅限于有效的验证者。为了在认证中建立信任，验证者依赖于可确保报告数据真实性和完整性的交付机制的可信性。 在云认证方面，Lauer和Kuntze进一步要求vm和hypervisor之间的层链接，以便信任vm认证。因此，必须为VM和hypervisor提供有效的认证信息。为了确保VM在其指定的管理程序上运行，必须能够将这些关联起来。Lauer和Kuntze的另一个要求是认证方案的可扩展性，它针对的是具有大量虚拟机的系统。就基于tpm的认证而言，这意味着减少对pTPM的调用数量。 此外，我们提出了特定于实现的需求：<strong>实现复杂性（Implementation Complexity）</strong> 和 <strong>客户机独立性（Guest Independence）</strong>。</p><ul><li>实现的复杂性：根据使用的认证方案和获取认证信息的方式，需要对客户OS或vTPM进行修改，这将增加开发成本。这也适用于在客户系统内安装其他软件，尽管这些并不像操作系统代码更改那样被认为是至关重要的。在典型的云环境中，客户希望根据应用程序需求选择软件和操作系统，而不是根据是否存在附加安全工具的实现。必须考虑到这些工具的影响和侵入性。越小、越少干扰的工具越容易移植。巨大的代码变化和对其他软件的依赖可能会在移植中产生更大的障碍。还必须考虑到软件所需的系统特权。</li><li>客户机独立性。为了减少攻击面，认证解决方案必须依赖尽可能少的附加基础设施。对其他基础设施的依赖关系也会影响解决方案的整体可靠性。增加实现的复杂性，导致系统变得更容易出错。不那么复杂的解决方案更容易维护。</li></ul><h1 id="5-安全独立的认证"><a href="#5-安全独立的认证" class="headerlink" title="5 安全独立的认证"></a><strong>5 安全独立的认证</strong></h1><p>在分析SEPA方法[12]时，我们发现VM和hypervisor之间的层链接机制存在缺陷。攻击者可以发起中继攻击来生成可验证的VM认证，从而欺骗验证者信任一个Bad VM。 我们假设一个威胁模型遵循[9]中Dolev和Yao的定义。攻击者完全控制网络，因此可以在网络上的任何地方读取、修改、插入或阻止消息。但是，她不能破坏任何底层的密码原语。而且，攻击者能够控制在VM中运行的系统，但不能控制hypervisor。 为了发起攻击，攻击者在目标系统的边界之外操作自己的虚拟机监控程序主机(Attacker Controlled System)，如图4所示。在该系统上，她运行VM的原始副本以及相应的vTPM，包括其配置和密钥。她进一步获得对原始系统上的虚拟机的访问，通过这种方式，她可以修改和运行内部被破坏的软件(参见图4中的bad VM)。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653576139280.png" alt="image-1653576139280"> 图4显示了中继攻击过程的时序图。每当验证者(V)向虚拟机发送它的认证请求时，Bad VM将这个请求转发给攻击者控制的系统上的原始虚拟机。从那里，VM将请求转发给它的vTPM, vTPM生成一个VmAttestation。VM将这个响应返回给Bad VM，Bad VM最终将VmAttestation转发给验证者。在原始系统上的hypervisor的后续认证中，将使用pTPM。验证者反过来验证两个认证，错误地认为Bad VM值得信任。 我们通过使用vTPM本身作为到管理程序的可信通道来解决中继问题。每当VM收到来自Verifier (V)的认证请求时，它会像往常一样在vTPM上触发TPM Quote操作(参见图5)。此时，为了缓解这一问题，我们让vTPM在hypervisor(3)上存储vTPM报价结果(VmAttestationhash)的散列。然后，继续正常的流程，VM将VM认证结果返回给验证者。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653576459909.png" alt="image-1653576459909"> 随后，验证者向hypervisor发送一个认证请求。hypervisor为VM使用最新的VmAttestationhash，并将其包含在hypervisor认证中。为了达到这个目的，hypervisor通过VmAttestationhash对来自Verifier的nonce的连接进行散列，从而创建一个复合nonce。这个复合nonce用于pTPM上的TPM Quote操作。结果返回给验证器。验证者验证虚拟机认证哈希是否匹配。为此，它创建一个从VM认证接收到的VM认证数据(VmAttestation)散列。Verifier与hypervisor完全相同地生成nonce，并将其与来自hypervisor认证数据的复合nonce进行比较。只有当复合认证匹配时，验证者才能确定收到了正确的虚拟机认证。通过这种方式，VM和hypervisor之间的层链接得到了显著改进。之后，Verifier继续验证VM和hypervisor的认证。 <strong>这种方式存在将指定给虚拟机的数据泄露给其他虚拟机或未经授权的第三方的风险</strong>。我们认为这种风险是最小的，因为认证方法确保VM和底层hypervisor主机都是值得信任的。可以使用加密和访问控制机制等其他安全措施来进一步保护转发的散列。不受信任的虚拟机监控程序可能会泄露从vTPM转发的信息，但会使用SEPA方案检测到。</p><h1 id="6-实现"><a href="#6-实现" class="headerlink" title="6 实现"></a><strong>6 实现</strong></h1><p>内存内省方法是计算密集型的，需要大量的主存，而且不容易实现。拦截从虚拟机到主机操作系统的系统调用需要更改hypervisor和主机操作系统。因为它们违反了我们的许多需求，所以我们不认为它们是我们实现的候选者。分层链接是至关重要的，我们选择SEPA和HYPA来实现，两者都符合我们的要求。 我们将SEPA和HYPA作为单一的概念验证来实现，扩展了英特尔的Open CIT 2.2。Open CIT提供主机启动时间认证功能，并使用Intel Trusted Execution Technology (TXT)建立硬件测量信任根(RTM)。支持VMware ESX、Citrix Xen、KVM (Kernel-based Virtual Machine)、Microsoft HyperV等hypervisor。认证信息通过web界面呈现。 Open CIT由两个主要组件组成：<strong>认证服务器(Attestation Server)和信任代理(Trust Agent)<strong>。认证服务器充当远程认证的验证者。它维护带有RIMs和认证结果的数据库，并通过REST API向依赖方公开这些结果。信任代理在任何经认证的计算机上运行，处理来自认证服务器的认证请求。即执行TPM Quote操作，收集并返回存储的测量日志(SMLs)。 我们向Open CIT添加了对验证VM的支持，包括HYPA和我们改进的SEPA层绑定机制，以将vm与其底层hypervisor关联起来。这需要同时更改信任代理和认证服务器。我们开发了一个vTPM实例管理器来为vm提供vTPM，使用QEMU和Stefan Berger的vTPM实现，以适应我们的需要。</strong>也就是说，对于HYPA，我们向hypervisor的Trust Agent添加了平台配置寄存器(PCR)读访问，对于SEPA，我们在hypervisor文件系统中存储VM认证散列</strong>。为了让HYPA访问vm中的vSML，我们使用hypervisor上的VirtIO与VM共享一个_tempfs_文件夹。此外，我们还添加了对IMA运行时完整性验证的支持。需要修改认证服务器、信任代理和虚拟机操作系统。</p><h1 id="7-评估"><a href="#7-评估" class="headerlink" title="7 评估"></a><strong>7 评估</strong></h1><p>在本节中，我们评估SEPA和HYPA认证方法。hypervisor主机使用libvirt、KVM和QEMU 2.6进行虚拟化。所有机器都运行Ubuntu 16.04。客户端虚拟机和hypervisor运行定制的Open CIT信任代理。为了比较SEPA和HYPA之间的性能度量，我们基于Open CIT为验证vm和hypervisor所执行的典型操作定义了评估场景:</p><ol><li>验证所有虚拟机;</li><li>验证单个VM;</li><li>验证Hypervisor。</li></ol><h2 id="7-1-Evaluation-Criteria-评估标准"><a href="#7-1-Evaluation-Criteria-评估标准" class="headerlink" title="7.1 Evaluation Criteria 评估标准"></a><strong>7.1 Evaluation Criteria 评估标准</strong></h2><ul><li><strong>执行时间</strong>。为了比较基于执行时间的认证方案，我们测量了每个场景的总体执行时间。这包括认证请求生成、响应处理、验证和网络传输。由于Open CIT在后端生成和验证TPM Quote响应会产生大量的开销，因此我们还要度量这两个事件完成所需的时间。</li><li><strong>网络流量</strong>。对于每个评估场景，我们捕获三个后续认证的整个网络流量。对于从authentication Server到hypervisor主机或VM的每个连接，我们计算接收和传输的数据量、吞吐量率以及第一次和最后一次传输之间的时间。在总结中，我们只包括所有连接的累计数据量。</li><li><strong>CPU和内存占用率</strong>。对于每次尝试进行3次验证，我们以兆字节为单位测量常驻(非交换)物理内存消耗以及CPU利用率的百分比。根据不同的场景，使用Linux top命令每100毫秒测量一次authentication Server和Trust Agent，计算平均值和峰值。有些任务占用超过100%的CPU，这意味着它们占用一个以上的CPU核。</li></ul><h2 id="7-2-评估结果"><a href="#7-2-评估结果" class="headerlink" title="7.2 评估结果"></a><strong>7.2 评估结果</strong></h2><p>在评估过程中，我们观察了这些方案的预期行为。表1显示了这些场景的测量执行时间。我们为每个场景生成10个度量值，并将它们积累到单个表中。也就是说，组中的每个值都是特定场景中所有测量执行时间的算术平均值。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653577208615.png" alt="image-1653577208615"> 表1数据显示，如果对所有虚拟机都进行了校验，则HYPA比SEPA快，因为它只对hypervisor进行一次校验。如果只验证了一个VM，或者只验证了hypervisor，那么SEPA要快得多。一个有趣的观察结果是检索TPM Quote响应和验证它所需的时间。这似乎在很大程度上不受已认证虚拟机数量的影响，SEPA显示了一个异常的最大值。然而，在实践中，如果要求的认证更少，或者IMA sml的规模变得非常大，那么HYPA的规模就会更大。当达到某个认证请求阈值(取决于虚拟机数量)后，SEPA的效率将低于HYPA。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653577403822.png" alt="image-1653577403822"> 对于CPU利用率，表3显示SEPA的平均CPU利用率和峰值总是较小，但一次验证所有vm除外。与SEPA相比，HYPA执行的认证操作更少，因此需要更少的CPU时间进行认证验证。表3中描述的内存消耗显示了意外的行为。在大多数情况下，HYPA比SEPA更有效。理论上，HYPA在验证时应该需要更多内存，因为它同时验证hypervisor和vm。我们只能用JAVA的垃圾回收来解释这种行为，或者是一般的操作系统内存管理扰乱了我们的测量结果。 表2显示，SEPA更有效地利用网络，直到达到认证请求的阈值。如果向hypervisor主机添加了更多的客户机vm，或者一次请求了更多的认证，那么HYPA将变得更高效。我们还测试了vm或底层hypervisor主机的完整性是否会影响测量结果。然而，我们无法找到非整数系统更昂贵的相关性或指标。结果是如此接近和难以区分，以至于这些差异可能是由不同的噪杂源引起的，从而导致测量的抖动，例如网络通信、其他应用程序和服务的主机利用率、Java Just in Time (JIT)优化、垃圾收集或操作系统调度。 我们还监控了客户端的Trust Agent。我们看不出这些方案之间有什么明显的差别。两种方案之间的CPU利用率和内存消耗没有差异。这也可能是由JAVA的开销和垃圾收集引起的。从逻辑上说，当认证管理器以SML和PCR值(需要加载到内存中)的形式收集认证信息时，内存消耗应该会稍微多一些。 <strong>两种方案的Nonce生成时间不同</strong>。HYPA需要更多的时间来收集和组合所有认证信息。它总体上是稳定的，只对方案的整体性能有很小的影响。随着运行虚拟机数量的增加，HYPA Nonce生成时间越长。因此，<strong>HYPA可能会在hypervisor Trust Agent上遇到可伸缩性问题。但只有在有许多客户机和非常大的SML的情况下。SEPA只有在许多主机需要在网络上进行认证时才有扩展性问题，但在单个信任代理上没有。</strong> 我们的结论是，对于少量VM, SEPA的性能优于HYPA。随着虚拟机认证次数的增加，SEPA性能下降。正如预期的那样，HYPA在所有测试中显示出稳定的性能。支持目标系统上的这两种认证方案，就可以定义有效的组合。</p><h1 id="8-未来工作和结论"><a href="#8-未来工作和结论" class="headerlink" title="8 未来工作和结论"></a><strong>8 未来工作和结论</strong></h1><p>本文分析了现有的基于可信计算的虚拟环境认证方法。我们发现现有的单独认证方法在概念上存在安全缺陷。 通过提出安全的独立认证，加强了hypervisor和VM层之间的层链接。改进了原有的单独认证方式的安全特性，为防止中继攻击提供了有效的对策。我们在生产级硬件上实现并评估了基于管理程序的认证方法以及安全的独立认证方法。通过性能度量，我们强调了我们的方法对于运行数量有限的vm的系统的可行性。此外，我们指出，通过只需要对管理程序软件进行最小的更改，我们的安全改进允许保持标准的认证协议。 未来的工作方向包括安全分离认证在虚拟网络设备、雾（fog）和边缘计算中的应用。随着容器技术的发展，我们的方法在完全成熟的机器虚拟化之外的适用性是另一个有趣的研究方向。</p>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>远程证明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程证明_03_使用Intel SGX对虚拟机进行远程认证和完整性测量</title>
    <link href="/0003.html"/>
    <url>/0003.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 远程证明_03_使用Intel SGX对虚拟机进行远程认证和完整性测量 date: 2022-05-20 00:09:09.607 updated: 2022-05-22 22:10:00.748 url: &#x2F;archives&#x2F;yczm03 categories:</p><ul><li>论文阅读</li><li>远程证明 tags:</li><li>可信计算</li><li>远程证明</li></ul><hr><h1 id="原文信息"><a href="#原文信息" class="headerlink" title="原文信息"></a><strong>原文信息</strong></h1><ol><li>文章标题：Remote attestation and integrity measurements with Intel SGX for virtual machines</li><li>文章中文翻译：使用Intel SGX对虚拟机进行远程认证和完整性测量</li><li>文章等级：CCF B</li><li>文章发表时间：2021</li><li>文章作者：Kucab M, Boryło P, Chołda P.</li><li>完整引用：Kucab M, Boryło P, Chołda P. Remote attestation and integrity measurements with Intel SGX for virtual machines[J]. Computers &amp; Security, 2021, 106: 102300.</li><li>全文请查看：<a href="https://www.sciencedirect.com/science/article/pii/S0167404821001243">全文链接</a></li></ol><h1 id="0-摘要信息"><a href="#0-摘要信息" class="headerlink" title="0 摘要信息"></a><strong>0 摘要信息</strong></h1><p>基于一组CPU指令，实现了虚拟机的启动时和启动后任何时刻的远程认证，信任等级评估。确定了安全属性，假设小的配置文件、二进制文件和可执行文件是最关键的。</p><blockquote><p>重点看如何实现运行时的远程证明。</p></blockquote><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a><strong>1 介绍</strong></h1><ol><li>我们提出了一种新的基于Intel SGX的远程认证过程，用于在虚拟机内运行的应用程序。</li><li>我们为流程启用了动态策略，可以对每个认证迭代进行调整。确定应该测试什么以及测试频率的策略文件由外部维护，可以在任何时间点进行调整。</li><li>我们评估了提出的机制引入的性能开销。</li><li>我们将所提出的解决方案的性能作为测量文件大小的函数进行评估。</li><li>我们评估了认证服务器的性能和扩展能力</li></ol><h1 id="2-背景"><a href="#2-背景" class="headerlink" title="2 背景"></a><strong>2 背景</strong></h1><p>先介绍了裸机的远程证明的实现方式 TPM、SGX、TrustZone的，然后引出裸机上的不适合直接运用在虚拟机上，在虚拟机上，有一个VTPM，但是VTPM存在迁移问题。他说的是针对多供应商云环境的迁移问题。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653015051499.png" alt="image-1653015051499"> 下面是原文：</p><blockquote><p>上述要求很难在多供应商云环境中得到满足，因为应用供应商可以以类似、统一的方式透明地控制所有云环境中的VM安全方面。对于应用程序供应商来说，这意味着认证功能非常有限，无法避免服务提供商锁定。这也意味着，如果不进行安全权衡，应用程序就无法部署在理想的、最近的云基础设施中。因此，性能和整体最终用户体验可能不太理想，因为用户被重定向到满足应用程序要求的数据中心，而不一定是最接近的数据中心。</p></blockquote><h1 id="3-SGX上的远程证明"><a href="#3-SGX上的远程证明" class="headerlink" title="3 SGX上的远程证明"></a><strong>3 SGX上的远程证明</strong></h1><p>文章说，与VTPM相反，SGX不需要任何额外的组件来创建和维护信任链，所以这使得它成为云部署的一个很好的候选者。 专用的受保护SGX内存（其中存储enclave页和SGX指令）称为enclave页缓存（EPC），其大小有限。对于裸机部署，它仅由操作系统使用，但对于多租户环境，它在所有VM之间共享。具有SGX支持的Hypervisor在创建特定VM后为其分配请求的EPC内存。分配的内存成为Guest VM的飞地。这就为来宾VM上的认证软件实现了绑定到主机硬件的安全执行。 然后，远程验证者可以信任认证过程的结果。在此基础上，验证者评估应用程序信任级别。 基于SGX的虚拟机远程认证过程由两个步骤组成。第一步的目标是在enclave可供认证客户端使用之前，为其提供认证。为此，我们使用了基于IAS的著名机制；但是，如第6节所述，也可以使用其他解决方案。第二步的目标是确保VM的远程认证。为此，我们提出了第3.4节描述的虚拟机远程认证模式。</p><h2 id="3-1-威胁模型"><a href="#3-1-威胁模型" class="headerlink" title="3.1 威胁模型"></a><strong>3.1 威胁模型</strong></h2><p>除了恶意软件、黑客、垃圾邮件发送者等传统对手外，云部署还存在特定于云的威胁。这些威胁包括恶意云提供商、恶意租户或内部人员。我们关注特定于系统的威胁，这些威胁可以直接影响其行为。在Intel SGX威胁模型中，只有enclave是可信的，我们假设对手可以<strong>访问虚拟机、虚拟机监控程序、云基础设施和未部署的硬件组件</strong>。系统软件被认为不可信，但SGX设计阻止其读取enclave内存和数据。这意味着在enclave内执行的任何处理都是安全的，任何不受信任的认证客户端调用都可能被恶意软件或rootkit破坏。当enclave正在查找一些无法直接用于enclave的信息时，需要进行此类调用。如果发生这种情况，建议的系统将检测到不正确的证明结果，并将特定VM表示为承诺的VM。假设对手可以传递给Enclave预期的信息，但在这种情况下，对手的操作必须在文件系统中留下一些痕迹。完整的系统认证检查应揭示这一点，并为此VM发出警报。 需要注意的是，对手不知道测试策略和预期结果。我们可以利用这一事实，还可以<strong>评估度量时间或任何命令执行</strong>，这可以让我们全面了解系统内部发生的情况。作为给定系统的示例，文件X的测量时间应为：$t_{min}&lt;t_{X}&lt;t_{max}$。对于单线程认证客户端，测量一组文件还将生成单个测量时间值的向量：$v&#x3D;t_A、t_B、t_C,….，t_N$。此信息可作为<strong>测试服务器验证的结果指纹使用</strong>。如果测量的时间超出预定义的时间范围，我们可以推断该值被注入。<strong>我们不考虑任何拒绝服务攻击，包括网络层或资源耗尽</strong>。VM仅在功能完备的端到端操作中受信任。由于Liu等人（2016）所述的解决方案，<strong>我们也没有实施任何机制来防止侧通道攻击</strong>；Oleksenko等人（2018年）；Schwarz等人（2020年）可用于缓解这些问题。 总结：</p><ol><li>可能利用度量时间和命令执行来验证系统是否符合预期结果</li><li>未考虑拒绝服务攻击，即使是正常是服务器资源耗尽等情况。</li><li>没有实施任何机制来防止enclave测信道攻击。</li></ol><blockquote><p>如果按照度量时间，那这个范围怎么确定，太大了会导致验证效果差，无法有效验证，太小了又会误判。</p></blockquote><h2 id="3-2-飞地（enclave）的远程证明"><a href="#3-2-飞地（enclave）的远程证明" class="headerlink" title="3.2 飞地（enclave）的远程证明"></a><strong>3.2 飞地（enclave）的远程证明</strong></h2><p>在可以使用enclave之前，还应该证明它是可信的，并向远程实体证明它是可信的。我们利用<strong>IAS</strong>，使用内置enclave和SGX属性，以加密方式证明我们的enclave是合法的。它还评估系统上运行的安全级别检查固件版本。对于标准的非对称加密，每个公钥都有一个对应的私钥，消息发起人的身份是可以确信的。为了保护用户和设备的隐私，使用了增强的隐私ID机制（Sarangdhar和Nemiroff，2014）。由于这种机制，单个公钥可以关联多个私钥。验证者将发起者认证为较大组的成员，以保持其匿名性，并保护用户和设备的隐私。 引起对签名者匿名或潜在服务滥用担忧的IAS（Swami，2017）有其他选择。可以使用基于Intel的DCAP（Scarlata et al.，2018）或OPERA（Chen et al.，2019）的第三方服务。它们允许构建自己的认证服务，并声称可以解决隐私问题和可能出现的大规模分布式部署性能瓶颈。虽然DCAP和OPERA声称的隐私和性能的改善，但该解决方案的完整性要么不明确，要么受到质疑（Swami，2017）。</p><blockquote><p>IAS远程认证服务，是Intel SGX的对enclave的远程认证服务。</p></blockquote><p>当enclave认证完成时，我们知道远程平台在支持Intel SGX的处理器上运行，并且具有已知的TCB级别（DoD 5200.28-M，1985）。还建立了一个经过身份验证的安全通信通道，从那时起，远程服务器可以以安全的方式向enclave提供机密。虚拟机认证过程现在可以开始了，因为它使用了认证的enclave。 总结：<strong>先进行enclave认证，再进行虚拟机认证</strong></p><h2 id="3-3-虚拟机的远程证明"><a href="#3-3-虚拟机的远程证明" class="headerlink" title="3.3 虚拟机的远程证明"></a><strong>3.3 虚拟机的远程证明</strong></h2><p>当enclave由认证服务创建和验证时，它可以用作认证客户端的安全执行环境。在enclave内部，我们使用内置密钥生成私钥，该私钥将用于加密数据，然后再将其暴露在enclave外部。私钥在enclave之外不可用，而相应的公钥与认证服务共享，以启用安全通信通道。通过此通道，可以将加密的策略文件发送到enclave，并执行预定义的文件系统检查。测试完成后，结果将以加密形式发送回认证服务器（AS） 为了评估收到的值，系统必须了解预期值。这些值可以在受信任（和受控）的实验室环境中捕获，然后由认证服务器用作参考值。基于这些知识，可以将远程VM文件系统的评估作为受信任的计算资源。</p><h2 id="3-4-模型描述"><a href="#3-4-模型描述" class="headerlink" title="3.4 模型描述"></a><strong>3.4 模型描述</strong></h2><p>定义如下术语：</p><ul><li><strong>认证客户端</strong>（Attestation client）是一种执行所需测试场景的软件。它安装在虚拟机中。</li><li><strong>认证服务</strong>（Attestation service）是一种控制认证过程并可以评估其结果的软件。它是一个验证器，可以评估安装在受信任和完全控制的环境中的VM信任级别。</li><li><strong>证明过程</strong>（Attestation process）是一系列步骤和操作，允许验证者评估enclave或虚拟机的信任级别。</li></ul><p>enclave认证过程应确认enclave本身是可信的，并且可以安全地用作认证客户端的执行环境。IAS（IAS）验证所创建的enclave，并可以开始正确的VM认证。在较高的级别上，新的过程从保密开始，即生成用于加密的密钥对，并与认证服务共享公钥。加密的策略文件被推送到认证客户端并传递给enclave，enclave可以解密并开始执行测试用例。enclave正在收集测试结果，并为系统调用进行必要的应用程序调用。最后，结果被加密并由认证客户端发送给认证服务，该服务可以在安全级别上进行评估。 总结：先通过IAS认证enclave，确保enclave可信，然后利用enclave生成公私钥，进行认证客户端和服务之间的通信，服务端先传送过来策略文件，认证客户端执行测试用例，最后将结果返回给服务端，服务端进行评估安全级别。</p><h2 id="3-5-模型细节（主要）"><a href="#3-5-模型细节（主要）" class="headerlink" title="3.5 模型细节（主要）"></a><strong>3.5 模型细节（主要）</strong></h2><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653014978223.png" alt="image-1653014978223"></p><ol><li>不受信任的认证客户端调用enclave来生成非对称密钥对。密钥由处理器通过EGETKEY指令生成，并密封到当前enclave或enclave签名者。因此，只有相同的enclave或由相同身份签名的enclave才能解封（解密）数据。这允许在enclave外部存储加密数据，并在需要时在enclave内部按需解密。请注意，此操作在启动时由VM应用程序启动，但也可以由认证服务按需远程触发。</li><li>作为对之前操作的响应，enclave将公钥返回给客户端</li><li>客户端通过网络将公钥发送到测试服务器，并请求测试策略。</li><li>AS使用从enclave接收的公钥加密测试策略，并将其发送回客户端。</li><li>认证客户端将加密的策略文件传递给enclave，enclave保存一个与公钥配对的私钥。</li><li>策略文件在enclave内解密，enclave开始执行请求的测试。单个测试可以包括计算文件列表的校验和。</li><li>在计算过程中，如果需要从enclave执行系统调用，enclave必须调用认证客户端（OCall）。此机制可防止在Enclave内执行任何代码和任何操作（例如IO操作、系统或外部库调用）。每个预期的系统OCall都是在应用程序中有意实现的。</li><li>客户端正在执行请求的系统调用，无需任何其他处理。</li><li>系统调用结果将发送回enclave。重复步骤7–10，直到测试过程完成。</li><li>测试结果由私钥加密并重新返回给客户端。</li><li>客户端通过安全通信通道将加密的测试结果发送给认证服务器。</li><li>AS解密结果并将其与已知的适当值进行比较，从而对VM信任级别进行评估。</li><li>认证服务器使客户机和其他系统可以使用评估状态，以便他们可以开始使用VM作为可信的计算资源。</li></ol><p>注意，任何网络通信都应该使用加密和安全的信道（图3中没有描述这一事实）。至少需要TLS通信和网络防火墙。</p><h2 id="3-6-安全属性"><a href="#3-6-安全属性" class="headerlink" title="3.6 安全属性"></a><strong>3.6 安全属性</strong></h2><p>为了能够基于CPU SGX指令对远程虚拟机进行完整性验证，建议的系统提供以下安全属性：</p><ul><li><strong>私钥保护</strong>。Intel SGX保证CPU生成的密钥永远不会在enclave之外共享。每次创建enclave时，都会生成一个新密钥，并且永远不会持久化。这发生在每次VM启动或按需启动时（在稍后启动认证时的任何时间点）。为了泄露密钥，攻击者必须在Intel SGX体系结构或认证客户端中发现漏洞。最近的研究表明，enclave RSA密钥可以在隔离的实验室环境中通过成功的侧信道攻击（Schwarz et al.，2020）重建。在实际部署场景中，这非常具有挑战性；然而，作者提供了可供应用程序开发考虑的对策。</li><li><strong>运行时保护</strong>。enclave就像认证客户的黑盒子；它接收加密数据，并用加密数据进行回复。校验和计算在屏蔽enclave运行时使用加密内存执行。只有简单的系统调用才能在enclave之外执行，从而最大限度地减少滥用的机会。当系统调用被篡改时，认证结果评估将揭示这一点，并且VM将不受信任。</li><li><strong>最小TCB</strong>。对于我们的模型，我们不信任云提供商。<strong>可信计算基础仅限于Intel CPU和SGX SDK</strong>，它们可以利用hypervisor公开的EPC内存。SGX SDK在为虚拟机创建的受保护运行时中执行CPU指令。认证客户端不知道底层硬件基础结构，不需要Intel CPU和SGX SDK以外的任何其他模块。有了这个属性，我们可以利用各种云模型，即裸机即服务&#x2F;MaaS、IaaS或具有比以前更高信任级别的系统容器。</li><li><strong>受信任的认证服务</strong>。在我们的系统中，认证服务是部署在应用程序供应商拥有并完全控制的可信环境中的唯一软件。这意味着<strong>该软件也可以被视为可信的</strong>。任何部署在云模型中的应用程序都会因特定于云的漏洞而面临风险（Singh和Chatterjee，2017），对于未部署在云中的认证服务器来说，这些漏洞不是问题所在。</li><li><strong>通信加密</strong>。每个网络通信通道都受到TLS保护，enclave输入&#x2F;输出额外加密。enclave返回的测试结果使用enclave私钥加密。认证客户端使用TLS会话密钥对它们进行进一步加密，然后再通过网络将它们发送到AS。TLS通信通过客户端证书认证得到增强，该认证将相互认证认证客户端和AS。对于生产部署，应确保TLS证书提供和传输机制。</li></ul><blockquote><p>这个3.6 感觉是在凑字数，因为上面都知道了。</p></blockquote><h1 id="4-系统评估"><a href="#4-系统评估" class="headerlink" title="4 系统评估"></a><strong>4 系统评估</strong></h1><p>测试场景的假设是测量文件系统中的<strong>关键文件、应用程序二进制文件、配置文件、库</strong>，以及通过<code>/proc/</code>文件系统提供的静态运行时信息。当为虚拟机引入SGX enclave时，测量结果用于评估性能开销。这是通过在以下三种情况下计算选定文件的校验和来完成的：</p><ul><li>无SGX。认证客户端直接部署在裸机操作系统上，没有任何虚拟化，并且不使用SGX进行计算。这被用作性能比较的参考场景。</li><li>物理SGX。认证客户端直接部署在裸机操作系统上，并使用SGX进行计算。</li><li>虚拟SGX。这是我们的建议，其中认证客户端部署在虚拟机中，并配置为使用虚拟机监控程序公开的SGX Enclave进行计算。</li></ul><p>每个场景包含50个重复100次的文件的度量。在物理SGX和虚拟SGX场景中，执行相同的步骤，但在前一种情况下，它们直接在主机上执行，在后一种情况下，它们发生在已经创建并准备使用的VM上。</p><h2 id="4-1-实现细节"><a href="#4-1-实现细节" class="headerlink" title="4.1 实现细节"></a><strong>4.1 实现细节</strong></h2><p>见下表，总共2200行C代码，3个模块。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653017815972.png" alt="image-1653017815972"></p><ol><li><strong>The untrusted Attestation Client</strong>,客户端包含一组例程，用于保护与认证服务的通信。我们利用OpenSSL进行TLS加密，还使用 SSL_CTX_set_verify_depth(ctx,1) 函数强制执行证书身份验证，该函数将强制执行对等证书验证。这将只允许由为认证客户端预先配置的证书颁发机构颁发的证书。将拒绝出示任何其他证书。另一个主要的认证客户端功能是执行来自受信任enclave的系统调用。SGX要求每个OCall和ECall都由Enclave定义语言（Intel，2017）明确定义，描述在认证客户端中执行的受信任和不受信任的函数，见图4。还利用了SGX Edger8工具。</li><li><strong>Trusted Enclave</strong>，初始化和认证后，enclave使用sgx_ecc256_create_key_pair()函数创建密钥对，并与认证服务器共享公钥。AS需要一个策略文件，其中包含要测量的文件列表或要执行的命令集。或者，可以使用sgx_seal_data() 密封文件和部分测试结果，并将其存储在外部，以释放为enclave分配的一些内存。enclave利用OCALL将原子命令执行委托给应用程序，收集结果，并为每个测试重复该过程。为了进行性能评估，在飞地中实施了以下额外函数：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653025262605.png" alt="image-1653025262605">此函数返回当前系统时间戳，并在测试执行前后调用。它允许我们计算性能基准的执行测试时间。需要ocall_time，因为enclave不允许任何直接时间函数，因此，执行必须在enclave之外委托给认证客户机。两次OCall执行的惩罚对于捕获单个测试的执行时间是必要的，它会影响所有测试场景。</li><li><strong>Checksum calculator</strong>。对于我们的原型，我们将此函数放置在enclave中，并直接放置在认证客户端中。这仅用于比较目的，因为enclave未用于NoSGX场景下。相反，对于生产使用，应该考虑使用trusted libsgx_tsgxssl_crypto ，这是一个基于OpenSSL 1.1.0加密库的加密SGX库。这是可能的，因为校验和计算器仅在enclave内部实现。</li></ol><h2 id="4-2-4-3-详细比较与开销"><a href="#4-2-4-3-详细比较与开销" class="headerlink" title="4.2&#x2F;4.3 详细比较与开销"></a><strong>4.2&#x2F;4.3 详细比较与开销</strong></h2><p>当一个长期运行的测试受到争夺资源的其他操作系统进程执行的影响时，大文件的异常值就会报告出来。当操作系统将CPU分配给具有较高优先级的进程时，就会发生这种情况，对于利用多个虚拟机之间共享的CPU的单线程验证客户端，可以观察到这种情况。<strong>这种配置，在云部署中是很典型的，但是可以通过将CPU绑定到虚拟机上，专门为认证客户端分配处理能力来缓解</strong>。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653029176337.png" alt="image-1653029176337">该实验表明，处理时间不超过零秒，对于小文件，处理时间不会随着文件大小的增加而增加。这意味着代表配置文件的文件大小的度量操作对总体处理时间没有显著影响。在这种情况下，提供度量能力所需的执行环境开销以及由<strong>对象创建、内存分配、库调用等产生的执行环境开销是一个主要因素</strong>。 随着文件大小的增长，测量时间开始发挥重要作用，从10 kB的文件大小开始，可以在图9中观察到文件大小和处理时间之间的线性依赖关系1。由于观察到的线性，理论上可以估计任何文件大小的测量时间。例如，表2中给出了1 TB文件的此类计算以及较小文件的处理时间。在最复杂的虚拟SGX场景中测量的小文件的结果偏差最大。另一方面，结果表明在裸机无SGX情况下处理的大型文件的稳定性最大。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653029251412.png" alt="image-1653029251412"></p><h2 id="4-4-可能的改进措施"><a href="#4-4-可能的改进措施" class="headerlink" title="4.4 可能的改进措施"></a><strong>4.4 可能的改进措施</strong></h2><p>该原型允许验证文件系统和运行时的完整性。它可以在VM启动时执行，也可以在不影响操作流量的非高峰时间执行。然而，为了使我们的解决方案更适合实际部署，我们提出了一些潜在的改进措施，尤其是在高峰时间对大文件执行远程认证时：</p><ol><li><p><strong>算法选择</strong>。可以使用内置安全库中更有效的文件完整性检查算法来改进校验和或哈希计算。</p></li><li><p><strong>多线程</strong>。认证客户端可以使用多个线程同时处理更多文件。</p></li><li><p><strong>代码优化</strong>。通过一些工程努力和深入分析，可以改进客户端代码，以使用最佳缓冲区大小，降低复杂性和认证客户端调用。</p></li><li><p><strong>VM调整</strong>。我们的模型是CPU昂贵的，应该考虑到这一事实，在创建时分配更多CPU或专门将CPU固定到VM</p><blockquote><p>当一个长期运行的测试受到争夺资源的其他操作系统进程执行的影响时，对于大文件的测试会产生异常</p></blockquote></li><li><p><strong>无退出系统调用（Exitless system calls）</strong>（Kuvaiskii，2018）。对于每个系统调用，进程必须退出enclave，这会增加性能开销（Orenbach et al.，2017）。异步调用可以减少这种开销。</p></li></ol><h2 id="4-5-部署"><a href="#4-5-部署" class="headerlink" title="4.5 部署"></a><strong>4.5 部署</strong></h2><p>认证服务器，多实例、负载均衡等，VM认证客户可以通过放在VM引导镜像中或者VM引导时安装。</p><h2 id="4-6-认证服务器实现"><a href="#4-6-认证服务器实现" class="headerlink" title="4.6 认证服务器实现"></a><strong>4.6 认证服务器实现</strong></h2><p>在本节中，我们将介绍可用于生产部署的认证服务器实现细节。我们不关注用户界面或测试准备和分发。相反，我们讨论了对AS性能起关键作用的构建块，如图10所示。我们提出了2级缓存，即一个数据库缓存和一个位于数据库之上的顶级缓存。这样的设计减少了每次都必须扫描一组数据以搜索校验和，避免昂贵的数据库调用。 <strong>数据库缓存</strong>是在认证服务器启动期间从数据库读取的完整数据集的内存表示形式。 <strong>顶级缓存</strong>用于存储频繁请求对象的正确测量值。当同一测试场景对一些虚拟机执行时，这个数据集比较小而且是固定的。对于不同的请求，这个数据集会增长，人们可能会考虑最近使用最少的缓存策略，或其他缓存策略，保证它数据集不会太大。当测量的VM不相同时，顶级缓存大小会增加，例如，在要检查的操作系统和文件方面。在某种情况下，这会导致每次都要验证唯一的校验和，而AS无法有效地使用顶级缓存。AS利用缓存并进行一些步骤来评估从虚拟机收到的测量结果。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653030824339.png" alt="image-1653030824339"></p><ol><li>AS通过安全TLS通道接收加密的测量文件。</li><li>文件被额外解密为可由AS处理的纯文本。</li><li>文件中的每一行都包含一个绝对文件路径和一个校验和结果。行在循环中顺序处理。</li><li>检查校验和是否存在于顶级缓存中，即最频繁请求的对象中。比较器块搜索绝对文件路径的校验和。如果它与接收到的值匹配，则不执行任何操作，并继续执行下一项。</li><li>对于顶级缓存未命中，将在数据库缓存中验证校验和。由于它可以存储大量记录，因此比顶级缓存慢。当在那里找到校验和时，它将填充到顶级缓存中，以加快对同一对象的下一个请求。对于重复测试场景，它应该仅用于第一次运行，因为对相同校验和的后续调用将导致顶级缓存命中。</li><li>直接检查数据库是最后的手段。当DB缓存与数据库不同步时（例如由用户界面的更新引起），可能会发生这种情况。这样的更新应该触发DB缓存刷新。只有在更新完成之前，才会发生缓存未命中。</li><li>如果未在任何缓存和数据库中找到校验和，则不会检测到文件完整性冲突。</li><li>当发现未知校验和时，可以考虑以下几个选项。至少应报告以供进一步调查。在采取最终措施（例如停止VM）之前，应评估发现的不一致性的严重程度。</li></ol><h2 id="4-7-认证服务器性能评估"><a href="#4-7-认证服务器性能评估" class="headerlink" title="4.7 认证服务器性能评估"></a><strong>4.7 认证服务器性能评估</strong></h2><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653031487864.png" alt="image-1653031487864"></p><blockquote><p>both是两台AS服务器，做了负载均衡。</p></blockquote><p>假设只有一个实例（蓝线），AS可以每分钟评估9000个VM，每小时评估500000多个VM。有了这样的结果，应用程序供应商可以灵活地根据所拥有的虚拟机数量调整认证需求。</p><h1 id="5-安全性分析"><a href="#5-安全性分析" class="headerlink" title="5 安全性分析"></a><strong>5 安全性分析</strong></h1><p>我们已经证明，我们的系统可以成功地用于在运行SGX的分布式云环境中验证VM。然而，此类部署非常复杂，我们并不总是了解底层基础架构。在部署解决方案时，我们应该谨慎，并重申云的细节。否则，我们可能会使其面临额外的安全风险。例如，除了基本的生命周期操作之外，云栈还应该提供更复杂的功能，例如VM迁移或扩展。<strong>对于已迁移的典型基于SGX的应用程序，enclave使用新处理器创建不同的密钥对。这意味着它将无法解密由前一个虚拟机的处理器生成的加密密钥数据</strong>。在这种情况下，应提供新老平台之间密钥交换和加密enclave数据迁移的安全方法。建议的延期（Gu等人，2017年；Park等人，2019年；2016年）是有希望的，但不是真的。此外，它们还需要额外的构件。这增加了复杂性，并且不能保证迁移数据的机密性、完整性和可用性，因此VM实时迁移不能被视为安全的。</p><blockquote><p>基于SGX的迁移，会导致无法解密。</p></blockquote><p>在我们的模型中，我们不迁移enclave数据；因此，我们支持VM迁移。只有在认证过程运行时，我们才能在enclave之外存储数据。此外，总是在VM启动时，我们假设所有数据都会丢失，并且VM不受信任。这一强有力的假设意味着VM必须经过认证过程才能处理操作流量。由于此属性，建议的解决方案支持任何意味着使用其他处理器的云操作，包括VM迁移。 SGX技术也存在很多攻击点。</p><h1 id="6-基于虚拟TPM和SGX的远程认证比较"><a href="#6-基于虚拟TPM和SGX的远程认证比较" class="headerlink" title="6 基于虚拟TPM和SGX的远程认证比较"></a><strong>6 基于虚拟TPM和SGX的远程认证比较</strong></h1><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653033517876.png" alt="image-1653033517876"></p><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a><strong>7 总结</strong></h1><p>该文提出了一种新的远程证明解决方案，该远程证明专用于在具有支持SGX的虚拟机监控程序的云中运行的虚拟机。所提出的方法允许在启动期间基于文件系统完整性评估系统信任，也可以根据需要使用灵活的策略进行评估。我们表明，我们的方法不会给处理时间增加显著的开销。此外，我们建议进一步改进。 我们的原型符合我们定义的安全属性。它以最小的可信计算基础为认证客户端提供运行时保护。我们还分析了威胁模型和SGX攻击技术，提出了针对潜在漏洞的应对措施。该解决方案不需要对现有软件进行任何更改，这使其非常适合能够无缝传输其服务的应用程序供应商。我们的解决方案消除了VTPM实施中存在的一些障碍；因此，它是支持SGX的云部署的良好候选者。 下一步工作，我们计划（a）分析云配置安全方面，并提出缓解方法以避免错误配置，（b）提出适用于大型文件的完整性验证模型，以减少代价较高的处理时间。</p><h1 id="读者总结与思考"><a href="#读者总结与思考" class="headerlink" title="读者总结与思考"></a><strong>读者总结与思考</strong></h1><ol><li>这篇文章提出的远程证明思想基于SGX，与TPM无关，并且将VTPM与Virtual SGX的远程证明进行了对比。</li><li>它将所有的可信基础归结到SGX enclave，对虚拟机进行远程验证时，需要先对SGX enclave进行认证。</li><li>对enclave认证就是利用SGX的IAS认证服务方法，对于虚拟机的认证，先由不受信任的认证客户端，这个客户端是在虚拟机中运行的，向enclave发出生成非对称密钥对的指令，私钥由enclave保存，公钥返回给认证客户端。客户端再向认证服务器发出请求获取策略，认证服务器解密后，使用enclave生成的公钥加密策略发送给认证客户端，客户端得到策略，委托给enclave。enclave解密后，执行测试。如果测试过程中有系统调用之类的，需要发出ocalls，由认证客户端去发出，认证客户端再将结果返回给enclave。全部测试执行完毕后，加密所有结果，最终返回给认证服务器。认证服务器得到测试结果后，评估VM的安全级别，对VM执行相应操作。</li></ol><p>问题：</p><ol><li>SGX相关的攻击有可能会导致enclave不可信，并且已经有对于SGX的攻击。文中并没有给出如何解决，这种风险。</li><li>它所提出的测试场景包括：<strong>关键文件、应用程序二进制文件、配置文件、库</strong>，以及<strong>通过&#x2F;proc&#x2F;文件系统提供的静态运行时</strong>信息，这样涵盖了静态和动态，这个静态运行时信息，也没有给出示例。</li><li>测试的例子没有给出，只给了宏观的性能分析等，如何通过测试，让enclave来执行获取&#x2F;proc&#x2F;的运行时信息，之前有篇文章就是通过&#x2F;proc&#x2F;文件系统，获取程序代码段的运行时信息，因为代码段不会变嘛。</li><li>因为这个策略是由验证者来决定的，有很大的变动空间，如果策略设置不合理，或者出错，该如何解决？</li><li>enclave中存在CPU的上下文切换开销，对于大文件的认证操作有可能会受到其他进程的影响导致认证失败，而且对于大文件会导致极大的系统开销，如何解决？</li></ol>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>远程证明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程证明_02_TRIGLA V：公共云中虚拟机运行时完整性的远程验证_自我总结</title>
    <link href="/0002.html"/>
    <url>/0002.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 远程证明_02_TRIGLA V：公共云中虚拟机运行时完整性的远程验证_自我总结 date: 2022-05-15 23:08:18.466 updated: 2022-05-15 23:10:34.113 url: &#x2F;archives&#x2F;yczm02zj categories:</p><ul><li>可信计算 tags:</li><li>可信计算</li><li>远程证明</li></ul><hr><h1 id="1《TRIGLAV-Remote-Attestation-of-the-Virtual-Machine’s-Runtime-Integrity-in-Public-Clouds》，-CCFC，2021。"><a href="#1《TRIGLAV-Remote-Attestation-of-the-Virtual-Machine’s-Runtime-Integrity-in-Public-Clouds》，-CCFC，2021。" class="headerlink" title="1《TRIGLAV: Remote Attestation of the Virtual Machine’s Runtime Integrity in Public Clouds》， CCFC，2021。"></a><strong>1《TRIGLAV: Remote Attestation of the Virtual Machine’s Runtime Integrity in Public Clouds》， CCFC，2021。</strong></h1><h2 id="1-1-要解决的问题"><a href="#1-1-要解决的问题" class="headerlink" title="1.1 要解决的问题"></a><strong>1.1 要解决的问题</strong></h2><p>这篇论文提出了一种协议TRIGLAV，可以让租户建立VM中软件及其软件配置的运行时完整性的信任。 文章中提到，vTPM不能直接运用在云中，因为攻击者可以篡改vTPM和VM之间的通信，例如重新配置网络，发动中间人攻击，重置TPM。 这篇文章提出的这种远程证明协议，可以在不改动VM中运行的程序，可以限制主机操作系统中管理员的活动，租户可以使用不支持可信硬件的设备连接到VM进行认证，当租户通过SSH登录到VM时，隐式的发生了对虚拟机的认证。 传统vTPM设计中所存在的问题： <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652627004628.png" alt="image-1652627004628"></p><ul><li>1）Hypervisor通过4个字节的标识符标识vTPM，通过Hypervisor将VM的通信路由到对应的vTPM实例上，攻击者可以修改网络包，实现vTPM的错误路由，这个链路不安全，该篇文章提出使用TLS解决这个问题（图1a）。</li><li>2）要经过Hypervisor，但是Hypervisor和vTPM之间缺乏认证，存在中间人攻击， 攻击者可以配置hypervisor，使其通过中介软件与vTPM进行通信，从而拦截通信（图1b）。然后，可以放弃任意的测量或执行TPM重置攻击。</li><li>3）攻击者还可以入侵客户机操作系统，伪装成正常的VM，修改其中的TPM驱动，将TPM请求重定向到远程的TPM上。这种情况下，验证者无法知道，连接到的是底层的vTPM还是远程的TPM，因为在虚拟机内的验证者无法与vTPM建立安全通信。该文通过了TEE认证协议，在vTPM和验证者之间建立了一个安全的信道，并利用它交换了一个秘密，验证者就可以唯一地识别vTPM实例了。</li></ul><h2 id="1-2-TRIGLAV-架构"><a href="#1-2-TRIGLAV-架构" class="headerlink" title="1.2 TRIGLAV 架构"></a><strong>1.2 TRIGLAV 架构</strong></h2><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652627040144.png" alt="image-1652627040144"> 它由以下四个部分组成。(A)虚拟机VM，(B)管理虚拟机的Hypervisor，使其能够访问物理资源并与其他虚拟机隔离，(C)实现管理程序运行时完整性执行和认证的可信计算组件，(D)TRIGLAV，在TEE内执行的软件，允许租户认证并执行虚拟机的完整性。文章中采用的可信执行环境TEE是SGX。</p><ul><li>1）云服务提供者先启动云节点，启动TRIGLAV。然后在租户的请求下，创建一个虚拟机VM实例。</li><li>2）接下来，租户tenant首先与TRIGLAV建立信任，这是远程证明第一个被信任的组件。（如何建立信任？）租户请求TRIGLAV检查虚拟机监控程序Hypervisor是否符合策略。（这个策略下面会提到）该策略包含租户特定的信任约束，例如完整性度量等。</li><li>3）TRIGLAV使用IMA和TPM来验证平台的运行时完整性是否符合策略，然后生成虚拟机VM的公私钥，并将公钥返回给租户。TRIGLAV保护对私钥的访问，即仅当平台与策略中定义的状态匹配时，它才允许VM使用私钥。</li><li>4）最后，租户和VM建立信任。租户通过验证VM是否可以使用与之前获得的公钥相对应的私钥。对于VM认证租户，使用租户的SSH私钥以标准方式进行身份验证。将租户的SSH公钥嵌入到虚拟机的映像中，或在虚拟机部署期间提供。</li></ul><h2 id="1-3-VM启动过程"><a href="#1-3-VM启动过程" class="headerlink" title="1.3 VM启动过程"></a><strong>1.3 VM启动过程</strong></h2><p>上述架构中如何解决Hypervisor和vTPM之间的问题，如何避免中间人攻击呢？因为Hypervisor不像TRIGLAV在TEE内，所以TRIGLAV无法使用TEE证明来验证Hypervisor的身份，因此该篇文章提出，TRIGLAV通过要求管理程序在建立连接时出示一个秘密来确认管理程序的身份。这个秘密是TRIGLAV在TEE内生成的一个秘密，并使用硬件TPM密封。 TRIGLAV 在TEE需要生成多个模拟TPM，因为多个VM不能共享一个硬件的TPM。当TRIGLAV被Hypervisor请求时，会生成一个新的模拟vTPM实例，该实例通过一个单独的TCP端口访问。Hypervisor会将连接到的模拟TPM，并将其作为一个标准的字符设备暴露给虚拟机VM。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652627056056.png" alt="image-1652627056056"> 总结如下：</p><ul><li>1）在管理程序生成一个虚拟机之前，它命令TRIGLAV生成一个模拟TPM。</li><li>2）TRIGLAV创建一个新的模拟TPM，生成一个秘密，使用硬件TPM将秘密密封。之后TRIGLAV将TCP端口和密封的秘密返回给管理程序。</li><li>3）管理者从硬件TPM中解封秘密。</li><li>4）并用这个秘密建立一个与模拟TPM的TLS连接。</li><li>5）Hypervisor创建了一个虚拟机。虚拟机启动后，固件和IMA会将完整性度量发送给模拟TPM。</li><li>6）为了防止回滚攻击，每次完整性测量都会导致模拟TPM增加基于硬件的单调计数器（MC），并将当前MC值存储在模拟TPM内存中（⑥）。</li></ul><h2 id="1-4-信任如何建立"><a href="#1-4-信任如何建立" class="headerlink" title="1.4 信任如何建立"></a><strong>1.4 信任如何建立</strong></h2><p>租户通过三个步骤建立起对云中虚拟机的信任：</p><ol><li>他验证TRIGLAV在TEE内执行，并在真正的硬件（提供TEE功能的CPU）上运行。</li><li>他通过利用TRIGLAV验证和执行主机和客户操作系统的运行时完整性，将信任扩展到管理程序和虚拟机。</li><li>他连接到虚拟机，确保它是由TRIGLAV提供和控制的虚拟机。</li></ol><p>第一步信任建立使用基于TLS的SGX认证，通过第三方CA签署证书认证。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652627073980.png" alt="image-1652627073980"> 上述步骤中，租户需要验证VM是拥有SSH私钥的VM，而私钥从没有离开过TRIGLAV，相当于TRIGLV需要认证VM的来源，由VM来实现对VM的运行时完整性度量认证。 一旦握手成功，就相当于租户建立了对VM的信任。</p><h2 id="1-5-策略如何确保运行时完整性"><a href="#1-5-策略如何确保运行时完整性" class="headerlink" title="1.5 策略如何确保运行时完整性"></a><strong>1.5 策略如何确保运行时完整性</strong></h2><p>通过1.4描述可以知道TRIGLAV通过策略实施机制来确保VM运行时的完整性符合策略。 在主机操作系统上，TRIGLAV依靠IMA来防止主机内核加载到未经数字签名的内存文件中。具体来说，文件系统中的每个文件都有一个存储在其扩展属性中的数字签名。 在内核将文件加载到内存之前，IMA 会验证云提供商发出的签名。 签名验证所需的证书从 initramfs（由 DRTM 测量）加载到内核的密钥环。存在问题。 在Guest操作系统中，Guest OS内核中的IMA需要TRIGLAV批准才能将文件加载到内存中。</p><h2 id="1-6-如何制定策略呢"><a href="#1-6-如何制定策略呢" class="headerlink" title="1.6 如何制定策略呢"></a><strong>1.6 如何制定策略呢</strong></h2><p>我们现在知道，一个VM的完整性、策略是和一对SSH公私钥绑定的。每个租户都可以通过公私钥确定VM的完整性。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652627110745.png" alt="image-1652627110745"> 作者给了一个策略清单的示例： <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652627127646.png" alt="image-1652627127646"> 它包含了Host和Guest两个部分， 包含硬件TPM制造商的证书链的白名单（第4行），证书链被用来建立对底层硬件TPM的信任。Host内核的DRTM完整性度量（第6-8行），Guest内核的完整性度量（第14行），以及Guest OS 的合法运行时完整性度量（第16-18行，22行）。TRIGLAV将DRTM完整性度量值与TPM认证的PCR值进行比较，以确保加载具有启用完整性强化机制的正确的Hypervisor。TRIGLAV使用运行时完整性测量来验证是否只有预期的文件和软件被加载到客户操作系统内存中。专用证书（第22行）使完整性强制机制变得实用，因为它允许更多的文件被加载到内存中而不需要重新部署策略。具体来说，只要用相应的私钥对允许执行的软件进行签名，就可以让软件通过完整性强化机制（这个机制指的就是策略实施机制，因为不满足策略的软件是不会被加载入内存的）。<strong>额外的证书（第11、23行）允许操作系统的更新。</strong></p><h2 id="1-7-具体实现"><a href="#1-7-具体实现" class="headerlink" title="1.7 具体实现"></a><strong>1.7 具体实现</strong></h2><p>Qemu+KVM作为Hypervisor，使用SGX作为TEE技术。 具体的TRIGLAV分为三个组件：监控服务、模拟TPM和单调计数器服务。</p><ul><li>1）监控服务是利用Linux IMA和硬件TPM来收集主机操作系统的完整性测量的组件。每个主机操作系统只有一个监控服务在运行。在一个端口上暴露出由TLS保护的API，由租户来部署策略。这部分还包括，生成秘密、密封秘密、提供秘密给模拟TPM。</li><li>2）模拟TPM：一个基于软件的TPM仿真器，基于libtpms库。它暴露了一个基于TLS的API，允许QEMU进行连接。这个秘密就是1）中的秘密。</li><li>3）单调计数器服务（MCS）提供对硬件单调计数器（MC）的访问。他利用硬件TPM来提供MC功能。MCS依靠TPM证明与提供硬件MC的TPM芯片建立信任，并依靠加密和认证的通信渠道来保护与TPM芯片从飞地通信的完整性和保密性。MCS通过TLS暴露了一个REST API，允许其他enclave远程增加和读取硬件单调的计数器。</li></ul><h2 id="1-8-存在问题"><a href="#1-8-存在问题" class="headerlink" title="1.8 存在问题"></a><strong>1.8 存在问题</strong></h2><p>1）感觉他是通过DRTM来实现完整性度量，然后每次租户通过SSH访问时，就隐式的进行了认证。之前的远程证明都是有一个基准值库用来比对，他这个远程证明好像是验证系统完整性是否符合预期的策略。 2）对策略定义这块讲解的比较少，比如运行操作系统更新、允许软件加载进入内存这块不太清晰。</p><h1 id="2-下篇论文预告"><a href="#2-下篇论文预告" class="headerlink" title="2 下篇论文预告"></a><strong>2 下篇论文预告</strong></h1><p>下周打算看一下可信执行环境TEE、以及SGX的相关技术。 论文：《2021 CCFB Remote attestation and integrity measurements with Intel SGX for virtual machines》</p>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>远程证明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程证明_01_云数据中心的大规模虚拟机的远程证明</title>
    <link href="/0001.html"/>
    <url>/0001.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 远程证明_01_云数据中心的大规模虚拟机的远程证明 date: 2022-05-12 00:29:12.443 updated: 2022-05-22 22:10:06.922 url: &#x2F;archives&#x2F;yczm01 categories:</p><ul><li>论文阅读</li><li>远程证明 tags:</li><li>可信计算</li><li>远程证明</li></ul><hr><h1 id="原文信息"><a href="#原文信息" class="headerlink" title="原文信息"></a><strong>原文信息</strong></h1><ol><li>文章标题：Remote Attestation of Large-scale Virtual Machines in the Cloud Data Center</li><li>文章中文翻译：云数据中心的大规模虚拟机的远程证明</li><li>文章等级：CCF C</li><li>文章发表时间：2021</li><li>文章作者：Jie Cheng, Kun Zhang and Bibo Tu</li><li>完整引用：Cheng J, Zhang K, Tu B. Remote Attestation of Large-scale Virtual Machines in the Cloud Data Center[C]&#x2F;&#x2F;2021 IEEE 20th International Conference on Trust, Security and Privacy in Computing and Communications (TrustCom). IEEE, 2021: 180-187.</li><li>全文请查看：<a href="https://ieeexplore.ieee.org/abstract/document/9724484">全文链接</a></li></ol><h1 id="0-摘要中的信息"><a href="#0-摘要中的信息" class="headerlink" title="0 摘要中的信息"></a><strong>0 摘要中的信息</strong></h1><h2 id="0-1-文章要解决的问题"><a href="#0-1-文章要解决的问题" class="headerlink" title="0.1 文章要解决的问题"></a><strong>0.1 文章要解决的问题</strong></h2><p>在云数据中心中，如果进行大规模虚拟化环境的验证会造成TPM瓶颈和网络拥塞，导致远程验证效率低下。</p><h2 id="0-2-文章提出解决方法"><a href="#0-2-文章提出解决方法" class="headerlink" title="0.2 文章提出解决方法"></a><strong>0.2 文章提出解决方法</strong></h2><p>该文提出了 CloudTA，一种可扩展的远程证明架构。</p><ol><li>CloudTA 对每个云服务器上的所有虚拟机进行分组，并引入完整性测量组（IMG）来测量虚拟机并按组生成可信证据。</li><li>随后，云服务器上报物理平台和VM组的可信证据进行组验证，减少延迟，提高效率。</li><li>此外，CloudTA设计了一个混合高并发通信框架，通过结合主动请求和定期报告来支持大规模虚拟机的远程证明。</li></ol><p>评估结果表明，CloudTA具有良好的效率和可扩展性，可以支持万台虚拟机的远程认证。</p><h1 id="1-引入原因"><a href="#1-引入原因" class="headerlink" title="1 引入原因"></a><strong>1 引入原因</strong></h1><p>TPM Quote是一个耗时的操作，使用频繁，成为attestation的瓶颈；此外，很多虚拟机与评估者交互，容易造成网络拥塞，影响鉴证效率。有研究提出了一种基于hypervisor的 VM 远程证明 ，VM 不再直接与评估者交互，而是hypervisor上的代理获取 VM 的个人可信信息。最后，目标平台将其和虚拟机的可信信息发送给评估者进行验证。这种方法通过绑定主机和虚拟机有效地避免了身份问题，并且可以同时验证多个虚拟机，在一定程度上减少了验证冗余，提高了可扩展性。但是，每个 VM 仍然需要 TPM Quote 操作；因此，TPM 的瓶颈影响了证明的效率。总之，目前的方法不支持大规模虚拟机的远程证明。 此外，虚拟机的增加和动态特性对远程认证中的通信框架提出了更高的要求。主动请求的方法是，评估人员向特定平台发起请求，然后平台使用其可信证据进行响应。这种方法保证了及时响应，但无法实现实时验证。同时，主动报告方式是目标平台主动向评估人员报告其可信证据，确保实时验证，但无法及时响应，当大量平台同时报告时，会增加评估人员的负载压力。这两种方法都更适用于目标平台数量较少的场景。 为了支持大规模虚拟机的远程认证，该文提出了一种<strong>可扩展的体系结构CloudTA</strong>。CloudTA将每个云服务器上的VM视为一个组，并<strong>基于Tboot和IMA</strong>，在<strong>云服务器中引入了完整性度量组（IMG）</strong>。IMG通过一个小组来衡量虚拟机的完整性。之后，<strong>它将测量值聚合到TPM的特定PCR</strong>中，并将其记录到虚拟机测量日志（VM ML），建立分层连接，并将信任扩展到VM。此外，在<strong>高并发混合通信框架的支持</strong>下，云服务器将云主机组和物理平台的可信证据一起报告给认证服务器，通过<strong>现有的远程认证协议</strong>进行验证。 总结贡献：</p><ol><li>通过分组IMG实现批量远程证明</li><li>实现了一个高并发混合通信框架CloudTA 可以支持上万虚拟机同时证明</li></ol><h1 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2 相关工作"></a><strong>2 相关工作</strong></h1><p>利用了IMA，二进制完整性度量。</p><h2 id="2-1-远程证明"><a href="#2-1-远程证明" class="headerlink" title="2.1 远程证明"></a><strong>2.1 远程证明</strong></h2><p>远程认证使评估人员能够验证目标平台的完整性。首先，评估师发送一个包含随机数（nonce）的认证请求。当收到此请求时，目标平台中的认证代理将收集可信证据，包括通过对PCR和nonce执行TPM Quote操作获得的ML和签名。平台随后将该证据报告给评估人员。然后，评估人员验证签名的正确性，以确定身份并获得可信的PCR。接下来，通过模拟PCR扩展并将模拟结果与可信的PCR 10匹配，可以进一步确定ML的真实性。如果验证结果是肯定的，评估人员通过将可信的ML与从原始正确系统收集的期望值进行比较，进一步判断平台的可信度。</p><blockquote><p>PCR 10时IMA默认使用的PCR。</p></blockquote><h2 id="2-2-虚拟机的远程证明"><a href="#2-2-虚拟机的远程证明" class="headerlink" title="2.2 虚拟机的远程证明"></a><strong>2.2 虚拟机的远程证明</strong></h2><p>在基于虚拟机监控程序的虚拟化环境中，设计并实现了vTPM（例如基于软件的vTPM、基于硬件的vTPM、基于para-vTPM、基于KVM的vTPM和基于属性的vTPM），以将信任扩展到虚拟机，并提供与物理TPM相同的使用模型和接口。通过vTPM为每个虚拟机构建一个独立的信任根，远程认证可以为虚拟机工作。然而，VM认证需要满足分层连接。换句话说，VM认证应该连接到其底层组件（例如，虚拟机监控程序或主机操作系统）的认证；否则，恶意虚拟机监控程序可能会损害VM的可信度，导致错误的验证结论。</p><blockquote><p>VM的远程证明，需要将底层的宿主机一起证明，因为VM的可信不代表底层的可信，底层的hypervisor也需要得到证明。</p></blockquote><p>三种虚拟机远程证明方法：</p><ol><li>第一种方法是评估者<strong>分别验证 VM 和Hypervisor</strong>。 通过在 VM 和Host中部署证明代理，评估人员可以使用传统的远程证明协议独立验证它们。 这两个证明共同确保了整个平台的可信度。 这种方法不需要太多更改，因此很容易集成到现有系统中。 但是，由于虚拟机和主机之间缺乏绑定，可能会出现身份问题。 TVP-PCA 使用链式信任决策算法和 MAC 地址决策算法来解决身份问题。 此外，每次验证VM时，这种方法都需要验证主机，导致频繁使用TPM Quote操作。 但是，TPM Quote 是一项耗时的操作。 频繁使用成为证明的瓶颈，影响效率。</li><li>第二种方法是<strong>深度证明</strong>，评估者<strong>通过 VM 间接验证底层Hypervisor</strong>。 它将Hypervisor的完整性信息映射到虚拟机，然后通过虚拟机和评估者之间的远程证明来验证虚拟机和虚拟机管理程序。 这种方法绑定了主机和虚拟机来解决身份问题。 不幸的是，它提供的证据不够新鲜。</li><li>第三种方法是<strong>基于Hypervisor的认证</strong>，评估人员通过Hypervisor验证Hypervisor和它之上的虚拟机集合。它在主机操作系统或虚拟机监控程序（Hypervisor）中添加了一个代理，以收集虚拟机的各个完整性信息。随后，主机将其自身和虚拟机的完整性信息报告给评估人员进行验证。这种方法将主机和虚拟机绑定在一起以避免身份问题，并且不需要像上述两种方法那样在每个虚拟机中部署认证代理，从而减少资源浪费。一个认证可以同时验证多个虚拟机，这也避免了主机验证的冗余。在[18]中，Hagen等人提出了这个框架，但没有给出具体的实现，该框架忽略了虚拟机及其可信证据之间的相关性。在[19]中，Wang等人提出了一种基于VMI的实现，通过虚拟机内省（VMI）获取虚拟机监控程序中虚拟机的可信证据。然而，这两种方案都需要在每个VM上执行TPM_Quote操作；因此，仍然存在物理TPM瓶颈问题，影响认证效率。</li></ol><blockquote><p>注：Hypervisor &#x3D; 虚拟机监控程序</p></blockquote><h2 id="2-3-认证方法"><a href="#2-3-认证方法" class="headerlink" title="2.3 认证方法"></a><strong>2.3 认证方法</strong></h2><p>两个主要的远程认证开源项目是英特尔开放认证（OAT）和IBM认证客户机服务器（ACS）</p><ol><li>OAT采用主动请求（<strong>被动报告</strong>）方式；也就是说，认证服务器首先主动发送请求，然后目标平台用其可信证据进行响应。这种方法可以立即验证特定平台，但由于目标平台无法主动报告，因此无法实时检测其可信度的变化。</li><li>ACS采用<strong>主动报告</strong>方式；也就是说，目标平台主动向认证服务器报告其可信证据，确保实时性。但是，当服务器想要立即验证目标平台时，平台无法立即响应。此外，由于服务器需要逐个验证每个平台，当大量目标平台同时报告时，一些平台的活动报告过程可能会被阻塞，无法验证。</li></ol><p>这<strong>两种方法都不支持云数据中心中大规模虚拟机的远程认证</strong>。</p><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a><strong>2.4 总结</strong></h2><p>综上所述，现有的虚拟机远程认证方案经常使用TPM Quote操作，而物理TPM成为认证的瓶颈，这使得它们只适用于有限数量的虚拟机。此外，基于vTPM的认证需要修改Guest OS，这可能会导致安全问题。它还需要管理大量vTPM，这可能会增加性能开销。因此，基于vTPM的认证不利于实际应用。此外，主动请求或主动报告的通信方式各有优缺点，更适合于少数设备的远程认证场景。总之，需要一种解决方案来实现云数据中心中大规模虚拟机的远程认证。</p><h1 id="3-总体架构"><a href="#3-总体架构" class="headerlink" title="3 总体架构"></a><strong>3 总体架构</strong></h1><blockquote><p>这章介绍了问题的解决方案。</p></blockquote><h2 id="3-1-前提假设"><a href="#3-1-前提假设" class="headerlink" title="3.1 前提假设"></a><strong>3.1 前提假设</strong></h2><ul><li>云服务器配备了TPM，它根据TPM规范工作。</li><li>虚拟机映像可能已损坏，并且在虚拟机启动之前插入了恶意软件。</li><li>具有服务器物理权限的攻击方法（如冷启动攻击、硬件篡改）不在本文考虑的威胁范围内。</li><li>我们相信认证服务器是可信的，也就是说，它被正确地实现，安全地启动，并且在运行时受到保护</li></ul><h2 id="3-2-架构"><a href="#3-2-架构" class="headerlink" title="3.2 架构"></a><strong>3.2 架构</strong></h2><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652285443375.png" alt="image-1652285443375"> 如上图所示，这个架构中它包括两个主要实体：云服务器（Cloud Servers）和认证服务器（Attestation Servers）。</p><ol><li>云服务器：运行许多虚拟机，充当证明者，并提供可信的证据。 图 1 显示了 KVM+Qemu+TPM 的云服务器结构。 云服务器在现有Tboot和IMA的基础上增加了两个模块：Integrity Measurement Group（IMG）和Trusted Attestation Client（TAC）。 IMG 负责按组实施 VM 的完整性测量和管理，并为组生成可信证据。 TAC 主要负责通过收集器收集可信证据。 此外，基于混合高并发通信框架，通过通信模块与认证服务器建立连接，在远程证明中传输消息。</li><li>认证服务器：认证服务器作为认证请求者和评估者，由三个基本模块组成。<ol><li>通信模块（CM）负责建立与基于高并发混合通信框架的云服务器的连接以传递消息。</li><li>Attestation模块负责验证物理平台和VM组的可信证据，并做出证明决策。 此外，它还需要来自隐私证书颁发机构（PCA）的证书来对云服务器进行身份验证。</li><li>管理和报告模块负责管理来自平台管理员的认证请求，并提供可视化界面查看验证结果。</li></ol></li></ol><h2 id="3-3-完整工作流程"><a href="#3-3-完整工作流程" class="headerlink" title="3.3 完整工作流程"></a><strong>3.3 完整工作流程</strong></h2><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652286192326.png" alt="image-1652286192326"> 云服务器完整的完整性度量过程可以分解为以下几个部分：</p><ol><li>云服务器启动的完整性：从启动云服务器开始，到成功加载OS内核结束。它包括BIOS、GRUB和OS内核。</li><li><strong>虚拟机依赖项</strong>的完整性：指虚拟机监视器及其必要的文件或库。</li><li><strong>虚拟机启动的</strong>完整性：指虚拟机启动前的映像和引导配置。</li><li><strong>虚拟机运行时</strong>的完整性：从虚拟机启动开始，到虚拟机关闭结束。它包括虚拟机中运行的所有组件。</li></ol><p>Tboot可以测量云服务器启动的完整性。然后，IMA可以测量应用层的所有组件。在Qemu KVM架构下，每个VM都是一个Qemu进程。因此，虚拟机依赖关系的完整性可以通过IMA来衡量。此外，IMG在虚拟机启动前测量虚拟机映像。最后，在运行时测量VM，这将在将来完成。</p><blockquote><p>最后，<strong>在运行时测量VM</strong>，这将在将来完成 ,还没完成吗? 其次这里，可以看到是将PCR 12用于记录虚拟机 image Files，PCR 13用于 VM?</p></blockquote><p>该体系结构的完整工作流程是：Tboot、IMA和IMG测量从服务器启动到虚拟机启动前的完整性，并生成相应的可信证据（PCRs、ML、VM-ML）。随后，在高并发混合通信框架的保证下，TAC定期收集该可信证据并将其报告给认证服务器。认证服务器收到该证据后，认证模块对其进行验证，管理和报告显示验证结果。</p><h1 id="4-关键技术"><a href="#4-关键技术" class="headerlink" title="4 关键技术"></a><strong>4 关键技术</strong></h1><h2 id="4-1-IMG（Integrity-Measurement-by-Group）"><a href="#4-1-IMG（Integrity-Measurement-by-Group）" class="headerlink" title="4.1 IMG（Integrity Measurement by Group）"></a><strong>4.1 IMG（Integrity Measurement by Group）</strong></h2><p>本小节详细介绍了如何按组测量虚拟机镜像的完整性，以生成虚拟机组的可信证据。在CloudTA中，我们将云服务器中的所有虚拟机分为一个组，并使用IMG对其进行测量。IMG结合了一个虚拟机管理工具（即Libvirt）来拦截所有的虚拟机管理指令并测量虚拟机镜像的完整性。它将这些测量结果存储在虚拟机测量日志（VM ML）中，并将其扩展到特定的PCR中，按组生成可信的证据；其中，VM ML记录了用于组验证的虚拟机的详细测量清单和必要的元数据，PCR保护了VM ML的可信度。 认证是将测量值与期望值进行比较。因为虚拟机管理非常灵活，易于创建、启动、停止和删除。虚拟机的状态可能会发生变化，导致image的变化，而image的变化又会导致期望值的变化。因此，有必要在image变化之前，将测量结果记录为新的期望值。回到IMG，具体工作流程如下： 首先，我们选择当前系统中未使用的特定 PCR。 在本文中，我们选择 PCR 12。 由于 PCR 复位功能只能在云服务器启动时发生，我们记录 PCR 的历史值（PCR 12 history）。 我们还创建了一个空的 VM_ML。 其次，当对云服务器中的任何VM执行管理命令（创建、启动、停止和删除）时，通知IMG测量VM的映像。 随后，IMG 通过公式（1）将测量值（M_Val）扩展到 PCR 12，并通过公式（2）将相关元数据附加到 VM ML，从而为该组生成可信证据 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652336051104.png" alt="image-1652336051104"> 在远程验证期间，云服务器向验证服务器报告以下数值。PCR12历史，VM ML，ML，Sign（PCRs，nonce）AIK，其中PCRs包括PCR12。在这种情况下，认证服务器会验证TPM的签名，然后获得可信的PCR12。然后，认证服务器通过执行公式（1）和用返回的摘要值扩展PCR12历史来重新计算模拟值来验证VM ML的可信度。如果模拟值等于可信的PCR12，则确定VM ML的可信度。因此，建立了一个一一对应的保护链，TPM保护PCR12，PCR12进一步保护VM ML。此外，受信任的VM ML被用于虚拟机的分组验证。</p><h2 id="4-2-混合通信框架"><a href="#4-2-混合通信框架" class="headerlink" title="4.2 混合通信框架"></a><strong>4.2 混合通信框架</strong></h2><p>本小节介绍了一个高并发的混合网络通信框架，用于在云服务器和认证服务器之间建立连接，以传输远程认证中的信息。 这种混合框架结合了主动请求和定期报告的通信方式，如图3所示。</p><ol><li>一方面，云服务器主动定期报告，认证服务器被设计成高并发的。云服务器中的报告人设置一个定时器，定期向认证服务器报告可信证据。认证服务器中的接收者收到报告后，通过线程池等技术并发地处理这些报告。</li><li>另一方面，当证明服务器想验证特定云服务器或虚拟机的可信度时，它主动提出请求。认证服务器中的请求者向云服务器发送一个请求。当监听器收到请求时，它会触发报告者向证明服务器回应可信证据。在报告者处理完这个主动请求过程后，它继续等待下一个周期的定期报告。这确保了云服务器一次只能发送一份报告，避免了认证服务器收到报告时的混乱。</li></ol><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652336783614.png" alt="image-1652336783614"> 该框架将活动请求和定期报告相结合。在保证高并发性的前提下，不仅可以充分利用认证服务器的资源，支持大规模设备的验证，而且在需要时可以及时进行验证，实现高可扩展性和及时响应。</p><h2 id="4-3-组验证"><a href="#4-3-组验证" class="headerlink" title="4.3 组验证"></a><strong>4.3 组验证</strong></h2><p>在证明服务器收到可信证据后，它做了一系列验证（更多细节显示在D小节），以确定VM_ML的可信度，它存储了VM组的可信信息。本小节讨论了如何基于可信的VM_ML实现对虚拟机的分组验证。 得出是否信任或不信任虚拟机的结论是验证VM_ML是否符合预期。在云数据中心至少有两台云服务器，每台服务器至少有一个虚拟机，也就是至少有两个虚拟机image。因此，我们构建一个虚拟机image期望搜索树（IET）。IET是一棵以T为根，以云服务器序列为子的搜索树。然后根据云服务器和云服务器上的虚拟机序列来构建搜索树。虚拟机序列与虚拟机image的期望值一一对应。例如，云数据中心有两个云服务器，每个云服务器上有三个虚拟机，如图4所示。其中，S1和S2代表服务器序列，I11和I12等代表虚拟机image的期望。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652337605041.png" alt="image-1652337605041"> 当云服务器向认证服务器注册时，根节点下会生成一个新的子节点S。此后，当证明服务器验证虚拟机的可信度时，它将通过二进制搜索算法从根节点搜索相应云服务器的子节点。在这个子节点下，每个虚拟机image都被更新和验证。目前，分组验证只实现了对虚拟机image的验证，以确保虚拟机启动时的可信度。因此，我们假设虚拟机在运行时是可信任的。如算法1所示，我们的方法根据VM ML条目中的状态来验证和更新VM的image。它在虚拟机启动前验证image的可信度，并在其他状态下更新image的预期。因此，云服务器上的所有虚拟机都根据VM_ML进行验证，以实现群体验证。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652337699095.png" alt="image-1652337699095"></p><blockquote><p>只有虚拟机启动时验证，其他情况都是更新VM的值。</p></blockquote><h2 id="4-4-远程证明的过程"><a href="#4-4-远程证明的过程" class="headerlink" title="4.4 远程证明的过程"></a><strong>4.4 远程证明的过程</strong></h2><p>基于上述三个关键技术，本小节以定期报告过程为例，描述CloudTA的完整远程认证过程，如图5所示。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652338162627.png" alt="image-1652338162627"> 在步骤1中，云服务器中的TAC定期向认证服务器发送一个消息，请求一个随机数（nonce）。在步骤2中，认证服务器验证该云服务器是否已经注册。如果已经注册，认证服务器在步骤3中向TAC发送一个包含不可预测的随机数（nonce）的请求。 在步骤4中，TAC收集由Tboot和IMA生成的物理平台的可信证据和由IMG生成的虚拟机组的可信证据。TAC首先通过执行TPM Quote来收集TPM的签名，TPM Quote使用私钥AIKpriv来签署选定的PCRs和nonce，其中PCR指的是PCR0-7（Tboot）、PCR10（IMA）和PCR12（IMG），而nonce最初由认证服务器提供。接下来，TAC还收集了IMA和IMG的测量日志以及PCR12的历史值（即PCR12 history）。TAC在步骤5中对这些证据进行了回应。 在步骤6a中，认证服务器首先检索可信证书_cert_(AIKpub)以确定TPM的身份，然后验证签名以检测PCR的篡改。此外，它通过比较nonce是否与步骤3中的nonce匹配来验证响应的新鲜度，以防止重放攻击。 在步骤6b中，认证服务器通过遍历ML并重新计算PCR（模拟PCR扩展操作），并将模拟PCR与可信PCR10进行比较，来检查ML的可信度。此外，在步骤6c中，认证服务器通过方程（1），用VM ML中的测量值扩展PCR12的历史，计算出模拟PCR值。如果最终的模拟PCR等于可信的PCR12，则VM_ML被信任。 在步骤7中，认证服务器根据其从原始无恶意软件系统中收集到的预期验证ML，以确定物理平台的可信度。最后，认证服务器通过分组验证来验证虚拟机。 图6显示了远程验证的结果，其中另一个镜像用不同的配置替换了虚拟机（instance-00000037）。结果显示，一个证明可以验证多个虚拟机，而虚拟机（instance-00000037）是不被信任的。此外，当点击图6中的请求时，平台管理员会主动验证特定的云服务器。</p><h1 id="5-评估"><a href="#5-评估" class="headerlink" title="5 评估"></a><strong>5 评估</strong></h1><p>本节从效率和可扩展性方面对CloudTA系统进行评估。CloudTA的原型是基于IBM 2.0 ACS[21]。云服务器运行Ubuntu 18.04和64GB内存，集成了TPM模拟器（ibmtpm1637）来模拟TPM的功能，并安装了经过我们修改的Libvirt（4.0.0）来执行分组的完整性测量。验证服务器是Ubuntu 18.04，96GB内存，64个处理器核心。ACS的验证程序被修改以支持我们的分组验证。最后，一个基于半同步&#x2F;半同步模型的混合高并发网络通信框架被实施，它结合了主动请求和定期报告。 本小节通过比较TVP-PCA、VMI RA和CloudTA三种方案来分析其效率。其中，TVP-PCA是一个分别验证虚拟机和管理程序的方案。VMI RA是一个通过VMI实现的基于hypervisor的方案。CloudTA是本文提出的一种基于分组验证的方案。表一显示了这三种方案在完整的虚拟机远程验证中的通信开销、验证的虚拟机数量以及TPM Quote的执行时间。在远程验证中，云服务器和验证服务器之间的数据交换被称为interaction。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652339870435.png" alt="image-1652339870435"> (不考虑连接的创建和释放）。n是云服务器中的虚拟机数量。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652340063510.png" alt="image-1652340063510"> 可以看到TVP-PCA只能验证一个，需要两次TPM_Quote操作，VMI是验证n个虚拟机，需要n+1次，CloudTA则只需要1次。 最后验证了32个线程下的性能，可以支持10000个虚拟机的验证。 <strong>未来打算：将对KVM事件进行分析，并结合机器学习技术，在运行时对虚拟机进行分组验证，构建一个完整的大规模虚拟机远程认证系统。</strong></p><h1 id="6-总结工作"><a href="#6-总结工作" class="headerlink" title="6 总结工作"></a><strong>6 总结工作</strong></h1><ol><li>采用基于Hypervisor的虚拟机的批量远程证明。IMG+TAC。</li><li>做了一个高并发的通信框架，方便传输信息。</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>远程证明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_07_Linux 虚拟网络基础知识Tap、tun等</title>
    <link href="/0021.html"/>
    <url>/0021.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 操作系统_07_Linux 虚拟网络基础知识Tap、tun等 date: 2022-05-20 09:36:11.729 updated: 2022-05-20 17:05:45.152 url: &#x2F;archives&#x2F;os07 categories:</p><ul><li>操作系统 tags:</li><li>操作系统</li></ul><hr><h1 id="1-tap"><a href="#1-tap" class="headerlink" title="1 tap"></a><strong>1 tap</strong></h1><p>Tap是操作系统内核中的虚拟网络设备，位于第二层（数据链路层）。Linux使用tun模块实现了tun&#x2F;tap，在Linux定义中，tap和tun的数据结构是同一个，只是使用了一个Flag来区分。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653036252195.png" alt="image-1653036252195"></p><ol><li><p>检查是否具有tun模块 <code>modinfo tun</code></p></li><li><p>如果存在，查看是否加载： <code>lsmod grep tun</code> 如果已经加载，会出现tun ***</p></li><li><p>未加载tun模块，使用如下命令加载 <code>modprobe tun</code></p></li><li><p>安装tunctl工具操作tun&#x2F;tap (这一步容易找不到包，可以按网上教程添加源) <code>yum install tunctl -y</code></p></li><li><p>创建tap设备： <code>tunctl -t tap_test</code></p></li><li><p>查看tap设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ip <span class="hljs-built_in">link</span> list</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ifconfig -a</span><br></code></pre></td></tr></table></figure><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653036353681.png" alt="image-1653036353681"></p></li><li><p>此时还没给设备绑定ip地址，执行如下命令： <code>ip addr add local 192.168.100.1/24 dev tap_test</code> 至此，一个tap设备就创建完毕了。</p></li></ol><h1 id="2-namespace"><a href="#2-namespace" class="headerlink" title="2 namespace"></a><strong>2 namespace</strong></h1><p>namespace是Linux虚拟网络的一个重要概念。传统的Linux的许多资源是全局的，比如进程ID资源。而namespace的目的首先就是将这些资源做<strong>资源隔离</strong>。Linux可以在一个Host内创建许多namespace,于是那些原本是Linux全局的资源，就变成了namespace范围内的“全局”资源,而且不同namespace的资源互相不可见、彼此透明。 Linux具体将哪些全局资源做了隔离呢?看Linux相应的代码最直接、最直观：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653036435262.png" alt="image-1653036435262">以上6个资源，就是Linux namespace所隔离的资源。其基本含义如下：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653036458388.png" alt="image-1653036458388">从资源隔离的角度，linux namespace的示意图如下图所示：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653036473559.png" alt="image-1653036473559">可以看出，每个namespace里面，将原本是全局资源的进行了隔离，彼此互相不可见，同时在Linux的Host或者VM中，也会有一套相应的资源。 从网络的角度来看，一个namespace提供了一份独立的网络协议栈（网络设备接口、IPv4、IPv6、IP路由、防火墙规则等）。一个设备（Linux Device）只能位于一个namespace之中，不同namespace中的设备可以利用veth pair进行桥接。</p><h1 id="3-veth-pair"><a href="#3-veth-pair" class="headerlink" title="3 veth pair"></a><strong>3 veth pair</strong></h1><p>Veth pair不是一个设备，是一对设备，以连接两个虚拟以太网端口，操作veth pair需要与namespace一起配合。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653036521785.png" alt="image-1653036521785"> <code>ip link add tap1 type veth peer name tap2</code> 这一条命令不仅创建tap1、tap2还创建了两个相连的veth pair，之后再把tap1、tap2分别放入ns1、ns2之中，并且给他们绑定ip地址，同一网段，就可以访问了。 但是这个也只能连接两个namespace，如果是3个以上的namespace需要互通，就需要使用到Bridge&#x2F;Switch。</p><h1 id="4-Bridge-Switch"><a href="#4-Bridge-Switch" class="headerlink" title="4 Bridge&#x2F;Switch"></a><strong>4 Bridge&#x2F;Switch</strong></h1><p>在Linux概念之中，Bridge（网桥）与Switch（交换机）是一个概念。 Linux实现Bridge功能的是brctl模块，如果没有安装，<code>yum install bridge-utils -y</code>。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653036576551.png" alt="image-1653036576551">如上图，中间创建一个交换机，创建四对veth pair，分别对应四个命名空间，就可以互通了。</p><h1 id="5-Router"><a href="#5-Router" class="headerlink" title="5 Router"></a><strong>5 Router</strong></h1><p>Linux创建路由器，并没有像创建虚拟Bridge那样有个直接的命令brctl，它连间接的命令也没有，不能创建虚拟路由器，<strong>因为Linux本身就是路由器（Router）</strong>。 不过Linux默认没有打开路由转发功能，打开路由转发功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1&quot;</span> &gt; /proc/sys/net/ipv4/ip_forward<br></code></pre></td></tr></table></figure><p>上述方法修改后重启失效，一劳永逸的方法是需要修改配置文件<code>/etc/sysctl.conf</code>。将<code>net.ipv4.ip_forward=0</code>修改为1，保存后退出即可。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653036662321.png" alt="image-1653036662321"> 在上图中，ns1&#x2F;tap1与ns2&#x2F;tap2不在同一个网段，中间需要经过一个路由器进行转发才能互通。图中的Router是一个示意，其实就是Linux开通了路由转发功能。 当我们添加了tap并给其绑定IP地址时，Linux会自动生成直连路由，通过命令<code>route -n</code>查看路由表。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653036723508.png" alt="image-1653036723508"> 如果<code>ip netns exec ns1 ping 192.168.200.2</code> 不通的话，就意味着需要设置静态路由。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns"># ip netns  exec ns1 route add -net <span class="hljs-number">192.168.200.0</span> netmask <span class="hljs-number">255.255.255.0</span> gw <span class="hljs-number">192.168.100.1</span><br># ip netns  exec ns2 route add -net <span class="hljs-number">192.168.100.0</span> netmask <span class="hljs-number">255.255.255.0</span> gw <span class="hljs-number">192.168.200.1</span><br></code></pre></td></tr></table></figure><p>为ns1和ns2设置静态路由，分别可达对方的网段。这样就可以访问通了。但是这样的网络<strong>并不能访问外网</strong>。</p><h1 id="6-tun"><a href="#6-tun" class="headerlink" title="6 tun"></a><strong>6 tun</strong></h1><p>Tun是一个网络层的点对点设备，它启用了IP层隧道功能。Linux原生支持的三层隧道，可以通过ip tunnel help查看。 Linux一共原生支持5种三层隧道（tunnel），如下表所示：</p><p><strong>隧道</strong></p><p><strong>简述</strong></p><p>ipip</p><p>IP in IP，在IPv4报文的基础上再封装一个IPv4报文头，属于IPv4 in IPv4</p><p>Gre</p><p>通用路由封装(Generic Routing Encapsulation),定义了在任意一种网络层协议上封装任意一个其他网络层协议的协议，属于IPv4&#x2F;IPv6 over IPv4</p><p>Sit</p><p>这个跟ipip类似,只不过是用一个IPv4的报文头封装IPv6的报文，属于IPv6 over lPv4</p><p>Isatap</p><p>站内自动隧道寻址协议，一般用于IPv4网络中的IPv6&#x2F;IPv4 节点间的通信</p><p>Vti</p><p>全称是Virtual Tunnel Interface，为 IPsec隧道提供了一个可路由的接口类型</p><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653036914018.png" alt="image-1653036914018"> 配置如上网络，这里以ipip tunnel为例。</p><ol><li><p>首先加载ipip模块，Linux默认没有加载</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">modprobe</span> ipip<br><span class="hljs-symbol">lsmod</span> grep <span class="hljs-built_in">ip</span><br></code></pre></td></tr></table></figure></li><li><p>在ns1上创建tun1和ip tunnel</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ip netns exec ns1<span class="hljs-built_in"> ip </span>tunnel <span class="hljs-built_in">add</span> tun1 mode ipip remote 192.168.200.2 local 192.168.100.2 ttl 255<span class="hljs-built_in"></span><br><span class="hljs-built_in">ip </span>netns exec ns1<span class="hljs-built_in"> ip </span>link <span class="hljs-built_in">set</span> tun1 up<span class="hljs-built_in"></span><br><span class="hljs-built_in">ip </span>netns exec ns1<span class="hljs-built_in"> ip </span>addr <span class="hljs-built_in">add</span> 192.168.50.10<span class="hljs-built_in"> peer </span>192.168.60.10 dev tun1<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li><code>ip tunnel add tun1 mode ipip</code>：创建一个tun类型的设备tun1，并且隧道模式是ipip；</li><li><code>remote 192.168.200.2 local 192.168.100.2</code>：这个隧道的外层IP地址是远端192.168.200.2，近端（本地）是192.168.100.2，就是两个namespace中对应的两个tap。</li><li><code>ip netns exec ns1 ip addr add 192.168.50.10 peer 192.168.60.10 dev tun1</code> ：设备tun1是个点对点的设备，他自己的ip地址是192.168.50.10，它的对端的ip是192.168.60.10。这两个IP地址就是ipip隧道的内层IP。</li></ul></li><li><p>在ns2上创建tun2和ipip tunnel</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ip netns exec ns2<span class="hljs-built_in"> ip </span>tunnel <span class="hljs-built_in">add</span> tun2 mode ipip remote 192.168.100.2 local 192.168.200.2 ttl 255<span class="hljs-built_in"></span><br><span class="hljs-built_in">ip </span>netns exec ns2<span class="hljs-built_in"> ip </span>link <span class="hljs-built_in">set</span> tun2 up<span class="hljs-built_in"></span><br><span class="hljs-built_in">ip </span>netns exec ns2<span class="hljs-built_in"> ip </span>addr <span class="hljs-built_in">add</span> 192.168.60.10<span class="hljs-built_in"> peer </span>192.168.50.10 dev tun2<br></code></pre></td></tr></table></figure></li><li><p>测试ping得通不。 <code>ip netns exec ns1 ping 192.168.60.10</code> 如果ping不通，那么就关闭主机防火墙，<code>iptables -F</code></p></li></ol><p>查看路由表<code>route -n</code>，可以看到到192.168.60.10有一条直连路由。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653037192333.png" alt="image-1653037192333"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h1><blockquote><p>本文基本按照这本书中的操作进行</p></blockquote><ul><li>《深入理解OpenStack Neutron》，2018年1月1日，机械工业出版社，作者李宗标</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_06_Linux查看CPU架构、指令集</title>
    <link href="/0020.html"/>
    <url>/0020.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 操作系统_06_Linux查看CPU架构、指令集 date: 2022-05-17 11:16:36.217 updated: 2022-05-17 11:17:51.432 url: &#x2F;archives&#x2F;os06 categories:</p><ul><li>操作系统 tags:</li><li>操作系统</li></ul><hr><h1 id="CPU指令集"><a href="#CPU指令集" class="headerlink" title="CPU指令集"></a><strong>CPU指令集</strong></h1><p>又称指令集架构（英语：Instruction Set Architecture，缩写为ISA）、指令集体系、机器语言 计算机能够进行计算，主要靠cpu中大规模集成电路中由晶体管组成的逻辑电路，这些逻辑电路可以进行运算和判断，通过组合简单逻辑电路，可以完成复杂的运算 通过一定格式的指令来控制逻辑电路进行运算，这些指令的总和就是指令集——机器语言 又分为复杂指令集和精简指令集</p><h2 id="复杂指令集-CISC"><a href="#复杂指令集-CISC" class="headerlink" title="复杂指令集 CISC"></a><strong>复杂指令集 CISC</strong></h2><p>(Complex Instruction Set Computing；CISC） 在CISC微处理器中，程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的。<strong>顺序执行</strong>的优点是控制简单，但计算机各部分的利用率不高，执行速度慢。 包括：<strong>X86、X86-64指令集</strong></p><h2 id="精简指令集-RISC"><a href="#精简指令集-RISC" class="headerlink" title="精简指令集 RISC"></a><strong>精简指令集 RISC</strong></h2><p>(Reduced Instruction Set Computing，RISC） 对指令数目和寻址方式都做了精简，使其实现更容易，指令<strong>并行执行程度</strong>更好，编译器的效率更高 通过只执行在程序中经常使用的指令来简化处理器的结构 包括：<strong>arm指令集</strong></p><blockquote><p>关于他们的优缺点，我也不说了，网上很多。</p></blockquote><h1 id="Linux上查看CPU架构"><a href="#Linux上查看CPU架构" class="headerlink" title="Linux上查看CPU架构"></a><strong>Linux上查看CPU架构</strong></h1><ul><li><p>查看处理器架构</p><ul><li><code>hostnamectl</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@controller ~]<span class="hljs-comment"># hostnamectl</span><br>Static hostname: controller<br>     Icon name: comxxxr-xxx<br>       Chassis: server<br>    Machine ID: a7337xxxxxxxxxxxxxxxxxxxxxxxx4<br>       Boot ID: 9axxxxxxxxxxxxxxxxxxxxxxxxxf8a<br>Operating System: BigCloud Enterprise Linux 7.6 (Core)<br>   CPE OS Name: cpe:/o:bclinux:bclinux:7<br>        Kernel: Linux 3.10.0-957.84.1.el7.x86_64<br>  Architecture: x86-64<br></code></pre></td></tr></table></figure><ul><li><code>arch</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@controller ~]<span class="hljs-comment"># arch</span><br>x86_64<br></code></pre></td></tr></table></figure><ul><li><code>uname -p</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@controller ~]<span class="hljs-comment"># uname -p</span><br>x86_64<br></code></pre></td></tr></table></figure></li><li><p>综合信息</p><ul><li><code>lscpu</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">Architecture:          x86_64 <span class="hljs-comment">#架构</span><br>CPU op-mode(s):        32-bit, 64-bit  <span class="hljs-comment">#支持32位和64位运行</span><br>Byte Order:            Little Endian  <span class="hljs-comment">#字节序列大小端</span><br>CPU(s):                32 <span class="hljs-comment"># 逻辑CPU个数</span><br>On-line CPU(s) list:   0-31  <br>Thread(s) per core:    2  <span class="hljs-comment">#每个核的线程数，看出开启了超线程</span><br>Core(s) per socket:    16  <span class="hljs-comment"># CPU核数</span><br>Socket(s):             1 <span class="hljs-comment">#物理插槽1个</span><br>NUMA node(s):          1<br>Vendor ID:             GenuineIntel <span class="hljs-comment">#厂商</span><br>CPU family:            6<br>Model:                 85<br>Model name:            Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz <span class="hljs-comment">#型号</span><br>Stepping:              7<br>CPU MHz:               2100.000<br>BogoMIPS:              4200.00<br>Virtualization:        VT-x  <span class="hljs-comment">#虚拟化技术</span><br>L1d cache:             32K<br>L1i cache:             32K<br>L2 cache:              1024K<br>L3 cache:              22528K<br>NUMA node0 CPU(s):     0-31<br></code></pre></td></tr></table></figure><blockquote><p>不懂物理CPU、核心、逻辑CPU之间关系的可以看我之前的博客</p></blockquote><ul><li><code>cat /proc/cpuinfo</code> 会输出所有逻辑CPU信息</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">processor       :</span> <span class="hljs-number">1</span><br><span class="hljs-attr">vendor_id       :</span> <span class="hljs-string">GenuineIntel</span><br><span class="hljs-attr">cpu family      :</span> <span class="hljs-number">6</span><br><span class="hljs-attr">model           :</span> <span class="hljs-number">85</span><br><span class="hljs-attr">model name      :</span> <span class="hljs-string">Intel(R)</span> <span class="hljs-string">Xeon(R)</span> <span class="hljs-string">Silver</span> <span class="hljs-number">4216 </span><span class="hljs-string">CPU</span> <span class="hljs-string">@</span> <span class="hljs-number">2.</span><span class="hljs-string">10GHz</span><br><span class="hljs-attr">stepping        :</span> <span class="hljs-number">7</span><br><span class="hljs-attr">microcode       :</span> <span class="hljs-number">0x5003102</span><br><span class="hljs-attr">cpu MHz         :</span> <span class="hljs-number">2100.000</span><br><span class="hljs-attr">cache size      :</span> <span class="hljs-number">22528</span> <span class="hljs-string">KB</span><br><span class="hljs-attr">physical id     :</span> <span class="hljs-number">0</span><br><span class="hljs-attr">siblings        :</span> <span class="hljs-number">32</span><br><span class="hljs-attr">core id         :</span> <span class="hljs-number">7</span><br><span class="hljs-attr">cpu cores       :</span> <span class="hljs-number">16</span><br><span class="hljs-attr">apicid          :</span> <span class="hljs-number">14</span><br><span class="hljs-attr">initial apicid  :</span> <span class="hljs-number">14</span><br><span class="hljs-attr">fpu             :</span> <span class="hljs-literal">yes</span><br><span class="hljs-attr">fpu_exception   :</span> <span class="hljs-literal">yes</span><br><span class="hljs-attr">cpuid level     :</span> <span class="hljs-number">22</span><br><span class="hljs-attr">wp              :</span> <span class="hljs-literal">yes</span><br><span class="hljs-string">......</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h1><ul><li><a href="https://www.cnblogs.com/usmile/p/13038340.html">指令集 CPU架构 x86 x86_64 arm，linux windows 查看CPU信息</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_05_物理CPU和逻辑CPU</title>
    <link href="/0019.html"/>
    <url>/0019.html</url>
    
    <content type="html"><![CDATA[<p>title: 操作系统_05_物理CPU和逻辑CPU date: 2022-05-10 17:02:05.022 updated: 2022-05-10 17:03:57.638 url: &#x2F;archives&#x2F;os05 categories:</p><ul><li>操作系统 tags:</li><li>操作系统</li></ul><hr><h1 id="1-物理CPU、逻辑CPU、CPU核心"><a href="#1-物理CPU、逻辑CPU、CPU核心" class="headerlink" title="1 物理CPU、逻辑CPU、CPU核心"></a><strong>1 物理CPU、逻辑CPU、CPU核心</strong></h1><p>很多时候我们经常会听到逻辑CPU的概念，但是不清楚什么是逻辑CPU。下面我们来一一介绍一下。</p><h1 id="2-物理CPU"><a href="#2-物理CPU" class="headerlink" title="2 物理CPU"></a><strong>2 物理CPU</strong></h1><p>物理CPU其实就是指的你的主板上实际的物理CPU个数。 Windows下查看物理CPU个数：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652172197215.png" alt="image-1652172197215"> Linux下查看物理CPU个数，Linux就是通过&#x2F;proc&#x2F;cpuinfo文件中的 <code>physical id</code> 进行标识的，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/cpuinfo  grep physical<br></code></pre></td></tr></table></figure><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652172358838.png" alt="image-1652172358838"> 可以看到physical id只有0，说明只有一个物理CPU，这个physical id是从0开始编号的，两个物理CPU的话就是编号0、1，以此类推。</p><h1 id="3-CPU核心数"><a href="#3-CPU核心数" class="headerlink" title="3 CPU核心数"></a><strong>3 CPU核心数</strong></h1><p>CPU核心数是一块物理CPU上相对独立的CPU核心单元组，可以并行执行任务。我们常说的四核、八核说的就是这个核心数。 windows上核心数查看： <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652172696860.png" alt="image-1652172696860">可以看到有6个核。 Linux上查看核心数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/cpuinfo  grep cores  <span class="hljs-built_in">uniq</span><br></code></pre></td></tr></table></figure><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652172783635.png" alt="image-1652172783635"> 可以看到是2个核</p><h1 id="4-逻辑CPU"><a href="#4-逻辑CPU" class="headerlink" title="4 逻辑CPU"></a><strong>4 逻辑CPU</strong></h1><p>逻辑CPU又称逻辑处理器，一般情况下，<code>逻辑CPU个数=物理CPU个数xCPU</code> 的核心个数，但是有的CPU支持超线程技术，可以将一个内核当作两个内核来用，这个时候就可以看到逻辑 <code>CPU数量=物理CPU个数xCPU的核心x2</code> 。 Windows上查看逻辑CPU个数：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652173086211.png" alt="image-1652173086211"> 可以看到，1个物理CPU，6个核心，6个逻辑CPU。 Linux下查看逻辑CPU的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/cpuinfo  grep processor<br></code></pre></td></tr></table></figure><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652173197581.png" alt="image-1652173197581"> 与物理CPU类似，可以看到该台服务器，有1个物理CPU、2个核心，2个逻辑CPU，未开启超线程技术。</p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_03_可执行文件加载和运行流程</title>
    <link href="/0018.html"/>
    <url>/0018.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 操作系统_03_可执行文件加载和运行流程 date: 2022-04-18 10:54:36.0 updated: 2022-05-05 22:32:42.348 url: &#x2F;archives&#x2F;os03 categories:</p><ul><li>可信计算</li><li>操作系统 tags:</li><li>文件系统</li><li>操作系统</li></ul><hr><h1 id="操作系统-03-可执行文件加载和运行流程"><a href="#操作系统-03-可执行文件加载和运行流程" class="headerlink" title="操作系统_03_可执行文件加载和运行流程"></a><strong>操作系统_03_可执行文件加载和运行流程</strong></h1><blockquote><p>以下内容绝大部分来自参考文献，转载请附带参考文献。</p></blockquote><p>在 linux 系统中，一个ELF文件主要用来表示3种类型的文件</p><ul><li>可执行文件 : 被操作系统中的加载器从硬盘中读取，加载到内存中去执行。</li><li>目标文件(.o) ：被链接器读取，用来产生一个可执行文件或者共享文件。</li><li>共享文件(.so) ：在动态链接的时候，由 <a href="http://ld-linux.so/">ld-linux.so</a> 来读取。</li></ul><p>我们的源代码通过预处理，编译，汇编，链接后形成可执行文件，那么当我们在cmd窗口敲出指令$test argv1 argv2\n 后，操作系统是怎么将我们的可执行文件加载并运行的呢？ 首先知道，计算机的操作系统的启动程序是写死在硬件上的，每次计算机上电时，都将自动加载启动程序，之后的每一个程序，每一个应用，都是不断的 fork 出来的新进程。那么我们的可执行文件，以linux 系统为例，也是由shell 进程 fork 出一个新进程，在新进程中调用exec函数装载我们的可执行文件并执行。</p><ol><li>execve()</li></ol><p>当shell中敲入执行程序的指令之后，shell进程获取到敲入的指令，并执行execve()函数，该函数的参数是敲入的可执行文件名和形参，还有就是环境变量信息。execve()函数对进程栈进行初始化，即压栈环境变量值，并压栈传入的参数值，最后压栈可执行文件名。初始化完成后调用 sys_execve()</p><ol start="2"><li>sys_execve()</li></ol><p>该函数进行一些参数的检查与复制，而后调用 do_execve()</p><ol start="3"><li>do_execve()</li></ol><p>该函数在当前路径与环境变量的路径中寻找给定的可执行文件名，找到文件后读取该文件的前128字节。读取这128个字节的目的是为了判断文件的格式，每个文件的开头几个字节都是魔数，可以用来判断文件类型。读取了前128字节的文件头部后，将调用 search_binary_handle()</p><ol start="4"><li>search_binary_handle()</li></ol><p>该函数将去搜索和匹配合适的可执行文件装载处理程序。Linux 中所有被支持的可执行文件格式都有相应的装载处理程序。 以Linux 中的ELF 文件为例，接下来将会调用elf 文件的处理程序：load_elf_binary()</p><ol start="5"><li>load_elf_binary()</li></ol><p>该函数执行以下三个步骤: a）创建虚拟地址空间：实际上指的是建立从虚拟地址空间到物理内存的映射函数所需要的相应的数据结构。（即创建一个空的页表） b）读取可执行文件的文件头，建立可执行文件到虚拟地址空间之间的映射关系 c）将CPU指令寄存器设置为可执行文件入口（虚拟空间中的一个地址） load_elf_binary()函数执行完毕，事实上装载函数执行完毕后，可执行文件真正的指令和数据都没有被装入内存中，只是建立了<strong>可执行文件与虚拟内存之间的映射关系</strong>，以及分配了一个空的页表，用来存储虚拟内存与物理内存之间的映射关系。</p><ol start="6"><li>程序返回到execve()中</li></ol><p>此时从内核态返回到用户态，且寄存器的地址被设置为了ELF 的入口地址，于是新的程序开始启动，发现程序入口对应的页面并没有加载（因为初始时是空页面），则此时引发一个缺页错误，操作系统根据可执行文件和虚拟内存之间的映射关系，在磁盘上找到缺的页，并申请物理内存，将其加载到物理内存中，并在页表中填入该虚拟内存页与物理内存页之间的映射关系。之后程序正常运行，直至结束后回到shell 父进程中，结束回到 shell。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>加载时只是做了一个虚拟空间和可执行文件之间的映射，并没有实际分配物理内存，更没有从磁盘读取文件内容到内存。代码段，数据段，堆，栈等这时候都只是存在于虚拟空间。 程序开始执行后，先访问虚拟空间的代码段，操作系统的内存管理单元（MMU）通过TLB和Page Table查找虚拟页面（Page）所对应的物理内存页框（Page Frame）时，发现还没有对应的物理页框，也就是发生了缺页中断（Page Fault），这时候操作系统才会分配物理内存，并将程序的可执行文件读入内存中，开始执行程序代码。堆栈中的内存也是在需要访问的时候，发生Page Fault，然后才分配物理内存。 这样做好处很明显，需要用到的时候才分配物理内存，可以节省很多不必要的浪费。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h1><ul><li><a href="https://www.jianshu.com/p/84d96a6385b0">Linux内核装载和启动一个可执行文件 - 简书 (</a><a href="http://jianshu.com/">jianshu.com</a><a href="https://www.jianshu.com/p/84d96a6385b0">)</a></li><li><a href="https://www.cnblogs.com/lfri/p/12722981.html">可执行文件从装载到运行的全过程 - Rogn - 博客园 (</a><a href="http://cnblogs.com/">cnblogs.com</a><a href="https://www.cnblogs.com/lfri/p/12722981.html">)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_02_Linux文件系统</title>
    <link href="/0017.html"/>
    <url>/0017.html</url>
    
    <content type="html"><![CDATA[<p>title: 操作系统_02_Linux文件系统 date: 2022-04-18 10:45:05.0 updated: 2022-05-05 23:38:44.264 url: &#x2F;archives&#x2F;os02 categories:</p><ul><li>操作系统 tags:</li><li>文件系统</li><li>操作系统</li><li>Linux</li></ul><hr><h1 id="操作系统-02-Linux文件系统"><a href="#操作系统-02-Linux文件系统" class="headerlink" title="操作系统_02_Linux文件系统"></a><strong>操作系统_02_Linux文件系统</strong></h1><p>需要搞清楚的问题： 1、当我运行一个可执行文件时，整个操作系统运行的过程。 2、正在运行的进程，执行代码块，创建文件、打开文件、删除文件、读取文件、写入文件时发生了什么。</p><blockquote><p>以下内容绝大部分来自参考文献，转载请附带参考文献。</p></blockquote><h2 id="1-文件系统基本概念"><a href="#1-文件系统基本概念" class="headerlink" title="1 文件系统基本概念"></a><strong>1 文件系统基本概念</strong></h2><p>文件系统是操作系统与用户的接口，为用户管理数据，这些数据通过文件系统直观的存储的存储介质上。</p><h3 id="1-1-文件"><a href="#1-1-文件" class="headerlink" title="1.1 文件"></a><strong>1.1 文件</strong></h3><p>文件系统的基本数据单元是文件，文件具有如下属性：文件名、文件分类、元数据等。</p><ol><li><strong>文件名</strong>是文件在存储系统上的唯一标识，用户因此不需要关心文件的存储方式、访问路径、以及文件在磁盘上存储的位置等。不同文件系统对文件名的规则不同。例如ext2文件系统，限定文件名长度255个字符。</li><li>文件分类为了更有效地组织和管理文件。按照用途分类，文件可以分为<strong>系统文件、库文件、用户文件</strong>。按照文件的性质可以分为<strong>普通文件、目录文件和特殊文件</strong>。按照文件的保护级别可以分为<strong>只读文件、可读写文件、可执行文件</strong>。按照数据形式还可以分为<strong>源文件、目标文件和可执行文件</strong>。不同操作系统分类方法也不同，windows按照文件扩展名来标识文件类型，Linux则是通过隐含在文件属性中的信息来标识。</li><li>文件主要包含两部分的内容，一部分是文件自身所包含的数据，另一部分是关于文件的描述性息，被称为文件属性，也被称为元数据，例如文件创建日期、文件长度、文件权限、存储位置等。</li></ol><p>Unix在设计的时候就提出：一切皆文件，如果一个东西不是文件，那就是进程。</p><ul><li><strong>普通文件</strong>：用户大部分时间都在进行操作的文件。包括文本文件、C语言源代码、shell脚本、二进制的可执行程序和各种类型的数据。对Linux来说，文件就是文件，Linux唯一要区别它的就是，<strong>它是不是可执行文件</strong>。</li><li><strong>目录文件</strong>：目录也是文件，它们包含文件名和子目录名，并包含指向那些文件和子目录的指针。目录文件是Linux存储文件名的地方，使用ls命令可以列出一个目录的内容，但这没有触及到文件本身，如果将一个文件从一个目录移动到另一个目录，事实上只是把这个文件的说明从一个目录文件移动到了另一个文件目录中。</li><li><strong>特殊文件：</strong>在系统中，有很多特殊的文件，比如链接、设备文件（在Linux中所有设备都用文件来表示，大多数设备文件都放在&#x2F;dev目录中），命名管道、套接字等。</li></ul><h3 id="1-2-目录"><a href="#1-2-目录" class="headerlink" title="1.2 目录"></a><strong>1.2 目录</strong></h3><p>前面已经说过，目录也是文件，所有文件与目录在系统中形成了一个树状结构如下： !<img src="https://b3logfile.com/file/2022/04/1649925397800-36ffd009.png" alt="1649925397800.png"> Linux系统中每个文件都被赋予了一个唯一的数值，这个数值称为索引节点inode（index node），它包含了一个文件的全部信息。索引节点存储在一个成为索引节点表（inode table）中，该表在磁盘格式化时被分配。 每个实际的磁盘或分区都有自己的索引节点表。Linux文件系统把索引节点号1值赋予了根目录，可以通过查找根目录开始的一个目录链来找到文件系统中的任何文件。</p><h3 id="1-3-文件系统挂载与卸载"><a href="#1-3-文件系统挂载与卸载" class="headerlink" title="1.3 文件系统挂载与卸载"></a><strong>1.3 文件系统挂载与卸载</strong></h3><p>在Linux中要使用一个文件系统前，必须先挂在那个文件系统，每个文件系统都有自己的根目录，可以通过挂在命令mount&#x2F;umount挂载和卸载一个文件系统。</p><h2 id="2-索引节点、目录、目录项、文件存储"><a href="#2-索引节点、目录、目录项、文件存储" class="headerlink" title="2 索引节点、目录、目录项、文件存储"></a><strong>2 索引节点、目录、目录项、文件存储</strong></h2><p>Linux 文件系统会为每个文件分配两个数据结构： <strong>索引节点（ <em>index node</em> ）和目录项（ <em>directory entry</em> ）</strong> ，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <em>inode</em> ，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、<strong>数据在磁盘的位置</strong>等等。索引节点是文件的<strong>唯一</strong>标识，它们之间一一对应，也同样都会被存储在硬盘中，所以 <strong>索引节点同样占用磁盘空间</strong> 。</li><li>目录项，也就是 <em>dentry</em> ，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是， <strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong> 。</li></ul><p>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。 注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？</p></blockquote><p>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。 如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。 注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。</p><blockquote><p>那文件数据是如何存储在磁盘的呢？</p></blockquote><p>磁盘读写的最小单位是 <strong>扇区</strong> ，扇区的大小只有 <code>512B</code> 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。 所以，文件系统把多个扇区组成了一个 <strong>逻辑块</strong> ，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 <code>4KB</code>，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。 以上就是索引节点、目录项以及文件数据的关系，下面这个图就很好的展示了它们之间的关系： <img src="https://b3logfile.com/file/2022/04/1649926710907-0dd55e99.png" alt="1649926710907.png"> 索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中。 另外，磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。</p><ul><li><strong><em>超级块</em></strong> ，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。</li><li><strong><em>索引节点区</em></strong> ，用来存储索引节点；（存放有索引节点表）</li><li><strong><em>数据块区</em></strong> ，用来存储文件或目录数据；</li></ul><p>我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：</p><ul><li><strong>超级块：当文件系统挂载时进入内存；</strong></li><li><strong>索引节点区：当文件被访问时进入内存；</strong></li></ul><h2 id="3-虚拟文件系统VFS"><a href="#3-虚拟文件系统VFS" class="headerlink" title="3 虚拟文件系统VFS"></a><strong>3 虚拟文件系统VFS</strong></h2><p>由于文件系统种类繁多，如NTFS、ext2、ext3、ext4等，而操作系统则希望<strong>对用户提供统一的接口</strong>，于是通过在用户层和文件系统层引入一层抽象的虚拟文件系统层，隐藏各种不同文件系统的实现细节，对用户提供统一的API。 在 Linux 文件系统中，用户空间、系统调用、虚拟机文件系统、缓存、文件系统以及存储之间的关系如下图： <img src="https://b3logfile.com/file/2022/04/1649927058883-0a02dd03.png" alt="1649927058883.png"> Linux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：</p><ul><li><em>磁盘的文件系统</em> ，它是直接把数据存储在磁盘中，比如 Ext 2&#x2F;3&#x2F;4、XFS 等都是这类文件系统。</li><li><em>内存的文件系统</em> ，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 <code>/proc</code> 和 <code>/sys</code> 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据数据。</li><li><em>网络的文件系统</em> ，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。</li></ul><p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p><h2 id="4-用户进程对文件的访问"><a href="#4-用户进程对文件的访问" class="headerlink" title="4 用户进程对文件的访问"></a><strong>4 用户进程对文件的访问</strong></h2><p>从用户角度来说，拿read()函数作为例子，每个文件在内核中都有一个对应的文件对象结构体，在这个结构体中包含的f_op指针执行具体文件系统的功能函数，其中就包含了read的操作。当用户空间发起read()请求时，经历了VFS再到具体的文件系统。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">fd = <span class="hljs-built_in">open</span>(name, flag); <span class="hljs-comment"># 打开文件</span><br>...<br><span class="hljs-built_in">write</span>(fd,...);         <span class="hljs-comment"># 写数据</span><br>...<br><span class="hljs-built_in">close</span>(fd);             <span class="hljs-comment"># 关闭文件</span><br></code></pre></td></tr></table></figure><p>上面简单的代码是读取一个文件的过程：</p><ul><li>首先用 <code>open</code> 系统调用打开文件，<code>open</code> 的参数中包含文件的路径名和文件名。</li><li>使用 <code>write</code> 写数据，其中 <code>write</code> 使用 <code>open</code> 所返回的 <strong>文件描述符</strong> ，并不使用文件名作为参数。</li><li>使用完文件后，要用 <code>close</code> 系统调用关闭文件，避免资源的泄露。</li></ul><p>我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「 <strong>文件描述符</strong> 」，所以说文件描述符是打开文件的标识。 <img src="https://b3logfile.com/file/2022/04/1649928252603-93d9f2ab.png" alt="1649928252603.png"></p><h3 id="4-1-操作系统打开文件表"><a href="#4-1-操作系统打开文件表" class="headerlink" title="4.1 操作系统打开文件表"></a><strong>4.1 操作系统打开文件表</strong></h3><p>操作系统在打开文件表中维护着打开文件的状态和信息：</p><ul><li>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；</li><li>文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；</li><li>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；</li><li>访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I&#x2F;O 请求；</li></ul><h3 id="4-2-进程打开文件表"><a href="#4-2-进程打开文件表" class="headerlink" title="4.2 进程打开文件表"></a><strong>4.2 进程打开文件表</strong></h3><p>进程打开文件表包含文件的描述符以及文件指针。 进程打开文件表包含指向系统打开文件表的句柄，操作系统打开文件表包含指向inode表。 <img src="https://b3logfile.com/file/2022/04/1649928546438-cd6a2b45.png" alt="1649928546438.png"> 系统打开文件表中的属性给系统提供了维护内存中inode表的依据，当没有任何进程引用内存中的inode文件时，系统打开文件表中的文件打开计数器为0，操作系统会根据规则，收回该inode节点空间。 当我们写入文件时，由于内存和磁盘的速度差异性，操作系统对磁盘读写会以数据块进行，就算用户只读取文件中一个字符的内容，操作系统也会讲包含该文件该字符的数据块读入内存，写操作同理。用户读写与操作系统读写差异性，由文件系统屏蔽，用户无法感知。</p><h2 id="5-软链接与硬链接"><a href="#5-软链接与硬链接" class="headerlink" title="5 软链接与硬链接"></a><strong>5 软链接与硬链接</strong></h2><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过<strong>硬链接（ <em>Hard Link</em> ）</strong> 和<strong>软链接（ <em>Symbolic Link</em> ）</strong> 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。 硬链接是 <strong>多个目录项中的「索引节点」指向一个文件</strong> ，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以 <strong>硬链接是不可用于跨文件系统的</strong> 。由于多个目录项都是指向一个 inode，那么<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</strong> <img src="https://b3logfile.com/file/2022/04/1649929478732-e3b03059.png" alt="1649929478732.png"> 而软链接相当于重新创建一个文件，这个文件有 <strong>独立的 inode</strong> ，但是这个 <strong>文件的内容是另外一个文件的路径</strong> ，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以 <strong>软链接是可以跨文件系统的</strong> ，甚至<strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</strong> <img src="https://b3logfile.com/file/2022/04/1649929508527-24166846.png" alt="1649929508527.png"></p><h2 id="6-Linux常见文件类型"><a href="#6-Linux常见文件类型" class="headerlink" title="6 Linux常见文件类型"></a><strong>6 Linux常见文件类型</strong></h2><p><img src="https://b3logfile.com/file/2022/04/1649921994433-1cd21aed.png" alt="1649921994433.png"> windows里通过扩展名来区分文件类型的。linux里文件扩展名和文件类型没有关系。但为了容易区分和兼容用户使用windows的习惯，我们还是会用扩展名来表示文件类型。举例如下：</p><ul><li>源码.tar、.tar.gz、.tgz、.zip、.tar.bz表示压缩文件，创建命令一般为tar，gzip，zip等。</li><li>.sh表示shell脚本文件，通过shell语言开发的程序。</li><li>.pl表示perl语言文件，通过perl语言开发的程序。</li><li>.py表示python语言文件，通过python语言开发的程序。</li><li>.html、.htm、.php、.jsp、.do表示网页语言的文件。</li><li>.conf表示系统服务的配置文件。</li><li>.rpm表示rpm安装包文件。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://www.cnblogs.com/linguoguo/p/15807293.html">Linux 文件系统 - 林锅 - 博客园 (</a><a href="http://cnblogs.com/">cnblogs.com</a><a href="https://www.cnblogs.com/linguoguo/p/15807293.html">)</a></li><li><a href="https://www.nowcoder.com/discuss/476462?source_id=profile_create_nctrack&channel=-1">一口气搞懂「文件系统」，就靠这 25 张图了_资源分享_牛客网 (</a><a href="http://nowcoder.com/">nowcoder.com</a><a href="https://www.nowcoder.com/discuss/476462?source_id=profile_create_nctrack&channel=-1">)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_01_BIOS、UEFI等基础概念</title>
    <link href="/0016.html"/>
    <url>/0016.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 操作系统_01_BIOS、UEFI等基础概念 date: 2022-04-13 14:54:54.0 updated: 2022-05-05 22:33:12.703 url: &#x2F;archives&#x2F;os01 categories:</p><ul><li>操作系统 tags:</li><li>BIOS</li><li>操作系统</li><li>UEFI</li><li>MBR</li></ul><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a><strong>1 概述</strong></h1><p>本文只是简单介绍一些基本知识，包括BIOS、UEFI、MBR、GPT、GRUB等。</p><h1 id="2-BIOS-CMOS"><a href="#2-BIOS-CMOS" class="headerlink" title="2 BIOS&#x2F;CMOS"></a><strong>2 BIOS&#x2F;CMOS</strong></h1><h2 id="2-1-BIOS和CMOS的基本概念和区别"><a href="#2-1-BIOS和CMOS的基本概念和区别" class="headerlink" title="2.1 BIOS和CMOS的基本概念和区别"></a><strong>2.1 BIOS和CMOS的基本概念和区别</strong></h2><p>BlOS（Basic Input Output System）从字义上称为“基本输出输入系统”，专门负责系统硬件各种参数设定，本质上是“程序”，也就是一组“代码”。 BIOS芯片，是特指存储BIOS程序的一块特定的ROM芯片。ROM，只读存储器，一般写入后只能读，不能更改，但也有可擦除只读存储器。 ROM芯片是一个实体物品，本质就是一个储存器，是主板上一颗小小的快闪EEPROM内存模块板中的长方形或正方形芯片，这一类芯片可以存储BIOS程序，也可以存储其它程序、代码。 CMOS通常读作C-mo-se（中文发音“瑟模室”），是电脑主板上的一块可读写的RAM芯片，用来保存当前系统的硬件配置情况和用户对某些参数的设定。CMOS芯片由主板上的充电电池供电，即使系统断电，参数也不会丢失。CMOS芯片只有保存数据的功能，而对CMOS中各项参数的修改要通过BIOS的设定程序来实现。 <strong>总结：BIOS</strong> <strong>是程序，存放在ROM</strong> <strong>芯片上，而CMOS</strong> <strong>是芯片，而且是可读写的RAM</strong> <strong>芯片，用来存放系统硬件配置情况以及参数等，BIOS</strong> <strong>会对CMOS</strong> <strong>操作。</strong></p><h2 id="2-2-BIOS功能"><a href="#2-2-BIOS功能" class="headerlink" title="2.2 BIOS功能"></a><strong>2.2 BIOS功能</strong></h2><p>BIOS管理功能包括：</p><ol><li><strong>POST上电自检</strong> ：微机接通电源后，系统首先由(Power On Self Test,上电自检)程序来对内部各个设备进行检查。通常完整的POST自检将包括对CPU,640K基本内存,1M以上的扩展内存,ROM,主板,CMOS存储器,串并口,显示卡,软硬盘子系统及键盘进行测试，一旦在自检中发现问题，系统将给出提示信息或鸣笛警告。</li><li><strong>BIOS系统启动自举程序</strong> ：系统完成POST自检后，ROM BIOS就首先按照系统CMOS设置中保存的启动顺序搜索软硬盘驱动器及CD-ROM,网络服务器等有效地启动驱动器，读入操作系统引导记录，然后将系统控制权交给引导记录，并由引导记录来完成系统的顺序启动。</li><li><strong>BIOS中断服务程序</strong> 实质上是微机系统中软件与硬件之间的一个可编程接口，主要用于程序软件功能与微机硬件之间对接。例如,WINDOWS98对软驱,光驱,硬盘等管理,中断的设置等服务、程序。</li><li><strong>BIOS系统设置程序</strong> ：微机部件配置记录是放在一块可写的CMOS RAM芯片中的，主要保存着系统的基本情况,CPU特性,软硬盘驱动器等部件的信息。在BIOS ROM 芯片中装有“系统设置程序”，主要来设置CMOS RAM中的各项参数。这个程序在开机时按某个键就可进入设置状态，并提供良好的界面。（可以设置CMOS参数）</li></ol><h2 id="2-3-BIOS启动流程"><a href="#2-3-BIOS启动流程" class="headerlink" title="2.3 BIOS启动流程"></a><strong>2.3 BIOS启动流程</strong></h2><ol><li>POST自检：系统加电后，BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test），缩写为POST。如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</li><li>初始化：系统完成POST后读取CMOS RAM中的系统参数等进行初始化，包括创建中断向量、设置寄存器、对一些外部设备进行初始化和检测等，其中很重要的一部分是BIOS设置，主要是对硬件设置的一些参数，当计算机启动时会读取这些参数，并和实际硬件设置进行比较，如果不符合，会影响系统的启动。</li><li>寻找下一阶段启动程序：硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）。打开BIOS的操作界面，里面有一项就是”设定启动顺序”。</li><li>按照启动顺序，寻找设备引导记录：BIOS按照”启动顺序”， BIOS先从启动顺序设置的设备的开始扇区读取引导记录，如果没有找到，可能会跳过该设备，继续寻找下一个设备，如果最后也没找到则会在显示器上显示没有引导设备，如果找到引导记录会把计算机的控制权转给引导记录，由引导记录把操作系统装入计算机，在计算机启动成功后，BIOS的这部分任务就完成了。</li></ol><h1 id="3-UEFI-BIOS"><a href="#3-UEFI-BIOS" class="headerlink" title="3 UEFI&#x2F;BIOS"></a><strong>3 UEFI&#x2F;BIOS</strong></h1><h2 id="3-1-UEFI基本概念"><a href="#3-1-UEFI基本概念" class="headerlink" title="3.1 UEFI基本概念"></a><strong>3.1 UEFI基本概念</strong></h2><p>UEFI一般指统一可扩展固件接口。 统一可扩展固件接口（英语：Unified Extensible Firmware Interface，缩写UEFI）是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面，作为BIOS的替代方案。 总结：UEFI就是BIOS的替代方案，提到BIOS也可以指传统BIOS，也有UEFI BIOS的说法。以下说的BIOS指传统BIOS。 例如：可以在windows win+R输入msinfo32查看系统信息，可以看到BIOS模式，本机就是UEFI模式启动的。 <img src="https://b3logfile.com/file/2022/04/image-ef2f8c0c.png" alt="image.png"></p><h2 id="3-2-BIOS和UEFI共同点"><a href="#3-2-BIOS和UEFI共同点" class="headerlink" title="3.2 BIOS和UEFI共同点"></a><strong>3.2 BIOS和UEFI共同点</strong></h2><p>PC的启动引导流程本质上没有改变，BIOS和UEFI 启动本身都是要经历以下三个步骤：</p><ol><li><strong>ROM Stage</strong> :在这个阶段没有内存，需要在ROM上运行代码。这时因为没有内存，没有C语言运行需要的栈空间，开始往往是汇编语言，直接在ROM空间上运行。在找到个临时空间(Cache空间用作RAM，Cache As Ram, CAR)后，C语言终于可以粉墨登场了，后期用C语言初始化内存和为这个目的需要做的一切服务。</li><li><strong>RAM Stage</strong> :在经过ROM阶段的困难情况后，我们终于有了可以大展拳脚的内存，很多额外需要大内存的东西可以开始运行了。在这时我们开始进行初始化芯片组、CPU、主板模块等等核心过程。</li><li><strong>Find something to boot Stage:</strong> 终于要进入正题了，需要启动，我们找到启动设备。就要枚举设备，发现启动设备，并把启动设备之前需要依赖的节点统统打通。然后开始移交工作，Windows或者Linux的时代开始。</li></ol><h2 id="3-3-BIOS和UEFI不同点"><a href="#3-3-BIOS和UEFI不同点" class="headerlink" title="3.3 BIOS和UEFI不同点"></a><strong>3.3 BIOS和UEFI不同点</strong></h2><p>那UEFI为什么能取代传统BIOS呢？就是因为<strong>标准接口、开放统一、开源。</strong> UEFI扫除了<strong>传统****BIOS</strong> <strong>割裂的生态</strong> ，打通了PC固件之间的鸿沟，并提供统一的接口给操作系统，而不关心操作系统是什么;它能够更好的完成PC固件的终极目的:初始化硬件和提供硬件的软件抽象，和启动操作系统。如果说有什么东西帮助UEFI打败了传统BIOS，那这些东西就是:<strong>标准接口、开放统一和开源了</strong> 。 传统BIOS由IBM主导，当时由于激烈的商战导致接口无法统一，要写个驱动，让它不同BIOS厂商那里都能跑是不可能的。 而UEFI是Intel推动，一开始就将标准公开，并拉上了微软，强势统一了江湖。在近20年的深耕下，统一了固件启动阶段基础框架Spec: Pl Spec与操作系统的接口Spec: UEFI Spec，并将抽象硬件的原语性Spec: ACPI Spec也拉入这个大家庭，都变成UEFI Forum的一份子。现在只要符合UEFI driver model的驱动都可以在各个BIOS上运行，打通了各个BIOS厂商之间的栅栏;与此同时，符合UEFI标准的操作系统都可以流畅的在各种主板上运行，无论是Windows，还是Linux各种发行版，甚至是Android。实际上，PC生态圈的繁荣，和UEFI的推广和被广泛接受是分不开的。 UEFI采用PE&#x2F;COFF格式作为UEFI驱动和应用的标准。</p><h2 id="3-4-UEFI架构"><a href="#3-4-UEFI架构" class="headerlink" title="3.4 UEFI架构"></a><strong>3.4 UEFI架构</strong></h2><p>TPM CLIEN文章中的UEFI架构： <img src="https://b3logfile.com/file/2022/04/image-f0d49771.png" alt="image.png"> 可以看到，UEFFI服务包含引导时服务和运行时服务。</p><h2 id="3-5-UEFI实现"><a href="#3-5-UEFI实现" class="headerlink" title="3.5 UEFI实现"></a><strong>3.5 UEFI实现</strong></h2><h3 id="3-5-1-SEC，PEI和DXE"><a href="#3-5-1-SEC，PEI和DXE" class="headerlink" title="3.5.1 SEC，PEI和DXE"></a><strong>3.5.1 SEC，PEI和DXE</strong></h3><p><a href="https://b3logfile.com/file/2022/04/image-7092aa1b.png">image.png</a> <strong>SEC</strong> <strong>：</strong> PI平台启动的安全（Security，简称SEC）阶段必须处理不同类型的平台重置（Reset）事件。 SEC还是系统的信任根，它为系统上进一步启动固件提供了控制点（Control Point）。 SEC阶段的优点在于：它可以提供一个锚点，基于这个锚点来构建一个已验证的引导过程。一旦临时存储器可用，SEC必须找到引导进程的下一个阶段：EFI预初始化（Pre-EFI Initialization简称PEI）阶段，并将控制权限移交。当然，根据PEI代码的位置以及平台策略，PEI代码必须在执行之前经过认证。 <strong>PEI</strong> <strong>：</strong> PEI阶段的目标是为PEI模块的执行搭建合适的环境。 因此，在PEI阶段初期，PEI调度器就已启动。 PEI模块通常对设备和芯片组的底层平台进行初始化，例如串行端口和内存的初始化。 该阶段的的另一个职责是搜索平台信息，在切换块（hand-off blocks，简称HOB）中为此信息创建数据库，并将数据库传递给平台引导的下一阶段：DXE阶段。 和上一阶段相同的是，PEI模块也必须在运行模块之前进行验证。 一般来说，PEI模块是平台的核心固件的一部分，并且对于特定平台模型，可以认为这个模块是静态且可信的。 不过，在PI规范中没有关于PEI模块位置的要求，因此可以存在其中一些或所有PEI模块将需要被认证以维持平台完整性的平台。有些平台为了维持其完整性，会对所有的PEI模块进行验证。 <strong>DXE</strong> <strong>：</strong> 当PEI阶段找到并开始执行DXE的初始化程序加载时，标志着引导程序进入了PI规范要求的最终阶段。DXE阶段通过HOB来查询平台的相关信息，并为驱动程序搭建一个更加完整的环境。 DXE调度程序负责查找和启动DXE驱动程序，这些驱动程序可能有很多来源。但PI代码和UEFI核心仅来自系统板制造商，并且不能由第三方任意扩展。平台制造商必须为符合PI规范而且采用了UEFI服务的固件负责，保障其从生产到交付后的真实性和安全性。 为了保持平台完整性，对固件的更改必须处于平台制造商的控制监督之下。在不同的平台下，这一控制的实现或许会有所不同，但不管是什么平台，都必须实现散列和加密认证等方式，否则其安全性无法得以真正保障。 在较新版本的UEFI规范中，都提供了一些用于固件更新的工具。 对安全引导来说，固件更新必须是受控的。固件受控对于TCG测量引导（TCG Measured Boot）也同样必要。</p><h3 id="3-5-2-BDS，OS-loader和RT"><a href="#3-5-2-BDS，OS-loader和RT" class="headerlink" title="3.5.2 BDS，OS loader和RT"></a><strong>3.5.2 BDS，OS loader和RT</strong></h3><p><img src="https://b3logfile.com/file/2022/04/image-f8324ec5.png" alt="image.png"> BDS：在DXE结束后，BDS得以运行。<strong>BDS</strong> <strong>（Boot Device Select</strong> <strong>），顾名思义，就是发现引导设备（全部或者部分），</strong> 并作出选择（用户选择或者根据设定）。它负责初始化所有启动OS所需的设备（输入、输出和存储）。在更高层面上讲，它负责执行所有符合UEFI驱动模型（UEFI driver model）的驱动。这是一个发现并一个个连接的过程。譬如，首先发现PCI root，接着发现PCI bus，在PCI bus下发现SATA controller和USB controller……一个个启动设备被发现，其设备路径（device path）也被连接起来。在万事俱备后，一个界面被显示出来（嵌入式系统上可以没有），供用户进行设置和选择启动设备，这就是大家熟悉的BIOS界面。 <strong>RT</strong> <strong>：</strong> 在用户选择或者用预设的设备被挑出来后，BDS加载OS loader，而OS loader负责找到并运行OS。在OS启动后，所有的启动时服务都不可用了，只有运行时服务得以留存。</p><h1 id="4-MBR-GPT"><a href="#4-MBR-GPT" class="headerlink" title="4 MBR&#x2F;GPT"></a><strong>4 MBR&#x2F;GPT</strong></h1><h2 id="4-1-MBR"><a href="#4-1-MBR" class="headerlink" title="4.1 MBR"></a><strong>4.1 MBR</strong></h2><h3 id="4-1-1-MBR介绍"><a href="#4-1-1-MBR介绍" class="headerlink" title="4.1.1 MBR介绍"></a><strong>4.1.1 MBR介绍</strong></h3><p>MBR（Master Boot Record）分区分析： MBR的意思是“主引导记录”，它有自己的启动器，也就是启动代码，一旦启动代码被破坏，系统就没法启动，只有通过修复才能启动系统。最大支持2TB容量，在容量方面存在着极大的瓶颈，那么GPT在今后的发展就会越来越占优势，MBR也会逐渐被GPT取代。</p><h3 id="4-1-2-MBR作用"><a href="#4-1-2-MBR作用" class="headerlink" title="4.1.2 MBR作用"></a><strong>4.1.2 MBR作用</strong></h3><p>接着2.3 BIOS启动流程，BIOS按照”启动顺序”，把控制权转交给排在第一位的储存设备。 这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。 这最前面的<strong>512</strong> <strong>个字节，就叫做”</strong> <strong>主引导记录”</strong> <strong>（Master boot record</strong> <strong>，缩写为MBR</strong> <strong>）</strong> 。 “主引导记录”只有512个字节，放不了太多东西。它的主要作用是，<strong>告诉计算机到硬盘的哪一个位置去找操作系统</strong> 。 主引导记录由三个部分组成： （1） 第1-446字节：调用操作系统的机器码。 （2） 第447-510字节：分区表（Partition table）。 （3） 第511-512字节：主引导记录签名（0x55和0xAA）。 因为采用MBR这种方式的，一个硬盘最多只能分四个一级分区，又叫做”主分区”，并且4个主分区里，只有一个是激活的，如果还要更多的分区，需要进行扩展分区。因此当计算机的控制权就要转交给硬盘的某个分区了，又分成三种情况： <strong>1</strong> <strong>、情况A</strong> <strong>、卷引导记录。</strong> 四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做”卷引导记录”（Volume boot record，缩写为VBR）。 “卷引导记录”的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。 <strong>2</strong> <strong>、情况B</strong> <strong>、扩展分区和逻辑分区。</strong> 随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成”扩展分区”（Extended partition）。所谓”扩展分区”，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做”逻辑分区”（logical partition）。 计算机先读取扩展分区的第一个扇区，叫做”扩展引导记录”（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。 计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。 但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。 <strong>3、情况C、启动管理器</strong> 在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。 Linux环境中，目前最流行的启动管理器是GRUB。 以下是Linux操作系统启动的全过程。<img src="https://b3logfile.com/file/2022/04/image-f6792622.png" alt="image.png"></p><h2 id="4-2-GPT"><a href="#4-2-GPT" class="headerlink" title="4.2 GPT"></a><strong>4.2 GPT</strong></h2><p>GPT（GUID Partition Table）分区分析： GPT意为GUID分区表，这是一个正逐渐取代MBR的新标准，它由UEFI辅住而形成的，这样就有了UEFI用于取代老旧的BIOS，而GPT则取代老旧的MBR。这个标准没有MBR的那些限制。磁盘驱动器容量可以大得多，大到操作系统和文件系统都没法支持。它同时还支持几乎无限个分区数量，限制只在于操作系统，Windows支持最多128个GPT分区。通过UEFI，所有的64位的win0，win8，win7和Vista，以及所对应的服务器都能从GPT启动。</p><h2 id="4-3-MBR和GPT区别"><a href="#4-3-MBR和GPT区别" class="headerlink" title="4.3 MBR和GPT区别"></a><strong>4.3 MBR和GPT区别</strong></h2><p>1、MBR的局限性，它是存在于驱动器开始部分的一个特殊的启动扇区。这个扇区包含了已安装的操作系统的启动加载器和驱动器的逻辑分区信息。所谓启动加载器，是一小段代码，用于加载驱动器上其他分区上更大的加载器。如果你安装了Windows，Windows启动加载器的初始信息就放在这个区域里——如果MBR的信息被覆盖导致Windows不能启动，你就需要使用Windows的MBR修复功能来使其恢复正常。如果你安装了Linux，则位于MBR里的通常会是GRUB加载器； 2、MBR支持最大2TB磁盘，它无法处理大于2TB容量的磁盘。MBR还只支持最多4个主分区——如果你想要更多分区，你需要创建所谓【扩展分区】，并在其中创建逻辑分区； 3、GPT意为GUID分区表。（GUID意为全局唯一标识符）。这是一个正逐渐取代MBR的新标准，它和UEFI相辅相成——UEFI用于取代老旧的BIOS，而GPT则取代老旧的MBR。之所以叫做【GUID分区表】，是因为你的驱动器上的每个分区都有一个全局唯一的标识符（globally unique identifier，GUID）——这是一个随机生成的字符串，可以保证为地球上的每一个GPT分区都分配完全唯一的标识符；</p><h1 id="5-GRUB"><a href="#5-GRUB" class="headerlink" title="5 GRUB"></a><strong>5 GRUB</strong></h1><p>GNU GRUB（GRand Unified Bootloader简称“GRUB”）是一个来自GNU项目的多操作系统启动程序。GRUB是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。 GRUB加载流程： 当计算机加电自检后，ROM　BIOS加载MBR（主引导扇区，即硬盘第一扇区）中的代码到内存中，这个扇区一共512字节，前446字节内容存放grub（bootloader）的关键引导程序，接着64字节放置硬盘分区表DPT（Disk Partition Table）。当BIOS把引导程序加载到内存后就把控制权交给grub，而后grub的剩余代码将完成其它代码的加载和搬移以及文件系统初始化查找等工作，最终加载内核映像文件，从而把控制权交给真正的内核运行。</p><h1 id="6-参考链接"><a href="#6-参考链接" class="headerlink" title="6 参考链接"></a><strong>6 参考链接</strong></h1><ul><li><a href="https://zhuanlan.zhihu.com/p/25941528">UEFI架构 - 知乎 (</a><a href="http://zhihu.com/">zhihu.com</a><a href="https://zhuanlan.zhihu.com/p/25941528">)</a></li><li><a href="https://www.w3cschool.cn/bioswqsc/exfrob.html">BIOS与CMOS_w3cschool</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的？ - 阮一峰的网络日志 (</a><a href="http://ruanyifeng.com/">ruanyifeng.com</a><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UEFI</tag>
      
      <tag>BIOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongodb学习_01_相关概念基础知识</title>
    <link href="/0028.html"/>
    <url>/0028.html</url>
    
    <content type="html"><![CDATA[<h1 id="MongoDB学习记录"><a href="#MongoDB学习记录" class="headerlink" title="MongoDB学习记录"></a><strong>MongoDB学习记录</strong></h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a><strong>1 概述</strong></h2><p>MongoDB是一个基于分布式文件存储的NoSQL数据库，由C++编写。MongoDB使用BSON (Binary JSON）对象来存储，旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库当中功能最丰富，最像关系数据库的。</p><hr><h2 id="2-安装与启动"><a href="#2-安装与启动" class="headerlink" title="2 安装与启动"></a><strong>2 安装与启动</strong></h2><blockquote><p>本次实践安装在CentOS7虚拟机上，采用的是离线安装的方式</p></blockquote><ol><li>官网下载相应版本的mongodb的tgz包。</li><li>上传至虚拟机，采用命令：<strong>tar -zxvf tgz包 -C 解压路径</strong>，解压重命名即可。</li><li>创建数据、日志目录，并修改其读写权限。<ul><li>mkdir -p &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data&#x2F;db &#x2F;&#x2F;数据目录</li><li>mkdir -p &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;logs &#x2F;&#x2F;日志目录</li><li>touch &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;logs&#x2F;mongodb.log &#x2F;&#x2F;日志文件</li></ul></li><li>启动mongodb，分为前台启动和后台启动<ul><li>前台启动：<strong>bin&#x2F;mongod –dbpath &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data&#x2F;db&#x2F; –logpath &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;logs&#x2F;mongodb.log –logappend –port 27017 –bind_ip 0.0.0.0</strong> &#x2F;&#x2F;dbpath指定数据文件路径，logpath指定日志文件路径，logappend代表追加日志，port代表端口，默认27017，bind_ip默认只有本机可以访问。</li><li>后台启动：在前台的命令后添加”–fork”（一般不推荐），当然也可以采用配置文件方式启动。<ul><li><p>新建配置文件 vim bin&#x2F;mongodb.conf</p></li><li><p>将如下内容放入配置文件中</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#数据文件存放目录</span><br><span class="hljs-attr">dbpath</span> = /usr/local/mongodb/data/db<br><span class="hljs-comment"># 日志文件存放目录</span><br><span class="hljs-attr">logpath</span> = /usr/local/mongodb/logs/mongodb.log<br><span class="hljs-comment">#以追加的方式记录日志</span><br><span class="hljs-attr">logappend</span> = <span class="hljs-literal">true</span><br><span class="hljs-comment">#端口默认为27017</span><br><span class="hljs-attr">port</span> = <span class="hljs-number">27017</span><br><span class="hljs-comment">#对访问IP地址不做限制，默认为本机地址</span><br><span class="hljs-attr">bind_ip</span> = <span class="hljs-number">0.0</span>.o.<span class="hljs-number">0</span><br><span class="hljs-comment">#以守护进程的方式启用，即在后台运行</span><br><span class="hljs-attr">fork</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>启动命令变为：bin&#x2F;mongod -f bin&#x2F;mongodb.conf</p></li><li><p>关闭命令变为：bin&#x2F;mongod -f bin&#x2F;mongodb.conf –shutdown</p></li></ul></li></ul></li><li>可以通过 bin&#x2F;mongo 来测试是否启动，mongo是它提供的一个shell客户端</li><li>配置环境变量：<ul><li><p>vim &#x2F;etc&#x2F;profile</p></li><li><p>加入如下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">MONGODB_HOME</span>=/usr/local/mongodb<br><span class="hljs-comment"># Path后追加 &quot;:$MONGO_HOME/bin&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>source &#x2F;etc&#x2F;profile &#x2F;&#x2F;使环境变量生效</p></li></ul></li></ol><hr><h2 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3 基本使用"></a><strong>3 基本使用</strong></h2><h3 id="3-1-MongoDB用户与权限管理"><a href="#3-1-MongoDB用户与权限管理" class="headerlink" title="3.1 MongoDB用户与权限管理"></a><strong>3.1 MongoDB用户与权限管理</strong></h3><h4 id="3-1-1-常用权限"><a href="#3-1-1-常用权限" class="headerlink" title="3.1.1 常用权限"></a><strong>3.1.1 常用权限</strong></h4><ul><li>read&#x2F;readAnyDatabase &#x2F;&#x2F;允许用户读取指定数据库，加上AnyDatabase就需要在Admin数据库中定义，代表可以读取所有数据库，其他类似</li><li>readWrite&#x2F;readWriteAnyDatabase &#x2F;&#x2F;允许用户读写指定数据库</li><li>userAdmin&#x2F;userAdminAnyDatabase &#x2F;&#x2F;允许用户向system.users集合写入，可以在指定数据库里创建、删除和管理用户。</li><li>dbAdmin&#x2F;dbAdminAnyDatabase &#x2F;&#x2F;允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile。</li><li>clusterAdmin &#x2F;&#x2F;必须在admin数据库中定义，赋予用户所有分片和复制集相关函数的管理权限。</li><li>root &#x2F;&#x2F;必须在admin数据库中定义，超级权限。</li></ul><h4 id="3-1-2-创建管理用户"><a href="#3-1-2-创建管理用户" class="headerlink" title="3.1.2 创建管理用户"></a><strong>3.1.2 创建管理用户</strong></h4><p>打开mongo shell客户端</p><ol><li>use admin &#x2F;&#x2F;切换到admin数据库</li><li>show users &#x2F;&#x2F;查看admin数据库中的所有用户信息</li><li>db.createUser({用户信息}) &#x2F;&#x2F;根据用户信息创建用户</li></ol><p>开启用户认证</p><ol><li>编辑2中配置文件bin&#x2F;mongodb.conf</li><li>加入一行 “ auth &#x3D; true”</li></ol><p>开始认证</p><ol><li>重新启动mongod</li><li>打开mongo客户端，use admin切换到admin库</li><li>db.auth(“用户名”,”密码”) &#x2F;&#x2F;登录认证，返回1认证成功 0失败</li></ol><h4 id="3-1-3-创建普通用户"><a href="#3-1-3-创建普通用户" class="headerlink" title="3.1.3 创建普通用户"></a><strong>3.1.3 创建普通用户</strong></h4><ol><li>普通用户需要由管理员用户创建，先登录管理员用户。</li><li>创建数据库，Mongodb没有提供专门的创建数据库的函数，使用 <strong>use 数据库</strong> 的命令，如果数据库不存在，则创建并切换。</li></ol><h4 id="3-1-4-更新用户"><a href="#3-1-4-更新用户" class="headerlink" title="3.1.4 更新用户"></a><strong>3.1.4 更新用户</strong></h4><p>如果需要对已存在的用户进行角色修改，可以使用 <strong>db.updateUser()</strong> 函数来更新用户角色。</p><ul><li>db.updateUser(“用户名”,{“roles”:[ {“role”:”角色名称”,db:”数据库”},{“更新项2”:”更新内容”}]})</li></ul><p>修改用户密码：</p><ul><li>使用db.updateUser(“用户名”,{“pwd”:”新密码”})函数</li><li>使用db.changeUserPassword(“用户名”,”新密码”)函数</li></ul><blockquote><p>注意：更新用户信息以及密码需要当前用户具有<strong>userAdmin</strong> 或 <strong>userAdminAnyDatabse</strong>或 <strong>root</strong> 角色。</p></blockquote><h4 id="3-1-5-删除用户"><a href="#3-1-5-删除用户" class="headerlink" title="3.1.5 删除用户"></a><strong>3.1.5 删除用户</strong></h4><p>通过db.dropUser(）函数可以删除指定用户，删除成功以后会返回true。删除用户时需要切换到该用户所在的数据库。</p><blockquote><p>注意：删除用户信息以及密码需要当前用户具有<strong>userAdmin</strong> 或 <strong>userAdminAnyDatabse</strong>或 <strong>root</strong> 角色。</p></blockquote><h3 id="3-2-GUI可视化管理工具"><a href="#3-2-GUI可视化管理工具" class="headerlink" title="3.2 GUI可视化管理工具"></a><strong>3.2 GUI可视化管理工具</strong></h3><ul><li>studio 3T这是官方合作伙伴 <a href="https://studio3t.com/download/">下载地址</a>，付费版提供了SQL转mongodb命令的功能，可以提供给不会写mongodb命令的用户。</li><li>MongoDB Compass 官方的工具</li></ul><blockquote><p>使用可视化工具连接时，连接不上虚拟机，telnet也不能连接27017端口，需要关闭centOS防火墙 <strong>systemctl stop firewalld</strong>。</p></blockquote><h3 id="3-3-数据库操作"><a href="#3-3-数据库操作" class="headerlink" title="3.3 数据库操作"></a><strong>3.3 数据库操作</strong></h3><ol><li>show dbs &#x2F;&#x2F;查看数据库</li><li>db &#x2F;&#x2F;查看当前数据库</li><li>use 数据库名 &#x2F;&#x2F;创建数据库，懒创建的方式，没有数据就不会创建。</li><li>db.dropDatabase() &#x2F;&#x2F;删除数据库，需要写换到数据库才能删除</li></ol><h3 id="3-4-集合操作"><a href="#3-4-集合操作" class="headerlink" title="3.4 集合操作"></a><strong>3.4 集合操作</strong></h3><p>集合相当于关系型数据库的表。</p><ol><li>db.createCollection(集合名，可选参数) &#x2F;&#x2F;创建集合，插入文档时会自动创建集合</li><li>show collections &#x2F;&#x2F;查看集合</li><li>db.集合名.drop() &#x2F;&#x2F;删除集合</li></ol><h3 id="3-5-文档操作"><a href="#3-5-文档操作" class="headerlink" title="3.5 文档操作"></a><strong>3.5 文档操作</strong></h3><ol><li>db.集合名.insert(文档) &#x2F;&#x2F;插入文档，索引是”_id”，也可以批量插入</li><li><a href="http://db.集合名.save/">db.集合名.save</a>(文档) &#x2F;&#x2F;如果不指定”_id”字段，相当于插入，如果指定了，相当于更新操作，也可以批量插入</li><li>db.集合名.update(query,update,options) &#x2F;&#x2F;query是查询条件，类似sql中的where，update类似sql中的set部分，可选参数options。</li><li>db.集合名.remove(query,&lt;justOne, boolean&gt;) &#x2F;&#x2F;query是查询条件，justOne为true删除查到的全部文档，为false删除第一条。还有deleteOne、deleteMany等函数</li><li>db.集合名.find(查询条件) &#x2F;&#x2F;查询文档</li></ol><blockquote><p>此外mongodb还提供了索引和聚合等功能。</p></blockquote><hr><h2 id="4-和MySQL的区别"><a href="#4-和MySQL的区别" class="headerlink" title="4 和MySQL的区别"></a><strong>4 和MySQL的区别</strong></h2><ol><li>MongoDB是非关系型数据库，MySQL是关系型数据库</li><li>MongoDB存储方式采用虚拟内存和持久化，MySQL不同引擎有不同的存储方式。</li><li>MongoDB有独特的查询方式，MYSQL采用SQL语言，使用广泛</li><li>MongoDB数据是放在磁盘上的，热数据是放在内存，从而达到高速读写。</li></ol><p>可以和MySQL搭配使用，可以像redis一样搭配MySQL做缓存db，可以替代MySQL做后端数据库，而redis不能。从性能上来说，redis&gt;mongodb&gt;mysql，不过这是在内存充足的情况下，如果内存不足redis显然不能完成任务，因此在处理海量数据时，mongoDB是一个不错的选择。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a><strong>5 总结</strong></h2><ul><li>mongodb是一种NoSQL数据库，它能保证海量数据存储的情况，保证性能。</li><li>mongodb的所有数据实际上是存放在硬盘的，所有要操作的数据通过mmap的方式映射到内存某个区域内。</li></ul><hr><h1 id="高级部分"><a href="#高级部分" class="headerlink" title="高级部分"></a><strong>高级部分</strong></h1><h2 id="6-mongoDB复制集"><a href="#6-mongoDB复制集" class="headerlink" title="6 mongoDB复制集"></a><strong>6 mongoDB复制集</strong></h2><p>primary（主）和secondary（从）</p><ol><li>复制集目的为了实现服务的高可用，类似redis的主从复制，可以实现如下功能<ul><li>数据分发，减少数据响应时间</li><li>读写分离</li><li>容灾恢复</li></ul></li><li>选举：类似redis的哨兵模式<ul><li>复制集最多有50个节点，但具有投票权的最多7个。</li><li>具有投票权的节点会通过心跳保持联系</li><li>如果主节点失联，则会通过投票选出主节点</li></ul></li><li>复制过程：将操作日志oplog记录，从节点，将主节点的oplog重新执行。</li><li>复制集节点的常见配置项：<ul><li>是否具有投票权(v参数)：有则参与投票;</li><li>优先级(priority 参数)：优先级越高的节点越优先成为主节点。优先级为0的节点无法成为主节点;</li><li>隐藏(hidden参数)：复制数据，但对应用不可见。隐藏节点可以具有投票权，但优先级必须为0;</li><li>延迟(slaveDelay 参数)：复制n秒之前的数据，保持与主节点的时间差。设置延迟节点，可以恢复误删主节点数据等操作。</li></ul></li></ol><blockquote><p><strong>增加从节点并不会增加系统写性能！</strong></p></blockquote><ol start="5"><li>新增复制集：<ul><li>rs.initiate() &#x2F;&#x2F;初始化，连续两次回车就可以成为主节点</li><li>rs.status() &#x2F;&#x2F;查看复制集状态</li><li>rs.secondaryOk() &#x2F;&#x2F;设置从节点可读</li><li>rs.add() &#x2F;&#x2F;新增复制集</li></ul></li></ol><hr><h2 id="7-JSON文档模型和关系模型"><a href="#7-JSON文档模型和关系模型" class="headerlink" title="7 JSON文档模型和关系模型"></a><strong>7 JSON文档模型和关系模型</strong></h2><ol><li>模型设计层次：关系模型包含概念模型、逻辑模型、物理模型，JSON文档模型只包含概念模型、逻辑模型。</li><li>从模型实体来看，JSON文档模型是集合，关系模型是表</li><li>从属性来看，JSON文档模型是字段，关系模型是列</li><li>从模型关系来看，JSON文档模型是用内嵌数组、引用字段来表示关系，关系模型是用关联关系、主外键来表示。</li></ol><p><strong>什么时候采用引用而不是内嵌文档：</strong></p><ol><li>内嵌文档太大，数MB或超过16MB</li><li>内嵌文档或数组频繁更改</li><li>内嵌数组元素持续增长并且没有封顶</li></ol><p><strong>mongodb引用的限制：</strong></p><ol><li>MongodB对使用引用的集合之间并无主外键检查</li><li>MongoDB使用聚合框架的$lookup 来模仿关联查询</li><li>$lookup只支持left out join</li><li>$lookup的关联目标（from）不能是分片表</li></ol><h2 id="8-MongoDB设计模式"><a href="#8-MongoDB设计模式" class="headerlink" title="8 MongoDB设计模式"></a><strong>8 MongoDB设计模式</strong></h2><p>一个好的设计模式可以显著提升数据读写效率、降低资源的需求。</p><ol><li>问题：对于时序数据，大数据量存储。解决方案：分桶设计模式：对于时序数据，采用内嵌数组，讲一个时间段内的数据聚合到一个文档里，可以大量减少数据量、索引数量。</li><li>问题：解决大文档，很多字段、很多索引的问题。解决方案：列转行，通过将文档的字段转化为数组，一个索引解决查询问题。</li><li>问题：模型灵活，如何管理文档多个版本？解决方案：新增版本字段。可以快速过滤不需要升级的版本等。</li><li>问题：统计网页点击流量，没访问一个页面都要进行一次数据库计数更新操作，但是对精确度要求不高。解决方案：近似计算。例如每十次更新一次，减小10倍的写入数量。</li><li>问题：业绩排名，游戏排名等精确统计。消耗资源多，聚合计算时间长。解决方案：使用预聚合字段，每次更新数据，同时更新统计字段。</li></ol><h2 id="9-MongoDB事务"><a href="#9-MongoDB事务" class="headerlink" title="9 MongoDB事务"></a><strong>9 MongoDB事务</strong></h2><h3 id="9-1-什么是writeConcern"><a href="#9-1-什么是writeConcern" class="headerlink" title="9.1 什么是writeConcern"></a><strong>9.1 什么是writeConcern</strong></h3><p>writeConcern决定一个写操作落到多少个节点上才算成功。writeConcern 的取值包括:</p><ul><li>0：发起写操作，不关心是否成功;</li><li>1~集群最大数据节点数：写操作需要被复制到指定节点数才算成功;</li><li>majority：写操作需要被复制到大多数节点上才算成功。这样可以防止丢数据的情况。</li></ul><p><strong>发起写操作的程序将阻塞到写操作到达指定的节点数为止</strong> 使用方式：db.test.insert ( {count:1}, {writeConcern: {w:”majority”}}) <strong>注意事项：</strong></p><ul><li>虽然多于半数的 writeConcern 都是安全的，但通常只会设置majority，因为这是等待写入延迟时间最短的选择;</li><li>不要设置 writeConcern等于总节点数，因为一旦有一个节点故障，所有写操作都将失败;</li><li>writeConcern虽然会增加写操作延迟时间，但并不会显著增加集群压力，因此无论是否等待，写操作最终都会复制到所有节点上。设置 writeConcern只是让写操作等待复制后再返回而已;</li><li>应对重要数据应用{w: “majority”}，普通数据可以应用{w:1}以确保最佳性能。</li></ul><h3 id="9-2-读事务"><a href="#9-2-读事务" class="headerlink" title="9.2 读事务"></a><strong>9.2 读事务</strong></h3><ul><li>从哪儿读？数据节点位置-&gt;readPreference解决</li><li>什么样的数据可以读？隔离性-&gt;readConcern解决</li><li><strong>readPreference</strong>：决定使用哪一个节点来满足正在发起的读请求。可选值包括:<ul><li>primary：只选择主节点，默认;</li><li>primaryPreferred：优先选择主节点，如果不可用则选择从节点;</li><li>secondary：只选择从节点;</li><li>secondaryPreferred：优先选择从节点，如果从节点不可用则选择主节点;</li><li>nearest：选择最近的节点;</li></ul></li><li><strong>readConcern</strong>：在readPreference选择了指定的节点后，readConcern决定这个节点上的数据哪些是可读的，类似于关系数据库的隔离级别。可选值包括:<ul><li>available：读取所有可用的数据;</li><li>local：读取所有可用且属于当前分片的数据;(常用)</li><li>majority：读取在大多数节点上提交完成的数据;(常用) &#x2F;&#x2F;不会发生脏读</li><li>linearizable：可线性化读取文档，只读取大多数节点确认过的数据，因此可能读的会很慢。</li><li>snapshot: 读取最近快照中的数据;不会出现脏读、不可重复读、幻读，所有读使用同一快照，直到事务提交才释放。</li></ul></li></ul><h2 id="10-Change-Stream-变更流"><a href="#10-Change-Stream-变更流" class="headerlink" title="10 Change Stream 变更流"></a><strong>10 Change Stream 变更流</strong></h2><p>是实现变更跟踪的解决方案，类似关系型数据库的触发器，但原理不同。 需要在配置文件中开启 enableMajorityreadConcern true</p><ul><li>Change Stream依赖于oplog实现</li><li>关系型数据库触发器是同步的，也就是在事务中事件发生了去做什么，属于同一个事务，触发器可以被认为是一个隐式的嵌套事务。嵌套在引发它的事务中。而Change Stream这个是异步的，也就是在事件发生后才去执行。</li><li>Change Stream当发生故障时，从上次断点重新触发，而关系型数据库会事务回滚。、</li></ul><p>使用场景：</p><ul><li>跨集群的变更复制，在源集群订阅changeStream，一旦得到任何变更就写入目标集群</li><li>微服务联动，例如微服务检测数据库变更，就做出操作</li></ul><p>示例：db.collection.watch([],{maxAwaitTimeMS:30000}) &#x2F;&#x2F;监听集合，最多阻塞等待30000毫秒</p><hr><h2 id="11-分片集群"><a href="#11-分片集群" class="headerlink" title="11 分片集群"></a><strong>11 分片集群</strong></h2><p>分片集群横向扩展，提升性能。</p><ul><li>路由节点mongos：提供集群的单一入口，转发应用端请求，选择合适的数据节点进行读写，合并数据节点返回的数据，建议多个，实现高可用。</li><li>配置节点config：提供集群元数据的存储，分片数据分布的映射。多个配置节点，采用<strong>复制集实现</strong>，实现高可用。</li><li>数据节点shard：一个分片一个复制集，以复制集为单位，横向扩展，最多1024个分片，分片之间数据不重复，必须所有分片完整才能使用。</li></ul><p>三种分片方式：</p><ol><li>基于范围：正对某一个键值的范围进行分片，数据分布不均匀，容易有热点写，就是最新写入的数据，可能总是写入一个分片，但是范围查询效率高。</li><li>基于Hash：采用hash进行分片，这样的话数据分布均匀，写效率高，但是范围查询效率低。适用：日志、物联网等高并发场景。</li><li>基于zone&#x2F;tag：自定义zone，可以按照地域来分片，适用：跨地域，多中心的部署。</li></ol><blockquote><p>分片集群可以有效解决系统性能瓶颈和系统扩容问题，但是消耗较大，管理复杂。 数据量大于2TB考虑分片。如果分片资源占用60%以上就需要考虑扩展了。</p></blockquote><h2 id="12-Mongodb备份与恢复"><a href="#12-Mongodb备份与恢复" class="headerlink" title="12 Mongodb备份与恢复"></a><strong>12 Mongodb备份与恢复</strong></h2><h3 id="12-1-备份机制"><a href="#12-1-备份机制" class="headerlink" title="12.1 备份机制"></a><strong>12.1 备份机制</strong></h3><p>MongoDB的备份机制分为：</p><ul><li>延迟节点备份：复制集slavedelay参数实现。</li><li>全量备份 + oplog增量备份（任意时间点备份和恢复） 最常见的全量备份操作：</li><li>mongodump （比较常用）</li><li>复制数据文件 （需要暂停从节点）</li><li>文件系统快照</li></ul><h3 id="12-2-备份和恢复工具"><a href="#12-2-备份和恢复工具" class="headerlink" title="12.2 备份和恢复工具"></a><strong>12.2 备份和恢复工具</strong></h3><p>备份和恢复工具参数：</p><ul><li>mongodump：备份工具<ul><li>--oplog：复制mongodump从开始到结束过程中的所有oplog到结果中，保存在dump&#x2F;oplog.bson</li></ul></li><li>mongorestore：恢复工具<ul><li>--oplogRelay：恢复完数据再重放oplog，默认重放dump&#x2F;oplog.bson。</li><li>--oplogFile：指定需要重放的oplog文件位置</li><li>--oplogLimit：重放optlog截止到指定时间点</li></ul></li></ul><h3 id="12-3-分片集的备份"><a href="#12-3-分片集的备份" class="headerlink" title="12.3 分片集的备份"></a><strong>12.3 分片集的备份</strong></h3><p>分片集的备份比复制集复杂，因为需要考虑</p><ol><li>分片集各分片之间的数据迁移chunk，取决于config上的元数据，如果实际数据已经迁移到新分片，然而config依然以为数据在旧分片上，就会出现不一致的问题，</li><li>分片集的备份还需要考虑config配置节点的备份</li><li>由于多个分片集时间难以一致，很难完全恢复到同一个时间点上。</li></ol><p><strong>需要解决上面的问题，需要将均衡器停止，不让数据在分片间迁移，这样增量备份和恢复才能保证正确，</strong></p><h2 id="13-索引"><a href="#13-索引" class="headerlink" title="13 索引"></a><strong>13 索引</strong></h2><ul><li>单值索引</li><li>组合索引原则：ESR，<ul><li>精确(Equal)匹配的字段放最前面</li><li>排序(Sort)条件放中间</li><li>范围(Range)匹配的字段放最后面</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NoSQL相关概念</title>
    <link href="/0027.html"/>
    <url>/0027.html</url>
    
    <content type="html"><![CDATA[<h1 id="NoSQL学习"><a href="#NoSQL学习" class="headerlink" title="NoSQL学习"></a><strong>NoSQL学习</strong></h1><blockquote><p>NoSQL：Not Only SQL</p></blockquote><h2 id="1-1-NoSQL起因："><a href="#1-1-NoSQL起因：" class="headerlink" title="1.1 NoSQL起因："></a><strong>1.1 NoSQL起因：</strong></h2><p>大数据时代的3V ：海量Volume、多样Variety、实时Velocity 互联网需求的三高：高并发、高可扩、高性能</p><h2 id="1-2-NoSQL数据模型："><a href="#1-2-NoSQL数据模型：" class="headerlink" title="1.2 NoSQL数据模型："></a><strong>1.2 NoSQL数据模型：</strong></h2><ol><li>KV键值对：Redis</li><li>文档型数据库（以BSON为主）：MongoDB</li><li>列存储数据库：HBase、分布式文件系统、Hadoop</li><li>图关系数据库：不是放图形，放的是朋友圈社交网络。专注于构建关系图谱。Neo4J、InfoGird</li></ol><h2 id="1-3-NoSQL数据原理CAP-BASE"><a href="#1-3-NoSQL数据原理CAP-BASE" class="headerlink" title="1.3 NoSQL数据原理CAP+BASE"></a><strong>1.3 NoSQL数据原理CAP+BASE</strong></h2><h3 id="1-3-1-CAP"><a href="#1-3-1-CAP" class="headerlink" title="1.3.1 CAP"></a><strong>1.3.1 CAP</strong></h3><p>传统的关系型数据库ACID属性：Atomicity（原子性）、Consistency（一致性）、Isolation（独立性）、Durability（持久性）。NoSQL则是 <strong>CAP定理</strong>：</p><ul><li>C：Consistency：强一致性</li><li>A：Availability：高可用性</li><li>P：Partition tolerance：分区容错性</li></ul><p>CAP定理的核心：<strong>一个分布式系统，不能同时满足三个属性，最多同时满足两个，CA、CP、AP</strong></p><ul><li>CA：RDBMS、Oracle</li><li>CP：MongoDB、Redis、HBase</li><li>AP：CouchDB &#x2F;&#x2F;大多数网站架构的选择：弱一致性+高可用+分区容错性</li></ul><p>对于分布式系统 P（分区容错性）是必须满足的。所以只能是CP和AP。</p><h3 id="1-3-2-BASE"><a href="#1-3-2-BASE" class="headerlink" title="1.3.2 BASE"></a><strong>1.3.2 BASE</strong></h3><p>BASE就是为了解决关系数据库的强一致性引起的问题而导致可用性降低而提出的解决方案。 BASe是如下术语缩写：</p><ul><li>基本可用（Basically Available）</li><li>软状态 （Soft state）</li><li>最终一致 （Eventually consistent）</li></ul><p>他的思想是通过让系统放松某一时刻的数据一致性换来系统整体伸缩性和性能上的改观。</p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习_01_相关概念知识</title>
    <link href="/0026.html"/>
    <url>/0026.html</url>
    
    <content type="html"><![CDATA[<p> </p><h1 id="1-Redis学习"><a href="#1-Redis学习" class="headerlink" title="1 Redis学习"></a><strong>1 Redis学习</strong></h1><blockquote><p>主要了解redis安装、使用以及维护，以及与MySQL的区别</p></blockquote><h2 id="1-1-Redis概述"><a href="#1-1-Redis概述" class="headerlink" title="1.1 Redis概述"></a><strong>1.1 Redis概述</strong></h2><p>Redis，Remote Dictionary Server（远程字典服务器），是完全开源免费的，用C语言编写的一个高性能（key-value）分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库（关于NoSQL见 <a href="http://nosql.md/">NoSQL.md</a>）。</p><hr><h2 id="1-2-Redis的特点"><a href="#1-2-Redis的特点" class="headerlink" title="1.2 Redis的特点"></a><strong>1.2 Redis的特点</strong></h2><ol><li>Redis支持数据持久化，支持将内存中的数据持久化到磁盘，重启的时候可以重新加载使用</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供了list、set、zset、hash等数据结构的存储</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ol><h2 id="1-3-Redis的安装"><a href="#1-3-Redis的安装" class="headerlink" title="1.3 Redis的安装"></a><strong>1.3 Redis的安装</strong></h2><h3 id="1-3-1-Redis在Windows上的安装"><a href="#1-3-1-Redis在Windows上的安装" class="headerlink" title="1.3.1 Redis在Windows上的安装"></a><strong>1.3.1 Redis在Windows上的安装</strong></h3><ol><li>在 <a href="https://github.com/microsoftarchive/redis/releases">Git地址</a> 上选择合适的版本，下载安装包</li><li>在该网站中可以下载msi和zip两种格式，msi是微软格式的安装包，zip是压缩包。我们选择msi，这样可以在安装过程中，可以直接通过选择将程序路径加系统环境变量中。</li><li>安装完毕后，需要先做一些设定工作，以便服务启动后能正常运行。打开Redis服务配置文件。注意：不要找错了，通常为<strong>redis.windows-service.conf</strong>，而不是<strong>redis.windows.conf</strong>。后者是以非系统服务方式启动程序使用的配置文件。</li><li>在该配置文件中，找到含有requirepass字样的地方，追加一行，输入**requirepass “”**，引号中为访问Redis时的密码。</li><li>点击”开始”&gt;右击”计算机管理”&gt;”服务和应用程序”&gt;”服务”。再在右侧找到Redis名称的服务，查看启动情况。如未启动，则手动启动之。正常情况下，服务应该正常启动并运行了。</li><li>最后通过测试客户端来测试一下Redis是否正常提供服务，打开cmd，输入命令 <strong>redis-cli</strong>,如果显示端口号证明服务已启动。再输入命令：**auth “”**，引号中为4中设置的密码，即可开始使用Redis服务。</li></ol><h3 id="1-3-2-Redis在CentOS上的安装（推荐，公司常用）"><a href="#1-3-2-Redis在CentOS上的安装（推荐，公司常用）" class="headerlink" title="1.3.2 Redis在CentOS上的安装（推荐，公司常用）"></a><strong>1.3.2 Redis在CentOS上的安装（推荐，公司常用）</strong></h3><blockquote><p>一般下载地址：<a href="http://redis.io/download">http://redis.io/download</a> ，下载最新稳定版本。发现官方网站下载地址很慢，于是找到了华为的Redis下载镜像：<a href="https://mirrors.huaweicloud.com/redis/%E3%80%82">https://mirrors.huaweicloud.com/redis/。</a></p></blockquote><ol><li>cd &#x2F;usr&#x2F;local &#x2F;&#x2F;一般使用此目录下载文件</li><li>wget <a href="https://mirrors.huaweicloud.com/redis/redis-6.2.5.tar.gz">https://mirrors.huaweicloud.com/redis/redis-6.2.5.tar.gz</a> &#x2F;&#x2F;下载redis压缩包</li><li>tar xzf redis-6.2.5.tar.gz &#x2F;&#x2F;解压缩文件</li><li>cd redis-6.2.5</li><li>make &#x2F;&#x2F;编译并链接程序</li><li>执行完 make 命令后，redis-6.2.5 的 src 目录下会出现编译后的 redis 服务程序 redis-server，还有用于测试的客户端程序 redis-cli。</li><li>cd src</li><li>.&#x2F;redis-server &amp; &#x2F;&#x2F;后台启动Redis服务</li><li>.&#x2F;redis-cli &#x2F;&#x2F;测试redis服务是否启动</li></ol><h3 id="1-2-3-在redis安装过程所遇到的问题"><a href="#1-2-3-在redis安装过程所遇到的问题" class="headerlink" title="1.2.3 在redis安装过程所遇到的问题"></a><strong>1.2.3 在redis安装过程所遇到的问题</strong></h3><ol><li>在CentOS上安装Redis时，发现官网的访问速度很慢，于是找到华为云下载镜像解决。</li><li>在2.1.2的第8步中，后台启动Redis服务，还可以通过 <strong>ctrl + z</strong> 将该服务暂停到后台，通过命令 <strong>jobs -l</strong> 查看后台运行的任务的job号jobnumber，再通过命令 <strong>bg jobnumber</strong> 将一个在后台暂停的任务，变成在后台继续执行，或通过 <strong>fg jobnumber</strong>，将后台中的任务调至前台继续运行。</li></ol><hr><h2 id="1-3-Redis的基本使用"><a href="#1-3-Redis的基本使用" class="headerlink" title="1.3 Redis的基本使用"></a><strong>1.3 Redis的基本使用</strong></h2><blockquote><p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p></blockquote><h3 id="1-3-1-Redis命令"><a href="#1-3-1-Redis命令" class="headerlink" title="1.3.1 Redis命令"></a><strong>1.3.1 Redis命令</strong></h3><ol><li>redis-cli -h host -p port -a password &#x2F;&#x2F;连接到远程redis服务上，host是主机IP地址，port代表端口，password是连接密码</li><li>set key value &#x2F;&#x2F;设置指定key的value值，重复设定会覆盖</li><li>get key &#x2F;&#x2F;得到指定key的值</li><li>flushdb&#x2F;flushall &#x2F;&#x2F;清空当前库&#x2F;清空默认的16个库</li><li>select 数据库编号 &#x2F;&#x2F;切换数据库 默认有0-15 总共16个库。</li><li>config get requirepass &#x2F;&#x2F;查看密码</li></ol><h3 id="1-3-2-Redis-key常用命令"><a href="#1-3-2-Redis-key常用命令" class="headerlink" title="1.3.2 Redis key常用命令"></a><strong>1.3.2 Redis key常用命令</strong></h3><ol><li>keys * &#x2F;&#x2F;查看当前数据库的所有key</li><li>exist key &#x2F;&#x2F;查看key是否存在，1代表存在，0代表不存在</li><li>expire key 秒钟 &#x2F;&#x2F;设置key 的过期时间</li><li>ttl key &#x2F;&#x2F;查看key还有几秒过期，-1表示永不过期，-2代表已过期</li><li>type key &#x2F;&#x2F;查看key的类型</li><li>move key 数据库编号 &#x2F;&#x2F;移动key到相应的数据库</li><li>del key &#x2F;&#x2F;删除key</li></ol><blockquote><p>redis 所支持的数据结构都有着自己的遍历、增、删命令。</p></blockquote><h3 id="1-3-3-redis数据结构"><a href="#1-3-3-redis数据结构" class="headerlink" title="1.3.3 redis数据结构"></a><strong>1.3.3 redis数据结构</strong></h3><ol><li>string &#x2F;&#x2F;最基本的数据结构，value最大512M</li><li>list &#x2F;&#x2F;底层是双向链表，有lpush和rpush</li><li>hash &#x2F;&#x2F;依旧是kv模式，但v相当于java中map</li><li>set &#x2F;&#x2F;set是 k1 v1 v2 v3</li><li>zset &#x2F;&#x2F;有序集合，zset在set基础上加上了一个score分数值，zset是 k1 score1 v1 score2 v2</li></ol><hr><h2 id="1-4-redis配置文件（Linux）"><a href="#1-4-redis配置文件（Linux）" class="headerlink" title="1.4 redis配置文件（Linux）"></a><strong>1.4 redis配置文件（Linux）</strong></h2><blockquote><p>修改配置文件前，先将原版配置文件备份 使用cp命令即可 配置文件为 redis.conf</p></blockquote><ol><li>GENERAL。通用配置<ul><li>daemonize no &#x2F;&#x2F;当该项yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。默认是no，启动redis后将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。</li><li>port &#x2F;&#x2F;端口号，默认6379</li><li>bind &#x2F;&#x2F;绑定的ip地址，默认本机</li><li>timeout &#x2F;&#x2F;连接超时时间，当对方空闲时，切断连接，0代表不断开连接</li><li>loglevel &#x2F;&#x2F;日志级别，默认是notice，级别由低到高为</li><li>logfile &#x2F;&#x2F;日志记录方式，默认为标准输出</li><li>databases &#x2F;&#x2F;数据库数量 默认是16个，从0-15</li></ul></li><li>Security。安全配置<ul><li>命令行设置：config set requirepass “yourpassword” &#x2F;&#x2F;设置密码，重启会失效</li><li>配置文件设置：在配置文件中添加 requirepass “yourpassword”，登录redis时需要使用auth “yourpassword”</li></ul></li><li>Limit。限制配置，配置最大客户端、最大内存、缓存过期策略（默认永不过期）等。<ul><li>maxclients：最大客户端，默认10000</li><li>maxmemory ：最大内存(bytes)</li><li>maxmemory-policy：默认永不过期，真实生产环境需要修改策略。</li></ul></li><li>SNAPSHOT：快照<ul><li>rdbchecksum：对快照进行校验，会损耗性能，如果想提升性能可以关闭。</li><li>save：快照触发条件</li><li>dbfilename：快照文件，默认dump.rdb</li><li>dir：指定数据目录，可用config get dir 命令查看目录</li></ul></li><li>APPEND ONLY MODE:<ul><li>appendonly：默认no，yes开启aof持久化</li><li>appendfilename：默认aof文件</li><li>appendfsync：有三种：always（每次数据变更会记录到磁盘）、everyesc（默认，每秒记录，如果一秒内宕机，有数据丢失）、no。</li><li>auto-aof-rewrite-min-size：设置重写的基准值</li><li>auto-aof-rewrite-percentage：设置重写的基准值</li></ul></li></ol><hr><h2 id="1-5-Redis持久化"><a href="#1-5-Redis持久化" class="headerlink" title="1.5 Redis持久化"></a><strong>1.5 Redis持久化</strong></h2><p>有两种持久化方式RDB和AOF。</p><h3 id="1-5-1-RDB（Redis-DataBase）"><a href="#1-5-1-RDB（Redis-DataBase）" class="headerlink" title="1.5.1 RDB（Redis DataBase）"></a><strong>1.5.1 RDB（Redis DataBase）</strong></h3><p>在指定的时间间隔内，将内存中的数据集快照写到磁盘，就是snapshot快照，恢复时从磁盘读入内存，Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失，并且fork会复制主进程内容，会造成内存压力。</p><ul><li>默认保存文件为：dump.rdb</li><li>默认触发条件：1分钟内改了1万次，5分钟内改了10次，15分钟内改了1次。如果想要禁用RDB策略，不要在配置文件中使用任何sava指令。</li></ul><h3 id="1-5-2-AOF（Append-Only-File）"><a href="#1-5-2-AOF（Append-Only-File）" class="headerlink" title="1.5.2 AOF（Append Only File）"></a><strong>1.5.2 AOF（Append Only File）</strong></h3><p>以日志的形式记录每个写操作，redis启动时会按照该文件重新构建数据，配置文件中默认关闭，配置字段appendonly。</p><ul><li>Rewrite机制：因为aof文件只能追加，所以会越来越大，当文件超过设定的阈值时，Redis就会启动aof的文件内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof。触发条件是：默认是AOF文件大小是上次rewrite后大小的一倍且文件大于64M时，配置文件可修改。</li><li>默认保存文件：appendonly.aof</li><li>优点：可以灵活配置持久化时间，aof文件分析容易</li><li>缺点：相同数据集的数据aof文件要远大于rdb文件，恢复速度慢于rdb，aof运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同</li></ul><h3 id="1-5-3-总结"><a href="#1-5-3-总结" class="headerlink" title="1.5.3 总结"></a><strong>1.5.3 总结</strong></h3><p>当RDB和AOF共存时，AOF优先加载，假设AOF文件出现问题（断电，丢包等导致），启动不了Redis，但是可以使用redis-check-aof –fix appendonly.aof修复该文件。可以同时开启两种备份和恢复方式。</p><h2 id="1-6-Redis事务"><a href="#1-6-Redis事务" class="headerlink" title="1.6 Redis事务"></a><strong>1.6 Redis事务</strong></h2><p>一组指令顺序、无间断地执行。</p><ul><li>使用：使用mutil开启一个事务，使用exec执行所有命令，discard取消事务。unwatch 取消watch命令对所有key的监视，watch key[key…] 监视一个或多个key，在事务执行之前这些key被改动，那么事务会被打断。</li><li>指令加入队列时出错，整个事务都失败，而事务执行，某条语句出错，只有该条语句会错，其他语句不受影响。</li><li>watch监控：<ol><li>乐观锁：每次去拿数据的时候都认为别人不会修改，<strong>所以不会上锁</strong>，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。<strong>乐观锁策略:提交版本必须大于记录当前版本才能执行更新。</strong></li><li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都<strong>会上锁</strong>，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li></ol></li><li>一旦执行exec命令，之前加的监控锁都会自动被取消。</li><li>watch类似乐观锁，如果key已经被其他客户端改变，则整个事务都不会执行。</li><li>特性：<ol><li>单独的隔离操作:事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中不会被其他客户端发送来的命令请求所打断。</li><li>没有隔离级别的概念:队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题。</li><li>不保证原子性: redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</li></ol></li></ul><h2 id="1-7-redis的主从复制"><a href="#1-7-redis的主从复制" class="headerlink" title="1.7 redis的主从复制"></a><strong>1.7 redis的主从复制</strong></h2><p>主从复制，主机数据更新后根据配置和策略,自动同步到备机的master&#x2F;slaver机制，Master以写为主，Slave以读为主。</p><ul><li>主从复制功能：<ol><li>读写分离，主库以写为主，从库以读为主</li><li>容灾恢复</li></ol></li><li>基本使用：<ol><li>配从库不配主库</li><li>从库配置：slaveof 主库IP 主库端口 &#x2F;&#x2F;每次与master断开，都需重新连接，但可配入redis.conf。如果主机挂了，从机原地待命，主机回来一切照旧，如果从机挂了，重新回来变成主机，需要重新连接</li><li>配置文件操作：拷贝多个redis.conf，开启daemonize yes，修改pidfile、端口号、Log文件名称，dbfilename名字。</li><li>info replication &#x2F;&#x2F; 查看主从复制信息</li><li>slaveof no one &#x2F;&#x2F;从机变主机</li></ol></li><li>原理：从机连上主机后，先全量复制，再增量复制</li><li>哨兵模式：主机挂了以后，剩余从机里投票出新的主机master。<ol><li>新建sentinel.conf文件</li><li>该文件中添加：sentinel monitor 被监控主机名字(自己起名字) 主机ip 6379 1 &#x2F;&#x2F;后面的数字1代表主机挂了以后，slave投票得票数多少后成为主机</li><li>启动哨兵：redis-sentinel sentinel.conf文件路径</li></ol></li></ul><h2 id="1-8-Redis和MySQL区别"><a href="#1-8-Redis和MySQL区别" class="headerlink" title="1.8 Redis和MySQL区别"></a><strong>1.8 Redis和MySQL区别</strong></h2><ol><li>从类型上来说，MySQL是关系型数据库，Redis是缓存数据库。</li><li>从作用上来说，MySQL用于持久化的存储数据到硬盘，功能强大,但是速度较慢。Redis用于存储使用较为频繁的数据到缓存中，读取速度快。</li><li>从需求上来说，MySQL和Redis因为需求的不同，一般都是配合使用。目前基本都是MySQL(主) + Redis(辅)</li><li>从性能上来说，Redis数据存放在内存，MySQL放在磁盘因此性能要优于MySQL。</li><li>从安全性上而言MySQL要优于Redis。</li></ol><h2 id="1-9-总结"><a href="#1-9-总结" class="headerlink" title="1.9 总结"></a><strong>1.9 总结</strong></h2><p>因为磁盘造价便宜，因此MySQL用来存放冷数据，而MySQL每次读取数据都需要进行IO操作，磁盘IO比较耗时，因此采用缓存数据库Redis存放热数据来减少数据IO，从而提升系统性能。</p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux新硬盘的挂载操作</title>
    <link href="/0029.html"/>
    <url>/0029.html</url>
    
    <content type="html"><![CDATA[<p> </p><h3 id="情况说明"><a href="#情况说明" class="headerlink" title="情况说明"></a><strong>情况说明</strong></h3><p>使用VMware虚拟机的过程中发现硬盘大小不够用，但是扩展硬盘需要删除快照，这显然不可接受。于是就新增了一块磁盘，但是新增的磁盘，没有挂载到文件系统里，于是我们需要将新的硬盘挂载到Linux文件系统中。</p><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a><strong>操作步骤</strong></h4><ol><li><p>查看已经挂载的分区和文件系统类型(ext4&#x2F;xfs)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">devtmpfs                devtmpfs  1.9G     0  1.9G    0% /dev<br>tmpfs                   tmpfs     1.9G     0  1.9G    0% /dev/shm<br>tmpfs                   tmpfs     1.9G   12M  1.9G    1% /run<br>tmpfs                   tmpfs     1.9G     0  1.9G    0% /sys/fs/cgroup<br>/dev/mapper/centos-root xfs        17G   14G  3.2G   82% /<br>/dev/sda1               xfs      1014M  152M  863M   15% /boot<br>tmpfs                   tmpfs     378M     0  378M    0% /run/user/0<br><br></code></pre></td></tr></table></figure><p>我们可以看到第一次磁盘是xfs文件系统，我们要将新的硬盘也格式化为这种格式。</p></li><li><p>查看磁盘信息 <code># fdisk -l</code></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@centos7 ~]<span class="hljs-comment">#  fdisk -l</span><br><br>磁盘 /dev/sda：21.5 GB,<span class="hljs-number"> 21474836480 </span>字节，41943040 个扇区<br>Units = 扇区 of<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 512 </span>=<span class="hljs-number"> 512 </span>bytes<br>扇区大小(逻辑/物理)：512 字节 /<span class="hljs-number"> 512 </span>字节<br>I/O 大小(最小/最佳)：512 字节 /<span class="hljs-number"> 512 </span>字节<br>磁盘标签类型：dos<br>磁盘标识符：0x000b6dc8<br><br>   设备 Boot      Start         End      Blocks   Id  System<br>/dev/sda1   *       <span class="hljs-number"> 2048 </span>   <span class="hljs-number"> 2099199 </span>   <span class="hljs-number"> 1048576 </span> <span class="hljs-number"> 83 </span> Linux<br>/dev/sda2        <span class="hljs-number"> 2099200 </span>  <span class="hljs-number"> 41943039 </span>  <span class="hljs-number"> 19921920 </span>  8e  Linux LVM<br><br>磁盘 /dev/sdb：42.9 GB,<span class="hljs-number"> 42949672960 </span>字节，83886080 个扇区<br>Units = 扇区 of<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 512 </span>=<span class="hljs-number"> 512 </span>bytes<br>扇区大小(逻辑/物理)：512 字节 /<span class="hljs-number"> 512 </span>字节<br>I/O 大小(最小/最佳)：512 字节 /<span class="hljs-number"> 512 </span>字节<br><br><br>磁盘 /dev/mapper/centos-root：18.2 GB,<span class="hljs-number"> 18249416704 </span>字节，35643392 个扇区<br>Units = 扇区 of<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 512 </span>=<span class="hljs-number"> 512 </span>bytes<br>扇区大小(逻辑/物理)：512 字节 /<span class="hljs-number"> 512 </span>字节<br>I/O 大小(最小/最佳)：512 字节 /<span class="hljs-number"> 512 </span>字节<br><br><br>磁盘 /dev/mapper/centos-swap：2147 MB,<span class="hljs-number"> 2147483648 </span>字节，4194304 个扇区<br>Units = 扇区 of<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 512 </span>=<span class="hljs-number"> 512 </span>bytes<br>扇区大小(逻辑/物理)：512 字节 /<span class="hljs-number"> 512 </span>字节<br>I/O 大小(最小/最佳)：512 字节 /<span class="hljs-number"> 512 </span>字节<br></code></pre></td></tr></table></figure><p>可以看到还有一个磁盘 <code>/dev/sdb</code> 没有挂载。</p></li><li><p>格式化硬盘 格式化分区为XFS，使用mkfs.xfs命令。如果已有其他文件系统创建在此分区，必须加上”-f”参数来覆盖它。 <code>mkfs.xfs -f /dev/sdb</code></p></li><li><p>挂载硬盘 格式化后分区来挂载。假设&#x2F;mnt是XFS本地挂载点。使用下述命令挂载： <code>mount -t xfs /dev/sdb /mnt</code></p></li><li><p>验证XFS挂载是否成功： <code>df -Th /dev/sdb</code></p></li><li><p>如果你想要启动时自动挂载XFS分区在&#x2F;mnt上，加入下列行到&#x2F;etc&#x2F;fstab： <code>/dev/sdb /mnt xfs defaults 0 0</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>devops_jenkins_06_spring boot + vue项目前后端项目持续部署（2）</title>
    <link href="/035.html"/>
    <url>/035.html</url>
    
    <content type="html"><![CDATA[<h1 id="jenkins中进行项目部署"><a href="#jenkins中进行项目部署" class="headerlink" title="jenkins中进行项目部署"></a><strong>jenkins中进行项目部署</strong></h1><p>在部署真正的项目之前，我们进行一下jenkins的项目部署，了解相关配置。</p><h2 id="1-jenkins工作空间"><a href="#1-jenkins工作空间" class="headerlink" title="1 jenkins工作空间"></a><strong>1 jenkins工作空间</strong></h2><p>如何查看工作目录：系统管理-》系统配置 <img src="https://b3logfile.com/file/2022/05/image-dd8c90c5.png" alt="image.png"> 可以看到工作目录是 &#x2F;var&#x2F;lib&#x2F;jenkins <img src="https://b3logfile.com/file/2022/05/image-bad7aa9b.png" alt="image.png"> 进入工作目录，可以看到该文件夹下，目前还没有名为 workspace 的文件夹<img src="https://b3logfile.com/file/2022/05/image-8d6b7f38.png" alt="image.png"> 接下来我们新建项目并build后，该目录下会新增一个workspace文件夹，第3步末尾会查看该目录变化</p><h2 id="2-配置前工作"><a href="#2-配置前工作" class="headerlink" title="2 配置前工作"></a><strong>2 配置前工作</strong></h2><h3 id="2-1-SSH-Server"><a href="#2-1-SSH-Server" class="headerlink" title="2.1 SSH Server"></a><strong>2.1 SSH Server</strong></h3><p>因为我们的目的是Jenkins构建完成之后能在在其它设备上部署应用，所以在配置此项之前，我们还需要配置 SSH Server ; SSH Server使得jenkins通过SSH协议与远程设备连接，进行操作，比如执行远程服务器上的脚本。 这里我们需要用到一个插件，<strong>Publish over SSH</strong>，前面已经安装过了。同样是“系统管理”-》系统配置 <img src="https://b3logfile.com/file/2022/05/image-166c5cf2.png" alt="image.png"> 新增 SSH server。 <img src="https://b3logfile.com/file/2022/05/image-7e59c031.png" alt="image.png"> 连接SSH我们知道要么使用密码登录，要么使用公私钥。同一页面，点击高级设置。 <img src="https://b3logfile.com/file/2022/05/image-3cef6425.png" alt="image.png"> 这里我们使用密码登录，高级设置中还可以该端口等，服务器端端口没变就不改了。输入密码后测试是否通过，success，通过。 <img src="https://b3logfile.com/file/2022/05/image-67f53af2.png" alt="image.png"> 保存后，重复上面的操作，再新建一个前端server，但是我们前后端都部署再同一台服务器上，其实这部要看你具体的服务器搭配了。</p><h3 id="2-2-使用简单shell脚本"><a href="#2-2-使用简单shell脚本" class="headerlink" title="2.2 使用简单shell脚本"></a><strong>2.2 使用简单shell脚本</strong></h3><p>jenkins使用前后端项目的服务器上的shell脚本进行代码部署，我们先使用简单的shell脚本进行配置测试，通过后，再正式项目配置。 cd &#x2F;usr&#x2F;local&#x2F;bd-system&#x2F; 1）<strong>前后端服务器上</strong>，新建脚本spring-boot-demo.sh vim <a href="http://spring-boot-demo.sh/">spring-boot-demo.sh</a> 脚本内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;spring boot demo 脚本运行&quot;</span><br><span class="hljs-comment"># exit 0</span><br></code></pre></td></tr></table></figure><p>2） 运行脚本 . <a href="http://spring-boot-demo.sh/">spring-boot-demo.sh</a>。 <img src="https://b3logfile.com/file/2022/05/image-506155e3.png" alt="image.png"> 3）前端测试脚本部署，同样新建一个脚本 vim <a href="http://vue-demo.sh/">vue-demo.sh</a> 脚本内容： <code>echo &quot;vue -demo 脚本执行&quot;</code> <img src="https://b3logfile.com/file/2022/05/image-d5b8da99.png" alt="image.png"></p><h2 id="3-使用jenkins部署后端spring-boot项目"><a href="#3-使用jenkins部署后端spring-boot项目" class="headerlink" title="3 使用jenkins部署后端spring-boot项目"></a><strong>3 使用jenkins部署后端spring-boot项目</strong></h2><p>主页新建任务：<img src="https://b3logfile.com/file/2022/05/image-e9ac91f6.png" alt="image.png"> 输入任务名称和选择 <strong>构建一个maven项目</strong> ，点击确定。<img src="https://b3logfile.com/file/2022/05/image-a735de75.png" alt="image.png"></p><h3 id="3-1-General-配日志"><a href="#3-1-General-配日志" class="headerlink" title="3.1 General 配日志"></a><strong>3.1 General 配日志</strong></h3><p>跳转到编辑项目页面，勾选 <strong>丢弃旧的构建</strong> ，选择定时丢弃旧的构建 <img src="https://b3logfile.com/file/2022/05/image-8c7d853f.png" alt="image.png"></p><h3 id="3-2-源码管理"><a href="#3-2-源码管理" class="headerlink" title="3.2 源码管理"></a><strong>3.2 源码管理</strong></h3><p>添加Git源码管理<img src="https://b3logfile.com/file/2022/05/image-022616c0.png" alt="image.png"> 1）GitLab、Gitee一样 我们以Gitee为例，找到自己的后端代码仓库，复制仓库链接，这里使用HTTPS的，暂且先不用SSH方式。 <img src="https://b3logfile.com/file/2022/05/image-684c909c.png" alt="image.png"> 将链接复制过去后，因为没有凭证，会报错。 <img src="https://b3logfile.com/file/2022/05/image-7d2faadf.png" alt="image.png"> 点击新增之后，填写下表，填入gitee用户名、密码 <img src="https://b3logfile.com/file/2022/05/image-2f02f76b.png" alt="image.png"> 添加之后，在Credentials选择你的凭证，发现就不报错了。 <img src="https://b3logfile.com/file/2022/05/image-bd97fe20.png" alt="image.png"> 我们这里只有一个master分支，就不用更改了。它默认就是master。 2） Github GitHub我没有尝试，具体可参考<a href="https://blog.csdn.net/sinat_41811051/article/details/117285987">CentOS7&#x2F;8系统下，使用Jenkins实现SpringBoot+Vue前后端分离项目持续集成，一键编译打包跨设备部署，完整详细教学演示_MurrayLaw的博客-CSDN博客</a></p><h3 id="3-3-构建触发器"><a href="#3-3-构建触发器" class="headerlink" title="3.3 构建触发器"></a><strong>3.3 构建触发器</strong></h3><p>在这我们可以设置何时构建，这里我们就全部取消，当要构建的时候，手动构建就行。 <img src="https://b3logfile.com/file/2022/05/image-cec9daac.png" alt="image.png"></p><h3 id="3-4-构建环境"><a href="#3-4-构建环境" class="headerlink" title="3.4 构建环境"></a><strong>3.4 构建环境</strong></h3><p>这里非必要我们就不要动它，默认全空。 <img src="https://b3logfile.com/file/2022/05/image-514a1e5c.png" alt="image.png"></p><h3 id="3-5-Build"><a href="#3-5-Build" class="headerlink" title="3.5 Build"></a><strong>3.5 Build</strong></h3><p>1）<strong>Root POM</strong>：😋输入框填你要编译打包的pom路径；</p><ul><li>情景一：我想使用Maven编译打包整个项目所有的子Module，就需要获取父级pom在Git仓库的路径。从上上图得知父级pom在Git仓库的根目录下，则输入框填入“**.&#x2F;pom.xml**”或”pom.xml”就是对整个项目进行构建。</li><li>情景二：我想使用Maven编译打包项目的一个子Module：sunline-mmp-admin，就需要获取该Module的pom在Git仓库的路径；从上图得知该Module的pom在Git仓库根目录下的文件夹 sunline-mmp-admin 下，则输入框填入“.&#x2F;sunline-mmp-admin&#x2F;pom.xml”或”sunline-mmp-admin&#x2F;pom.xml”就是对该单个Module进行构建。</li></ul><p>我所用的是第一种情况，直接默认的pom.xml就行<img src="https://b3logfile.com/file/2022/05/image-9f3b578d.png" alt="image.png"> 2）Goals and options：输入框填指定要执行的目标，例如 “clean install” 或 “deploy” ；此处还可以接受Maven的任何其他命令行选项，例如”-e”或”-<a href="http://djava.net/">Djava.net</a>.preferIPv4Stack&#x3D;true” <img src="https://b3logfile.com/file/2022/05/image-d4ecadb8.png" alt="image.png"></p><h3 id="3-6-Post-step-构建设置"><a href="#3-6-Post-step-构建设置" class="headerlink" title="3.6 Post step &amp; 构建设置"></a><strong>3.6 Post step &amp; 构建设置</strong></h3><p>Post Step设置如下： <img src="https://b3logfile.com/file/2022/05/image-2d0fa1ac.png" alt="image.png"> 添加构建后操作：选择如下图所示<img src="https://b3logfile.com/file/2022/05/image-e96f2d3c.png" alt="image.png"></p><ol><li>Source files： 因为我们这里是Spring Boot项目，所以源文件只需要Jar包。</li><li>Remove prefix： 去除上面源文件路径前缀，避免生成多余文件夹。</li><li>Remote directory： 之前我们配置SSH Server时，就有配置一个操作目录，如果此处再填写一个路径的话，会从SSH Server配置内的操作目录进入到此处填写的目录；如果SSH Server操作的机器上没有此处填写的文件夹，则会自动创建文件夹。</li><li>Exec command： 在这里填我们之前编辑的脚本路径，最好填绝对路径；当源文件被上传到远程设备的文件夹后，SSH Server会运行该脚本。你也可以直接在这里写shell代码，但是调试不大方便，故这里使用脚本路径。</li></ol><p>注：在配置此项时，要在部署项目的机器上提前创建下面 <strong>Remote directory 、Exec command</strong> 对应的目录或脚本文件 1） 单module配置<img src="https://b3logfile.com/file/2022/05/image-c8c424ec.png" alt="image.png"> 更正一下，后面出现错误。<img src="https://b3logfile.com/file/2022/05/image-8e31977d.png" alt="image.png"> 2）多个module配置（这里我们没有用到，参考这个大佬的）<img src="https://b3logfile.com/file/2022/05/solo-fetchupload-7841426837006663940-3f544cb5.png" alt="在这里插入图片描述"> 点击保存</p><h2 id="4-构建Build"><a href="#4-构建Build" class="headerlink" title="4 构建Build"></a><strong>4 构建Build</strong></h2><h3 id="4-1-查看项目详情"><a href="#4-1-查看项目详情" class="headerlink" title="4.1 查看项目详情"></a><strong>4.1 查看项目详情</strong></h3><p>此时我们已经建立了第一个项目，回到主页之之后，点击项目名查看项目详情<img src="https://b3logfile.com/file/2022/05/image-5febcd67.png" alt="image.png"> 点击立即构建并查看构建记录详情 <img src="https://b3logfile.com/file/2022/05/image-caa5179e.png" alt="image.png"> 可以看到构建失败了查看控制台输出， <img src="https://b3logfile.com/file/2022/05/image-2e3760bb.png" alt="image.png"> 解决方法：<a href="https://www.cnblogs.com/wurainren/p/13604875.html">Jenkins部署spring boot项目时，构建 报xxxxx.RELEASE.pom.part.lock (No such file or directory) and ‘parent.relativePath’ points at wrong local POM的错误 - 言易解道 - 博客园 (</a><a href="http://cnblogs.com/">cnblogs.com</a><a href="https://www.cnblogs.com/wurainren/p/13604875.html">)</a> 再次构建：<img src="https://b3logfile.com/file/2022/05/image-947f8ae0.png" alt="image.png"> 正在下载maven依赖，说明前面的问题已经解决。 等待后，依然构建失败，毕竟第一次，失败很正常，尝试解决。<img src="https://b3logfile.com/file/2022/05/image-a2b31cae.png" alt="image.png"> 应该是jdk的配置问题，经过搜索，发现时使用yum安装openjdk8的问题，后续考虑更换版本。于是我们点击配置更换jdk。<a href="https://www.pianshen.com/article/99561365812/">centos7 用yum安装java8 - 程序员大本营 (</a><a href="http://pianshen.com/">pianshen.com</a><a href="https://www.pianshen.com/article/99561365812/">)</a><img src="https://b3logfile.com/file/2022/05/image-5435d398.png" alt="image.png">再次构建， 报错：<img src="https://b3logfile.com/file/2022/05/image-3906a75d.png" alt="image.png"> 经过验证后发现，我上传jdk版本是windows版的，找不到里面的都是java.exe，之类的所以报错，于是需要重新配置java jdk。 去官网下载后，按照之前的方法重新配置上传。并在系统配置-》工具配置中修改jdk版本以及对应的目录。 可以看到构建成功：<img src="https://b3logfile.com/file/2022/05/image-bdae48ee.png" alt="image.png"> 可以日志中还是存在问题：<img src="https://b3logfile.com/file/2022/05/image-d5cb8cb9.png" alt="image.png"> 文件并没有传输过去，应该是配置存在问题。更正配置<img src="https://b3logfile.com/file/2022/05/image-8e31977d.png" alt="image.png"> 重新构建，更新成功 <img src="https://b3logfile.com/file/2022/05/image-9d362183.png" alt="image.png"> 查看项目服务器上的文件是否更新：<img src="https://b3logfile.com/file/2022/05/image-2eb910aa.png" alt="image.png"> 更新成功</p><h3 id="4-2-查看jenkins工作目录"><a href="#4-2-查看jenkins工作目录" class="headerlink" title="4.2 查看jenkins工作目录"></a><strong>4.2 查看jenkins工作目录</strong></h3><p>之前我们说过Jenkins会在工作目录下生成一个workspace文件用来存放git拉下来的项目，我们查看一下。<img src="https://b3logfile.com/file/2022/05/image-661b1867.png" alt="image.png"> <img src="https://b3logfile.com/file/2022/05/image-c0b574ef.png" alt="image.png">进入工作台，可以看到有两个文件夹，一个是我们的项目名加 @tmp，这个 @tmp 后缀的文件夹是空的，咱们不管；另一个是文件夹名称是我们的项目名，进入后从内容可以看到，这其实就是一个git仓库了<img src="https://b3logfile.com/file/2022/05/image-6596c1ed.png" alt="image.png"></p><h3 id="4-3-完善shell脚本"><a href="#4-3-完善shell脚本" class="headerlink" title="4.3 完善shell脚本"></a><strong>4.3 完善shell脚本</strong></h3><p>之前我们使用的时项目服务器上的存放在 cd &#x2F;usr&#x2F;local&#x2F;bd-system <a href="http://目录下的spring-boot-demo.sh/">目录下的spring-boot-demo.sh</a>，只是简单的输出，现在我们将其修改为项目运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;开始执行脚本&quot;</span><br><span class="hljs-built_in">cd</span> /usr/local/bd-system/back/                           <span class="hljs-comment">#进入jar包存放路径</span><br><span class="hljs-built_in">kill</span> -9 `lsof -ti:8052`         <span class="hljs-comment">#关闭8052端口的程序，取消占用</span><br><span class="hljs-built_in">nohup</span> java  -jar bdxm-2.1.1-SNAPSHOT.jar --spring.profiles.active=prod  &gt;/dev/null 2&gt;&amp;1 &amp;                       <span class="hljs-comment">#设置参数启动项目</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;脚本执行完成&quot;</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure><p>随便访问一个接口，可以看到后台项目已经成功启动了。 <img src="https://b3logfile.com/file/2022/05/image-2b6306a5.png" alt="image.png"></p><h2 id="5-配置前端vue项目"><a href="#5-配置前端vue项目" class="headerlink" title="5 配置前端vue项目"></a><strong>5 配置前端vue项目</strong></h2><p>主页-新建任务-输入项目名称 freestyle project，确定<img src="https://b3logfile.com/file/2022/05/image-5f783bf8.png" alt="image.png"></p><h3 id="5-1-General"><a href="#5-1-General" class="headerlink" title="5.1 General"></a><strong>5.1 General</strong></h3><p>同上spring boot项目</p><h3 id="5-2-源码管理"><a href="#5-2-源码管理" class="headerlink" title="5.2 源码管理"></a><strong>5.2 源码管理</strong></h3><p>选择Git <img src="https://b3logfile.com/file/2022/05/image-3b426def.png" alt="image.png"></p><h3 id="5-3-构建触发器"><a href="#5-3-构建触发器" class="headerlink" title="5.3 构建触发器"></a><strong>5.3 构建触发器</strong></h3><p>同spring boot项目，默认即可</p><h3 id="5-4-构建环境"><a href="#5-4-构建环境" class="headerlink" title="5.4 构建环境"></a><strong>5.4 构建环境</strong></h3><p>第一步勾选 <strong>Provide Node &amp; npm bin&#x2F; folder to PATH</strong> 第二步下拉选择我们之前配好的Node.Js，一般会默认选择配置存在的Node.Js<img src="https://b3logfile.com/file/2022/05/image-4c39ecc8.png" alt="image.png"></p><h3 id="5-4-构建"><a href="#5-4-构建" class="headerlink" title="5.4 构建"></a><strong>5.4 构建</strong></h3><p><strong>增加构建步骤</strong> &#x3D;&gt;执行 shell <img src="https://b3logfile.com/file/2022/05/image-06a1fe5a.png" alt="image.png"> <img src="https://b3logfile.com/file/2022/05/image-dca649c3.png" alt="image.png"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span> <span class="hljs-comment">#编译</span><br>npm run <span class="hljs-keyword">build </span><span class="hljs-comment">#打包</span><br>tar -zcvf <span class="hljs-keyword">dist.tar.gz </span><span class="hljs-keyword">dist </span><span class="hljs-comment"># 打成压缩包方便传输</span><br></code></pre></td></tr></table></figure><h3 id="5-5-构建后操作"><a href="#5-5-构建后操作" class="headerlink" title="5.5 构建后操作"></a><strong>5.5 构建后操作</strong></h3><p><strong>增加构建后操作步骤</strong> &#x3D;&gt; <strong>Send build artifacts over SSH</strong> <img src="https://b3logfile.com/file/2022/05/image-e5a223b7.png" alt="image.png"> <img src="https://b3logfile.com/file/2022/05/image-eb34045b.png" alt="image.png"> 这时我们就需要更换重新写下，前端脚本：vim &#x2F;usr&#x2F;local&#x2F;bd-system&#x2F;vue-demo.sh</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;前端脚本执行！&quot;</span><br><span class="hljs-keyword">cd</span> /usr/local/<span class="hljs-keyword">bd</span>-<span class="hljs-built_in">system</span>/front/<br>tar -zxvf dist.tar.gz<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;前端脚本执行完毕！&quot;</span><br></code></pre></td></tr></table></figure><p>构建后，检查是否成功：前端部署成功，前后端联调也成功！！yes！！<img src="https://b3logfile.com/file/2022/05/image-f3ba647c.png" alt="image.png"> 注：以上前后端之前就曾经使用过nginx，于是就省去了nginx配置的繁琐过程。如果想要使用nginx，请参考参考文献中的。 再次感谢各位大佬的博客。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h1><ul><li><a href="https://blog.csdn.net/sinat_41811051/article/details/117285987">CentOS7&#x2F;8系统下，使用Jenkins实现SpringBoot+Vue前后端分离项目持续集成，一键编译打包跨设备部署，完整详细教学演示_MurrayLaw的博客-CSDN博客</a></li><li><a href="https://www.cnblogs.com/wurainren/p/13604875.html">Jenkins部署spring boot项目时，构建 报xxxxx.RELEASE.pom.part.lock (No such file or directory) and ‘parent.relativePath’ points at wrong local POM的错误 - 言易解道 - 博客园 (</a><a href="http://cnblogs.com/">cnblogs.com</a><a href="https://www.cnblogs.com/wurainren/p/13604875.html">)</a></li><li><a href="https://www.pianshen.com/article/99561365812/">centos7 用yum安装java8 - 程序员大本营 (</a><a href="http://pianshen.com/">pianshen.com</a><a href="https://www.pianshen.com/article/99561365812/">)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>devops_jenkins_05_spring boot + vue项目前后端项目持续部署（1）</title>
    <link href="/034.html"/>
    <url>/034.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: devops_jenkins_05_spring boot + vue项目前后端项目持续部署（1） date: 2022-05-04 02:03:53.0 updated: 2022-05-05 23:31:34.357 url: &#x2F;archives&#x2F;jenkins05 categories:</p><ul><li>devops tags:</li><li>jenkins</li><li>devops</li><li>持续部署</li></ul><hr><p>​​</p><h1 id="1-实现目标"><a href="#1-实现目标" class="headerlink" title="1 实现目标"></a><strong>1 实现目标</strong></h1><p>​目前拥有两台腾讯云服务器，其中一台用来运行项目（本次前后端均在一个服务器上），一台用来运行jenkins持续部署。实现从gitLab上拉取代码，并持续部署的一个效果。 主要就是分为：​</p><ol><li>jenkins服务器部署过程</li><li>前后端项目服务器部署过程​在前面的文章我们已经安装好了jenkins，现在我们只需要进行后续的步骤即可。​</li></ol><h1 id="jenkins工作流程"><a href="#jenkins工作流程" class="headerlink" title="jenkins工作流程"></a><strong>jenkins工作流程</strong></h1><p>​_Jenkins的工作流程就是：_​<strong>①从版本控制器下拉代码到本地</strong> &gt; <strong>②本地编译打包</strong> &gt; <strong>③传输打包好的文件到远程服务器</strong> &gt;<strong>④在远程服务器运行脚本</strong> &gt; <strong>⑤完成项目实施</strong>​</p><h1 id="1-配置java开发环境"><a href="#1-配置java开发环境" class="headerlink" title="1 配置java开发环境"></a><strong>1 配置java开发环境</strong></h1><p>​由上面的思路我们知道，两台服务器都需要java环境，一个打包一个部署运行。​这个我们就跳过了，之前已经安装过了，安装的都是1.8版本的。​</p><h1 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2 安装Git"></a><strong>2 安装Git</strong></h1><p>​<strong>在jenkins服务器上进行安装Git。</strong> 命令：​yum -y install git title: devops_jenkins_05_spring boot + vue项目前后端项目持续部署（1） date: 2022-05-04 02:03:53.0 updated: 2022-05-05 23:31:34.357 url: &#x2F;archives&#x2F;jenkins05 categories: devops tags: jenkins devops 持续部署 1 实现目标 目前拥有两台腾讯云服务器，其中一台用来运行项目（本次前后端均在一个服务器上），一台用来运行jenkins持续部署。实现从gitLab上拉取代码，并持续部署的一个效果。 主要就是分为： jenkins服务器部署过程 前后端项目服务器部署过程 在前面的文章我们已经安装好了jenkins，现在我们只需要进行后续的步骤即可。 jenkins工作流程 Jenkins的工作流程就是： ①从版本控制器下拉代码到本地 &gt; ②本地编译打包 &gt; ③传输打包好的文件到远程服务器 &gt;④在远程服务器运行脚本 &gt; ⑤完成项目实施 1 配置java开发环境 由上面的思路我们知道，两台服务器都需要java环境，一个打包一个部署运行。 这个我们就跳过了，之前已经安装过了，安装的都是1.8版本的。 2 安装Git 在jenkins服务器上进行安装Git。 命令： yum -y install git git –version image.png安装成功 3 安装maven 安装位置：jenkins服务器 在之前我们介绍过在里面安装maven，现在看一下，感觉之前做的太简单了，不太正确。这里重新装一下。这次我们安装在&#x2F;usr&#x2F;local目录下 3.1 下载安装包 首先 cd &#x2F;usr&#x2F;local 进入Linux中用户级的程序目录 wget <a href="https://mirrors.bfsu.edu.cn/apache/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz">https://mirrors.bfsu.edu.cn/apache/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz</a> 下载安装包，可以看到我们的当前目录下多了一个名为apache-maven-3.8.1-bin.tar.gz 的文件 3.2 解压 tar -zxvf &#x2F;usr&#x2F;local&#x2F;apache-maven-3.8.5-bin.tar.gz image.png 3.3 配置maven 1）创建本地maven仓库 mkdir mavenRepo 创建maven仓库 ls 查看多了 mavenRepo 文件夹，说明创建成功 image.png 2）修改settings.xml cd apache-maven-3.8.5&#x2F;conf&#x2F; ls image.png 修改settings.xml文件 vim settings.xml 新增语句： &#x2F;usr&#x2F;local&#x2F;mavenRepo image.png 删除语句：将下面框住的部分全部删除。 image.png 然后把你项目开发过程中用到的maven配置文件打开，找出除本地仓库外不同的内容，然后将其都放入服务端maven配置文件里对应的标签内。就是开发环境配置文件和服务器端一致。 （比如我是用idea开发，其maven配置文件目录在：{idea安装目录}\plugins\maven\lib\maven3\conf） 3） Maven系统环境变量配置 vim &#x2F;etc&#x2F;profile 进入系统环境配置编辑，文件中追加以下内容： export MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;apache-maven-3.8.5 export PATH&#x3D;${PATH}:${MAVEN_HOME}&#x2F;bin source &#x2F;etc&#x2F;profile 命令重新加载&#x2F;etc&#x2F;profile文件，使修改的内容在当前shell窗口中生效 4）验证 使用 mvn -v echo $MAVEN_HOME查看Maven是否安装配置成功image.png 4 安装Node.js 安装位置：jenkins服务器 4.1 下载Node.js 先查看我自己的电脑的node版本，npm版本，cnpm版本。 image.png 之前出现过vue因为版本的问题，出现很多前端问题，没有时间解决，所以我们尽量先统一版本。 下载最新版可进入，进入国内官网<a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a> 我们直接进入镜像站寻找我们想要的版本：CNPM Binaries Mirror (<a href="http://npmmirror.com/">npmmirror.com</a>) 找到14.8.0的linux x86版本，复制下载地址： <a href="https://registry.npmmirror.com/-/binary/node/v14.8.0/node-v14.8.0-linux-x64.tar.xz">https://registry.npmmirror.com/-/binary/node/v14.8.0/node-v14.8.0-linux-x64.tar.xz</a> 1） 开始下载 cd &#x2F;usr&#x2F;local 进入到我们用户级的程序目录； wget <a href="https://registry.npmmirror.com/-/binary/node/v14.8.0/node-v14.8.0-linux-x64.tar.xz">https://registry.npmmirror.com/-/binary/node/v14.8.0/node-v14.8.0-linux-x64.tar.xz</a> 2）解压 tar -xvf node-v14.8.0-linux-x64.tar.xz lsimage.png 3） 配置Node.js环境变量 vim &#x2F;etc&#x2F;profile 编辑环境变量 在开头是 export PATH&#x3D; 后面加入 :${PATH}:&#x2F;usr&#x2F;local&#x2F;node-v14.8.0-linux-x64&#x2F;bin 注意冒号，英文冒号，node.js的根文件夹名称 。 image.png source &#x2F;etc&#x2F;profile 命令重新加载&#x2F;etc&#x2F;profile文件 4）验证 node -v 查看node版本 npm -v 查看npm版本image.png 可以看到已经成功了，接下来是配置国内淘宝的cnpm npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> 安装 cnpm 。 cnpm -v 查看 cnpm 版本，如下图所示，表示安装成功。image.png由于是香港服务器，用上面的淘宝的镜像可能不太好用：用npm install -g cnpm –registry&#x3D;<a href="http://r.cnpmjs.org/">http://r.cnpmjs.org/</a> 查看cnpm版本，7.1.1 不过问题不大，香港服务器使用npm应该不会受到限制。 image.png至此jenkins的安装就算安装完成了。 5 jenkins安装与部署 经过之前的折腾我们基本已经把jenkins安装好了。现在只要将相关的工具配置一下就可以了。之前已经配置过jdk，maven我们需要重新配置一下。 5.1 配置maven image.png 5.2 配置Git whereis git 查看git路径 image.png 我们就用第一个路径 &#x2F;usr&#x2F;bin&#x2F;git image.png 5.3 配置Node.js 同样的配置方法。 image.png 接下来我们就要开始介绍如何配置具体的项目了 参考文献 CentOS7&#x2F;8系统下，使用Jenkins实现SpringBoot+Vue前后端分离项目持续集成，一键编译打包跨设备部署，完整详细教学演示_MurrayLaw的博客-CSDN博客 idea maven配置文件设置_byxu的博客-CSDN博客_idea maven配置文件</p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>devops_jenkins_04_常用插件安装</title>
    <link href="/033.html"/>
    <url>/033.html</url>
    
    <content type="html"><![CDATA[<p>title: devops_jenkins_04_常用插件安装 date: 2022-05-03 21:42:04.0 updated: 2022-05-05 23:31:52.94 url: &#x2F;archives&#x2F;jenkins04 categories:</p><ul><li>devops tags:</li><li>jenkins</li><li>devops</li><li>持续部署</li></ul><hr><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a><strong>安装插件</strong></h1><p>这里只介绍我安装的，其他的一些插件，请查看参考文献。这些安装的插件，后面会详细介绍，如果是需要一些新的插件时也会在文章中提到。</p><h2 id="1-用户以及权限"><a href="#1-用户以及权限" class="headerlink" title="1 用户以及权限"></a><strong>1 用户以及权限</strong></h2><ol><li>Role-based Authorization Strategy <a href="https://plugins.jenkins.io/role-strategy%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%8F%92%E4%BB%B6%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%EF%BC%88Role%EF%BC%89%E7%9A%84%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5%EF%BC%8C%E6%94%AF%E6%8C%81%E5%88%9B%E5%BB%BAglobal%E8%A7%92%E8%89%B2%E3%80%81Project%E8%A7%92%E8%89%B2%E3%80%81Slave%E8%A7%92%E8%89%B2%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%BB%99%E7%94%A8%E6%88%B7%E5%88%86%E9%85%8D%E8%BF%99%E4%BA%9B%E8%A7%92%E8%89%B2%E3%80%82%E8%BF%99%E6%AC%BE%E6%8F%92%E4%BB%B6%E6%98%AF%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84Jenkins%E6%9D%83%E9%99%90%E7%AD%96%E7%95%A5%E5%92%8C%E7%AE%A1%E7%90%86%E6%8F%92%E4%BB%B6%E3%80%82%EF%BF%BC">https://plugins.jenkins.io/role-strategy，这个插件提供了一种基于角色（Role）的用户权限管理策略，支持创建global角色、Project角色、Slave角色，以及给用户分配这些角色。这款插件是最常用的Jenkins权限策略和管理插件。<img src="https://b3logfile.com/file/2022/05/image-3fb00012.png" alt="image.png"></a></li></ol><h2 id="2-代码管理"><a href="#2-代码管理" class="headerlink" title="2 代码管理"></a><strong>2 代码管理</strong></h2><p>Jenkins 项目中配置Source Code Management 去下载代码进行构建任务，是非常普遍的应用场景。Jenkins插件支持很多SCM的系统，使用最常见的是Git 和SVN。</p><ul><li>l Git <a href="https://plugins.jenkins.io/git%EF%BC%8C%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8Github%E3%80%81GitLab%E3%80%81Gerrit%E7%AD%89%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E3%80%82">https://plugins.jenkins.io/git，支持使用Github、GitLab、Gerrit等系统管理代码仓库。</a></li><li>l Subversion <a href="https://plugins.jenkins.io/subversion%EF%BC%8C%E6%94%AF%E6%8C%81Subversion%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E6%BA%90%E4%BB%A3%E7%A0%81%E3%80%82">https://plugins.jenkins.io/subversion，支持Subversion系统管理源代码。</a></li></ul><h2 id="3-项目及视图"><a href="#3-项目及视图" class="headerlink" title="3 项目及视图"></a><strong>3 项目及视图</strong></h2><p>Jenkins中对Project 和 view的管理，是用户日常工作中使用很多的功能。</p><ul><li>l Folder <a href="https://plugins.jenkins.io/cloudbees-folder%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%8F%92%E4%BB%B6%E6%94%AF%E6%8C%81%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%EF%BC%8C%E7%9B%AE%E5%BD%95%E6%94%AF%E6%8C%81%E5%B5%8C%E5%A5%97%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%94%AF%E6%8C%81%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE%E3%80%82">https://plugins.jenkins.io/cloudbees-folder，这个插件支持用户使用目录管理项目，目录支持嵌套，并且支持目录中创建视图。</a></li><li>l Build Pipeline <a href="https://plugins.jenkins.io/build-pipeline-plugin%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%8F%92%E4%BB%B6%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E7%A7%8DBuild">https://plugins.jenkins.io/build-pipeline-plugin，这个插件提供了一种Build</a> Pipeline 视图，用于显示上、下游项目构建的关系。（存在XSS漏洞没安装）</li></ul><h2 id="4-构建触发"><a href="#4-构建触发" class="headerlink" title="4 构建触发"></a><strong>4 构建触发</strong></h2><p>Jenkins支持多种Build 触发方式，尤其一些<a href="http://www.ttlsa.com/auto/">自动化</a>触发方式非常有用</p><ul><li>l GitLab <a href="https://plugins.jenkins.io/gitlab-plugin%EF%BC%8C">https://plugins.jenkins.io/gitlab-plugin，</a> 这个插件将Jenkins 集成到GitLab web hook中，支持Gitlab 分支及Merge Request等相关事件触发Jenkins构建。</li><li>l GitHub Integration <a href="https://plugins.jenkins.io/github-pullrequest">https://plugins.jenkins.io/github-pullrequest</a> ，这个插件将Jenkins集成到GitHub中，支持Gitgub分支及Pull requests 触发Jenkins 构建。</li><li>l Maven Integration。maven风格插件。</li></ul><h2 id="5-构建参数"><a href="#5-构建参数" class="headerlink" title="5 构建参数"></a><strong>5 构建参数</strong></h2><ol><li>Rebuilder：此插件可以直接重复上次构建，也可以用于查看一些参数比较复杂的构建时，上次构建所选的参数是什么。非常nice的一个插件。</li><li>Build With Parameters。为了实现参数化构建。</li><li>build-name-setter <a href="https://plugins.jenkins.io/build-name-setter%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%8F%92%E4%BB%B6%E6%94%AF%E6%8C%81%E8%AE%BE%E7%BD%AE%E6%9E%84%E5%BB%BA%E7%9A%84%E6%98%BE%E7%A4%BA%E5%90%8D%E5%AD%97%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E9%BB%98%E8%AE%A4%E7%9A%84%E4%B8%BA#1%EF%BC%8C#2%EF%BC%8C%E2%80%A6%E2%80%A6%EF%BC%8C#buildnum">https://plugins.jenkins.io/build-name-setter，这个插件支持设置构建的显示名字，而不是默认的为#1，#2，……，#buildnum</a></li><li>description setter <a href="https://plugins.jenkins.io/description-setter%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%8F%92%E4%BB%B6%E6%94%AF%E6%8C%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%9E%84%E5%BB%BAlog%E8%BE%93%E5%87%BA%EF%BC%8C%E8%AE%BE%E7%BD%AE%E6%9E%84%E5%BB%BA%E7%9A%84%E6%8F%8F%E8%BF%B0">https://plugins.jenkins.io/description-setter，这个插件支持正则表达式匹配构建log输出，设置构建的描述</a></li></ol><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6 其他"></a><strong>6 其他</strong></h2><ol><li>邮件插件,Email Extension</li><li>显示用户名 build user vars(还有其作用)</li><li>Git 扩展：git parameter</li><li>选项型参数：Active Choices Plugin</li><li>配置备份还有回滚功能，Job Configuration History Plugin</li><li>项目视图中看到构建人，Build Trigger Badge</li><li>构建后在当前窗口构建日志，Display Console Output Plugin</li><li>通过插件的方式提供更加丰富的构建版本号，Version Number</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h1><ul><li><a href="http://www.ttlsa.com/auto/jenkins-plugin-recommend/">Jenkins 高效插件推荐 – 运维生存时间 (</a><a href="http://ttlsa.com/">ttlsa.com</a><a href="http://www.ttlsa.com/auto/jenkins-plugin-recommend/">)</a></li><li><a href="https://www.cnblogs.com/iancloud/p/16045093.html">Jenkins常用插件汇总以及简单介绍原创 - ianCloud - 博客园 (</a><a href="http://cnblogs.com/">cnblogs.com</a><a href="https://www.cnblogs.com/iancloud/p/16045093.html">)</a></li><li><a href="https://zhuanlan.zhihu.com/p/378093468">Jenkins必备安装插件 - 知乎 (</a><a href="http://zhihu.com/">zhihu.com</a><a href="https://zhuanlan.zhihu.com/p/378093468">)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>devops_jenkins_03_多jdk和maven版本配置</title>
    <link href="/032.html"/>
    <url>/032.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: devops_jenkins_03_多jdk和maven版本配置 date: 2022-05-03 20:27:10.0 updated: 2022-05-05 23:32:10.973 url: &#x2F;archives&#x2F;jenkins03 categories:</p><ul><li>devops tags:</li><li>jenkins</li><li>devops</li><li>持续部署</li></ul><hr><h1 id="1-多jdk版本和maven设置"><a href="#1-多jdk版本和maven设置" class="headerlink" title="1 多jdk版本和maven设置"></a><strong>1 多jdk版本和maven设置</strong></h1><p>jenkins 系统管理-》全局工具配置-》jdk安装可以设置不同的jdk，因为jenkins可能会构建不同的项目，不同的项目依赖的jdk不同。maven也是同理</p><h2 id="1-1-先将下载好的jdk版本上传至服务器"><a href="#1-1-先将下载好的jdk版本上传至服务器" class="headerlink" title="1.1 先将下载好的jdk版本上传至服务器"></a><strong>1.1 先将下载好的jdk版本上传至服务器</strong></h2><p><img src="https://b3logfile.com/file/2022/05/image-35c399d1.png" alt="image.png"> 如上图，我们准备了jdk1.6、1.7、1.8的版本，maven采用apache maven 3.6.0版本。</p><h2 id="1-2-配置jdk"><a href="#1-2-配置jdk" class="headerlink" title="1.2 配置jdk"></a><strong>1.2 配置jdk</strong></h2><p>以1.8为例：如下图所示， <img src="https://b3logfile.com/file/2022/05/image-deb6f5ed.png" alt="image.png"> 同理，1.6，1.7就不截图了。</p><h2 id="1-3-配置maven同理"><a href="#1-3-配置maven同理" class="headerlink" title="1.3 配置maven同理"></a><strong>1.3 配置maven同理</strong></h2><p><img src="https://b3logfile.com/file/2022/05/image-6c8617cb.png" alt="image.png"> 保存即可。 接下来的我们讲一下，jenkins的常用插件安装。</p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>devops_jenkins_02_更换主题</title>
    <link href="/031.html"/>
    <url>/031.html</url>
    
    <content type="html"><![CDATA[<hr><p> </p><h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a><strong>更换主题</strong></h1><p>Jenkins 默认是不支持更换主题的，需要安装一个插件：<strong>Simple Theme</strong> 安装完成一起重启 Jenkins，然后在：<strong>[系统管理] –&gt; [系统设置]</strong> 会增加一个 <strong>Theme</strong> 项。 更换主题存在问题，暂时先停止</p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>devops_jenkins_01_安装与部署</title>
    <link href="/030.html"/>
    <url>/030.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: devops_jenkins_01_安装与部署 date: 2022-05-03 19:17:06.0 updated: 2022-05-05 23:32:44.057 url: &#x2F;archives&#x2F;jenkins01 categories:</p><ul><li>devops tags:</li><li>jenkins</li><li>devops</li><li>持续部署</li></ul><hr><h1 id="1-jenkins安装与部署"><a href="#1-jenkins安装与部署" class="headerlink" title="1 jenkins安装与部署"></a><strong>1 jenkins安装与部署</strong></h1><p>官网: <a href="https://jenkins.io/">https://jenkins.io/</a> 本次部署是在CentOS</p><h1 id="2-jdk安装"><a href="#2-jdk安装" class="headerlink" title="2 jdk安装"></a><strong>2 jdk安装</strong></h1><p>Jenkins 自身采用 Java 开发，所以要必须安装 JDK； 先检查是否安装了</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">java -<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p>没有安装直接yum安装 yum search java grep jdk yum install -y java-1.8.0-openjdk java -version <img src="https://b3logfile.com/file/2022/05/image-21ed30e9.png" alt="image.png"></p><h1 id="3-安装jenkins"><a href="#3-安装jenkins" class="headerlink" title="3 安装jenkins"></a><strong>3 安装jenkins</strong></h1><h2 id="3-1-在线安装jenkins"><a href="#3-1-在线安装jenkins" class="headerlink" title="3.1 在线安装jenkins"></a><strong>3.1 在线安装jenkins</strong></h2><p>sudo wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;jenkins.repo <a href="https://pkg.jenkins.io/redhat/jenkins.repo">https://pkg.jenkins.io/redhat/jenkins.repo</a> sudo rpm –import <a href="https://pkg.jenkins.io/redhat/jenkins.io.key">https://pkg.jenkins.io/redhat/jenkins.io.key</a> sudo yum -y install jenkins</p><h2 id="3-2-调整配置文件"><a href="#3-2-调整配置文件" class="headerlink" title="3.2 调整配置文件"></a><strong>3.2 调整配置文件</strong></h2><p>编辑vim &#x2F;etc&#x2F;sysconfig&#x2F;jenkins文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">JENKINS_USER=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-comment">## 原值 &quot;jenkins&quot; 必须修改，否则权限不足</span><br>JENKINS_PORT=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-comment">## 原值 &quot;8080&quot; 可以不修改</span><br><span class="hljs-comment">## 还有开启 HTTPS 相关参数，此处不打算开启，故不作说明</span><br></code></pre></td></tr></table></figure><p>安装目录: &#x2F;usr&#x2F;lib&#x2F;jenkins 工作目录: &#x2F;var&#x2F;lib&#x2F;jenkins(对应于环境变量 JENKINS_HOME)</p><h2 id="3-3-启动jenkins"><a href="#3-3-启动jenkins" class="headerlink" title="3.3 启动jenkins"></a><strong>3.3 启动jenkins</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> jenkins <span class="hljs-comment">#开机自启</span><br>systemctl restart jenkins <span class="hljs-comment">#重启jenkins</span><br></code></pre></td></tr></table></figure><h2 id="3-4-防火墙放行"><a href="#3-4-防火墙放行" class="headerlink" title="3.4 防火墙放行"></a><strong>3.4 防火墙放行</strong></h2><p>放开8080端口： firewall-cmd –zone&#x3D;public –add-port&#x3D;8080&#x2F;tcp –permanent 如果是腾讯云或者阿里云的服务器，需要去安全组开放端口。 到现在已经安装好了输入<a href="http://服务器ip:8080/">http:&#x2F;&#x2F;服务器ip:8080</a> 即可访问jenkins。如下图： <img src="https://b3logfile.com/file/2022/05/image-5d5f3ca1.png" alt="image.png"></p><h1 id="4-jenkins基本配置"><a href="#4-jenkins基本配置" class="headerlink" title="4 jenkins基本配置"></a><strong>4 jenkins基本配置</strong></h1><h2 id="4-1-登录并修改密码"><a href="#4-1-登录并修改密码" class="headerlink" title="4.1 登录并修改密码"></a><strong>4.1 登录并修改密码</strong></h2><p>按照要求 cat &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;secrets&#x2F;initialAdminPassword 将密码填入后，进入插件自定义页面，我们先跳过。 <img src="https://b3logfile.com/file/2022/05/image-8a239c06.png" alt="image.png">点击开始使用jenkins。 <img src="https://b3logfile.com/file/2022/05/image-01b93966.png" alt="image.png"> 修改登录密码：主界面右上角“注销”链接的左边的用户名下拉菜单中点“设置”。</p><h2 id="4-2-插件安装"><a href="#4-2-插件安装" class="headerlink" title="4.2 插件安装"></a><strong>4.2 插件安装</strong></h2><p>由于之前没有选择任何的插件，所以我们目前是英文界面，插件安装可以采用离线安装或者在线安装。</p><h3 id="4-2-1-离线安装"><a href="#4-2-1-离线安装" class="headerlink" title="4.2.1 离线安装"></a><strong>4.2.1 离线安装</strong></h3><p>主要是在线安装插件失败率高，需要翻墙。 手工下载(*.hpi): <a href="http://updates.jenkins-ci.org/download/plugins/">http://updates.jenkins-ci.org/download/plugins/</a> 进入：系统管理 &#x2F; 管理插件 &#x2F; 高级，然后上传插件进行安装。 无需重启 Jenkins 插件即生效。</p><h3 id="4-2-2-在线安装"><a href="#4-2-2-在线安装" class="headerlink" title="4.2.2 在线安装"></a><strong>4.2.2 在线安装</strong></h3><p><img src="https://b3logfile.com/file/2022/05/image-53288843.png" alt="image.png"> 中文插件请参考：<a href="https://blog.csdn.net/qq_37489565/article/details/104337073">(50条消息) Jenkins 中文设置_我是刘先生的博客-CSDN博客_jenkins 中文</a> 最终效果如下图： <img src="https://b3logfile.com/file/2022/05/image-f46849f0.png" alt="image.png"></p><h1 id="4-3-安全设置"><a href="#4-3-安全设置" class="headerlink" title="4.3 安全设置"></a><strong>4.3 安全设置</strong></h1><p>默认情况下，任何用户都可以使用 Jenkins 进行发布。 可以进入相关设置：系统管理 &#x2F; Configure Global Security, 选择 <strong>Jenkins专有用户数据库</strong>，不要选中** 允许用户注册**； 选择 <strong>登录用户可以做任何事</strong>，选中 <strong>匿名用户具有可读权限</strong> <img src="https://b3logfile.com/file/2022/05/image-3c1ba625.png" alt="image.png"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h1><ul><li><a href="https://blog.csdn.net/qq_37489565/article/details/104337073">(50条消息) Jenkins 中文设置_我是刘先生的博客-CSDN博客_jenkins 中文</a></li><li><a href="https://blog.csdn.net/kefengwang/article/details/54233584">(50条消息) Jenkins 持续集成综合实战_kefeng-wang的博客-CSDN博客_jenkins持续集成</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可信计算-供应链安全-FIM和RIM</title>
    <link href="/013.html"/>
    <url>/013.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 可信计算-供应链安全-FIM和RIM date: 2022-06-07 17:32:04.123 updated: 2022-06-07 17:58:10.735 url: &#x2F;archives&#x2F;kxjsgylaq categories:</p><ul><li>可信计算 tags:</li><li>可信计算</li></ul><hr><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h1><p>例如，终端计算机、台式机和笔记本电脑包含硬件、固件、驱动程序、操作终端和应用软件，它们影响着设备和它们所在网络的完整性和安全性。对于网络管理员来说，了解其网络中终端的当前状况可能是一项令人沮丧的工作。有多个问题在起作用。1）新部署的机器是否按照要求建立和配置？ 2）在这些机器的生命周期内，环境中的机器的持续状态是什么？PC客户端固件完整性测量规范（FIM）提供了一个框架，用于确定硬件的配置以及运行了哪些固件来初始化处于启动状态的端点。该规范与其他TCG规范结合使用，为企业环境中的平台验证提供了完整的解决方案，并构成了基于该验证的信任决策的基础。 终端计算机依靠平台OEM提供的和第三方提供的固件来初始化和启动到可用状态。固件存储在非易失性存储器中，可以使用平台OEM提供的工具进行更新。一些第三方提供的固件可以通过第三方提供的实用程序进行更新，例如，硬盘驱动器固件更新。根据TPM 2.0系统的TCG PC客户端平台固件配置文件[1]，在平台初始化和启动期间运行的固件被测量并存储在TPM中。这些测量结果为FIM提供了基础，但对于信任决策来说是一个不充分的基础。这些测量值告诉网络管理员，即验证者，当前正在运行什么。验证者还需要知道的是，什么是应该运行的。<strong>验证者如何将当前状态与所需状态联系起来？TCG参考完整性规范（RIM）[4]中规定的参考完整性测量是反映基线或黄金测量的一组测量，可以与之进行比较</strong>。 FIM和RIM反映了在终端计算机上运行的固件，但配置也会影响终端的完整性和安全性。核查员如何知道任何特定的端点是正确配置的？FIM和RIM中记录了终端计算机当前启用的功能和设备，但这只是验证人希望了解的终端计算机的一个子集。可以对设备进行哪些配置更改以改善安全状况？端点计算机有哪些固有的属性，使验证者能够更好地信任该端点？这些信息在FIM中是不可用的，所以必须从其他地方获取。<strong>TCG平台证书规范[3]中定义的平台证书可以捕获这些信息。</strong> 平台OEM可以为交付给验证者的终端提供一套RIM和平台证书，让验证者为该计算机建立一个基线。这套完整性和属性信息所促成的场景详见下文。</p><hr><p>FIM需要协调RTM和信任链来对终端进行测量，需要一个TPM来保护测量结果不被修改，直到它们可以被报告，还需要一个参考完整性清单（RIM）来与任何单个启动过程的测量结果进行比较。一个软件代理，Attestation Client，可以用来收集TPM的测量值和事件日志的记录。验证客户端收集的信息将至少包括事件日志、PCR报价结果，以及可能的用于签署报价的签名密钥的证书。在某些情况下，签名钥匙的证书可能作为端点注册过程的一部分提供。确保固件完整性的综合系统还将包括对所收集的测量结果进行某种形式的验证，相应地，验证者也是评估所报告的测量结果所必需的。这样的验证者通常驻扎在网络基础设施的外部。此外，如果测量、报告和&#x2F;或验证过程的任何组件可以被修改或更新，那么这些组件的可信度取决于用于实施更新的机制。平台固件的更新需要符合NIST SP800-147的规定。平台的平台证书提供了终端符合签名固件更新过程的断言。 RoT、信任链和代理的可信度和协调性使验证者有信心对测量的端点的固件完整性进行可靠的评估。 对复合端点提供的信任属性的评估至关重要，并且单个代理的信任属性的评估仅与整个系统的上下文相关。 图 2 详细说明了 RoT 必须协同行动，以实现 FIM 的可靠和值得信赖的测量、报告和验证。 此外，这些 RoT 必须组合在一个端点中，该端点包含安全平台固件更新机制以及其他安全功能。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654586244783.png" alt="image-1654586244783"> 有意义的完整性测量比较方案的一个关键因素<strong>是建立和维护一个已知的断言、配置和测量的基线，验证者可以据此做出决定</strong>。基准线的建立必须考虑两种情况：具有未知或可疑出处的平台固件的平台，以及具有已知和可信（受保护和签名）固件的平台。本节介绍了平台制造商提供的平台证书和RIM包中包含的必要和可选的断言、配置和测量。平台制造商向验证者提供的平台证书包括对终端TPM EK证书的明确引用以及用于获取RIM的GUID和URI。 一个例子是这样的：平台制造商根据制造的终端生成参考测量值，包括代码和配置，并产生一个RIM和一个平台证书。平台制造商将端点和平台证书交付给客户，客户可以在任何配置或固件改变之前对PCR进行快照。客户可以根据RIM验证快照，以验证在制造之后和收到终端之前没有进行过任何改变。客户还可以验证平台证书中的断言，并将其与快照中的配置进行比较。然后，客户可以进行任何固件和配置更改，询问PCR，并拍摄新的快照以建立他们的基线。这将产生一个反映客户基线的支持RIM，如TCG参考完整性清单规范[4]中所定义。 如果没有平台证书，平台制造商还有其他选择来提供RIM捆绑包。捆绑包可以在制造时安装在平台上，并在[6]中定义的位置。捆绑包可以通过客户支持渠道提供，如网站。捆绑包可以作为平台固件安装包的一部分。本规范没有为平台制造商提供RIM捆绑包的方式提供规范性指导。 在SP800-155中，完整性属性被用于评估固件完整性测量的可信度。平台制造商有各种方式向客户传达完整性属性。平台制造商可以通过带外渠道（即不与终端本身一起交付，而是通过其他方式）向客户提供平台证书中的这些信息。平台制造商可向客户提供一个工具，以查询端点并从已知位置提取平台证书。或者，平台制造商可以允许客户向管理的在线服务提供序列号，然后响应平台的平台证书，因为它已经交付。无论客户如何获得特定终端的平台证书，<strong>证书的目的是为客户提供一种手段，以评估终端报告的断言和测量的有效性，并对其收到的关于终端总体健康状态的报告形成一定程度的信任，而不仅仅是固件测量</strong>。 平台证书： 平台证书中应报告平台序列号。序列号可以是资产标签、服务标签或UID，但必须与平台证书中的其他信息相结合，在平台制造商的产品系列或型号中唯一地识别平台。 平台固件断言在平台证书配置文件第3.1节[3]中定义。这些断言作为tBBSecurityAssertions属性的一部分被捕获。根据TCG平台证书配置文件规范[3]的规定，这些断言（定义如下）应在平台证书中报告。下面的列表是最小的列表，并不打算限制平台制造商包括额外的断言。 MeasurementRootType、TCGPlatformSpecification、PlatformFwSignatureVerification等 平台证书规范[3]将 platformProperties 定义为平台证书规范[3]中定义的 platformConfiguration 属性的一个元素。平台OEM可以使用这个字段来填充验证者感兴趣的额外断言。这些断言应按照[3]中的定义，以名称、值对的形式进行填充。 平台证书规范[3]将ComponentIdentifier属性定义为一个可选的元素，用于在平台证书中加入相关的组件。表4详细地定义了PC客户端平台中的相关组件。平台制造商可以包括额外的组件。如果他们确实包括额外的组件，他们应该遵守下面规范1中定义的元素。组件类别（componentClass）的值在TCG组件类别注册表中定义，为了方便读者阅读，这里也包括了这些值。该属性的结构在《平台证书配置文件规范》第3.1.8节中定义，包含强制性和可选性元素。当有成熟的解决方案来报告和验证这个属性时，本节将成为强制性的。 <strong>PlatformConfigUri提供了验证者可以找到PC客户端RIM捆绑的位置</strong>。注意，这个字段不包含RIM捆绑物。正如《TCG PC 客户端参考完整性清单规范》[6]中所定义的，平台制造商可以将捆绑包放在 EFI 分区的端点上。如果放置在EFI分区中，建议在发生硬盘故障或磁盘重新分区的情况下，验证人需要RIM捆绑包时，可将其放置在EDI分区中。</p><h1 id="验证平台证书"><a href="#验证平台证书" class="headerlink" title="验证平台证书"></a><strong>验证平台证书</strong></h1><p>平台证书验证需要交付平台制造商的根证书，并将证书中的元素与可从平台获得的信息进行比较。证书中的一些元素提供了可以目视检查的信息，如制造商和型号或底盘类型。有些元素提供的信息可以通过与测量结果进行比较来验证，例如存在一个S-HCRTM，它将被捕获为PCR 0中的测量事件。 这套属性不能以编程方式验证，除非能力被启用。在这种情况下，它们可以通过PCR 1中的测量事件进行验证。如果平台证书包含组件信息，则该信息可能只能通过平台制造商提供的工具进行验证。</p><h1 id="RIM"><a href="#RIM" class="headerlink" title="RIM"></a><strong>RIM</strong></h1><p>TCG参考完整性清单（RIM）信息模型规范[4]为平台的一组参考测量值定义了一个信息模型。平台制造商为随平台发货的固件版本提供一个初级RIM。对于平台固件的后续版本，平台制造商提供补丁RIM。平台制造商提供的主RIM可以在EFS分区中与平台一起交付，如TCG PC客户端参考完整性清单（PCRIM）信息模型规范[6]中所定义。或者，主RIM可以通过带外方式交付，例如通过平台制造商的网站。补丁RIM可以作为固件更新工具的一部分交付，也可以通过同样的带外机制提供。</p><h1 id="Verifier"><a href="#Verifier" class="headerlink" title="Verifier"></a><strong>Verifier</strong></h1><p>验证者使用RIM的内容评估客户端的状态（作为验证者），RIM包含来自PCR值或平台制造商提供的事件日志的客户端信息。事件日志和PCR值是使用TAP[5]文件中规定的协议从客户端（即Attestor）传递的。如果使用事件日志，验证人首先使用相关的PCR值验证其完整性。验证者使用管理员提供的一套策略对证明者进行鉴定。</p><hr><h1 id="RIM-1"><a href="#RIM-1" class="headerlink" title="RIM"></a><strong>RIM</strong></h1><p>参考完整性清单包含验证者用来对照实际值（证据）验证预期值（断言）的结构。 一个RIM信息模型有几个特点。它。- 识别RIM实例的创建者（发行者）。- 确定产生参考值的供应链实体。- 包含可安装软件&#x2F;固件的参考测量值。- 包含嵌入式固件的参考测量值。- 识别组件、设备或环境。- 包含其自身的完整性保护能力（例如，数字签名验证）。- 对有助于确保语义互操作性和促进良好安全实践的RIM绑定规范设置约束。</p><h1 id="平台证书"><a href="#平台证书" class="headerlink" title="平台证书"></a><strong>平台证书</strong></h1><p>TCG平台证书档案规范[10]包含平台制造商做出的信任断言。该证书断言平台的安全属性和出厂时的配置。平台证书规范定义了一个PlatformConfigurationURI属性，其中包含 “验证人可以获得参考完整性测量值的URI”。平台证书规范的第3.1.7节讨论了PlatformConfigurationURI属性的选项。</p><h1 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a><strong>背景</strong></h1><p>TCG TPM 2.0供应指导文件[6]描述了一组参考测量值，”代表了启动固件和后续代码生成并扩展到TPM PCR的完整性测量值的预期默认值”。它进一步指出，”平台制造商应提供平台BIOS、固件和其他二进制文件的预期完整性测量值列表，他们提供的是’发货’。黄金测量值应包括在启动固件更新中，以支持特定终端平台的生命周期。” TCG基础设施工作组参考清单（RIMM）模式规范[7]，使用XML模式定义了一个信息模型和数据定义，提供了一套强大的数据项，可用于生成一套 “黄金测量”。此后，TCG接受了几项新技术，其格式和内容的灵活性选项能更好地满足参考测量的要求。本规范取代了RIMM规范。</p><h1 id="RIM-信息模型"><a href="#RIM-信息模型" class="headerlink" title="RIM 信息模型"></a><strong>RIM 信息模型</strong></h1><p>RIM信息模型由元素和相关属性的抽象表示组成，这些元素和属性形成一个清单，称为参考完整性清单（RIM）。该抽象表示通过应用RIM绑定规范实现为RIM实例，该规范定义了为散列、签名、传输和存储编码的元素和属性。RIMs包含关于平台状态或配置的断言。断言包含根据创建或制造平台或其硬件、固件或软件元素之一的实体（供应商、组织或个人）已知的正确值。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654589507285.png" alt="image-1654589507285"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><h1 id="1-FIM-Firmware-Integrity-Measurement-FIM"><a href="#1-FIM-Firmware-Integrity-Measurement-FIM" class="headerlink" title="1 FIM Firmware Integrity Measurement (FIM)"></a><strong>1 FIM Firmware Integrity Measurement (FIM)</strong></h1><p>PC客户端固件完整性测量（FIM）规范概述了收集、报告和处理（证明）PC客户端固件的基本流程。 FIM协调RTM等对终端进行测量，需要一个TPM来保护测量结果不被修改，直到它们可以被报告，并且使用一个参考完整性清单（RIM）来单个启动过程的测量结果进行比较。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654586244783.png" alt="image-1654586244783"> 一个例子是这样的：平台制造商根据制造的终端生成参考测量值，包括代码和配置，并产生一个RIM和一个平台证书。平台制造商将端点和平台证书交付给客户，客户可以在任何配置或固件改变之前对PCR进行快照。客户可以根据RIM验证快照，以验证在制造之后和收到终端之前没有进行过任何改变。客户还可以验证平台证书中的断言，并将其与快照中的配置进行比较。然后，客户可以进行任何固件和配置更改，询问PCR，并拍摄新的快照以建立他们的基线。这将产生一个反映客户基线的support RIM。 使用场景：</p><ol><li>验证客户收到的终端计算机是否与客户的订单相符： a. 客户下订单购买具有特定硬件和固件配置的计算机。 b. 平台 OEM 制造计算机，生成 RIM，并将计算机运送给客户。d. 客户收到计算机，收集FIM并与RIM进行比较。 e. 客户将当前的平台配置与RIM进行比较。 f. 利用从步骤d和e中确定的信息，客户确定平台已经交付，没有修改，并建立了一个基线。</li><li>验证一台终端计算机是否被正确配置以连接到网络。a. 管理员根据平台证书中描述的功能配置一台终端计算机以符合基线安全配置，并将该计算机交付给终端用户。 b. 终端用户启动终端并尝试连接到网络。d. 网络关守将FIM与RIM以及EK Cert所确定的该平台的平台证书进行比较，并决定该平台已正确配置。e. 端点计算机被允许访问网络。</li><li>对配置不正确的终端计算机进行隔离。a. 管理员将一台终端计算机配置为符合基线安全配置，并将计算机交付给终端用户。 b. 终端用户启动终端，通过关闭安全功能（如安全启动）来修改配置，并试图连接到网络。d. 网络关守将FIM与RIM和EK证书进行比较，确定安全配置已从基线修改。e. 端点计算机被隔离在网络之外，需要采取补救措施才能访问网络。</li></ol><h1 id="2-RIM-Reference-Integrity-Manifest-RIM"><a href="#2-RIM-Reference-Integrity-Manifest-RIM" class="headerlink" title="2 RIM Reference Integrity Manifest (RIM)"></a><strong>2 RIM Reference Integrity Manifest (RIM)</strong></h1><p>RIM信息模型由元素和相关属性的抽象表示组成，这些元素和属性形成的清单称为参考完整性清单（RIM）。 RIMs包含关于平台状态或配置的断言。断言包含根据创建或制造平台或其硬件、固件或软件元素之一的实体（供应商、组织或个人）已知的正确值。</p><blockquote><p>断言指的是参考值</p></blockquote><p>RIM可由平台制造商、经销商、IT人员等生成。可以通过平台证书的PlatformConfigurationURI字段获取RIM的位置。 包含Base RIM和support RIM。 base RIM结构： 如果playloadtype有三种、direct、indirect和hybrid，如果是indirect，那么payload将直接包含参考完整性测量，indirect就是Support RIM，需要支持RIM Binding 规范，hybrid就是两种结合。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654592024373.png" alt="image-1654592024373"> <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654592010288.png" alt="image-1654592010288"> <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654589507285.png" alt="image-1654589507285"></p><h1 id="3-为什么能保证供应链的完整性？"><a href="#3-为什么能保证供应链的完整性？" class="headerlink" title="3 为什么能保证供应链的完整性？"></a><strong>3 为什么能保证供应链的完整性？</strong></h1><p>因为RIMs的生命周期，他有平台制造商初始生成第一个RIM Bundle，后续平台可能经由系统集成商或增值经销商修改，例如添加操作系统等。于是会在第一个RIM Bundle后面添加补丁 Bundle。</p><blockquote><p>RIM生命周期从固件&#x2F;软件最初在平台上安装时开始，这通常由平台制造商执行。系统集成商、增值经销商或IT维护机构可能会提供软件&#x2F;固件更新，改变固件配置，或进行硬件更改，从而更新平台的RIM Bundles。</p></blockquote><p>RIM Bundles 集使用 Base RIM tagIds 提供后向链接，显示了 RIM Bundles集合的添加顺序。该序列描述了平台变化的演变。这种联系和顺序对验证者来说是有用的。 RIM不一定通过平台证书获取，也可以通过带外的方式获取，例如通过平台制造商的网站。补丁RIM可以作为固件更新工具的一部分交付，也可以通过同样的带外机制提供。</p>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FIM</tag>
      
      <tag>RIM</tag>
      
      <tag>供应链安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可信计算_密码学基础01_PKI、SSL、DAA、PCA</title>
    <link href="/014.html"/>
    <url>/014.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 可信计算_密码学基础01_PKI、SSL、DAA、PCA date: 2022-05-27 11:07:53.887 updated: 2022-05-27 11:48:54.449 url: &#x2F;archives&#x2F;可信计算密码学基础01pkissldaapca categories:</p><ul><li>可信计算 tags:</li><li>可信计算</li><li>密码学</li></ul><hr><h1 id="1-PKI"><a href="#1-PKI" class="headerlink" title="1 PKI"></a><strong>1 PKI</strong></h1><h2 id="1-1-PKI概念"><a href="#1-1-PKI概念" class="headerlink" title="1.1 PKI概念"></a><strong>1.1 PKI概念</strong></h2><p>PKI技术是利用公钥密码体系实现的一个标准的安全基础设施，作为一种提供安全服务的基础性平台，它主要提供应用层级别的安全服务，向网络实体提供所必须的安全服务。 PKI技术主要通过为网络空间中各个主体提供安全保障以解决网络中的信任问题。 它通过数字证书为用户提供数字签名、身份认证等具体的安全服务，来确立用户身份的 唯一性和真实性，PKI技术提供的基本服务有： <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653619477726.png" alt="image-1653619477726"></p><ol><li>身份认证服务：即身份认证与识别。PKI技术实现身份认证主要是检查由双方共同信任的CA颁发的数字证书的真实性以及是否过期。</li><li>数据的完整性和不可否认性：PKI技术通过数字签名技术保证信息在传递过程中没有被篡改过。而不可否认性是指从技术上确保用户认可所做的网络通信行为，确保数据有源可查，不能抵赖。</li><li>机密性：PKI技术通过对数据加密确保除密钥拥有者以外的其他任何实体不能理解出数据的具体信息。</li></ol><p>一个完整的PKI系统主要包括认证中心(Certificate Authority，CA)、注册中心 (Registration Authority，RA)、数字证书库、证书撤销等功能模块组成。</p><ol><li>认证中心CA：是PKI中具有权威性、公正性的第三方信任机构，CA是PKI技术中最重要的部分。它的主要作用是确认用户身份信息与相应的数字证书信息相对应，通过为经过验证的用户颁发的相应的数字证书来实现。</li><li>注册中心RA：RA主要负责证书申请者的信息录入、审核等工作，在对用户信息鉴别的基础上决定是否同意CA颁发数字证书给申请者。</li><li>证书发布库：证书发布库是存放CA所颁发和撤销的证书的数据库。</li><li>证书撤销：通过证书撤销列表CRL(CertificateRevocationList)确认证书是否撤销</li></ol><h2 id="1-2-X-509数字证书"><a href="#1-2-X-509数字证书" class="headerlink" title="1.2 X.509数字证书"></a><strong>1.2 X.509数字证书</strong></h2><p>PKI技术的重要基础之一是X.509数字证书，它通过把公钥和它的所有者的身份标识信息相互绑定保证用户身份的真实性，以此确保公钥信息的完整性和不被篡改，保证用户传送信息的安全性。是用户与认证中心建立信任关系的基础，也是PKI的关键技术之一。 X.509数字证书由可信第三方认证机构CA签发。通过CA对用户身份信息和公钥进行签名，以此保证证书的有效性。PKI技术的一切活动都是围绕X.509数字证书的应用展开的，数据机密性、身份认证、数据完整性等PKI所提供的全部安全服务功能都需要X.509数字证书完成。图6列出了X.509数字证书的结构。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653619688508.png" alt="image-1653619688508"> X.509数字证书的签名和认证过程：</p><ol><li>CA签名证书 在X.509证书格式中，最后一个字段代表认证机构CA对证书进行的数字签名，CA向申请用户颁发证书前，需要使用MD5或SHA-1对颁发证书的所有内容进行哈希运算得到一个消息摘要。然后CA使用私钥加密这个消息摘要，形成最终的数字签名。最后CA将加密后的消息摘要插入X.509证书的最后一个字段，这样CA就完成了对X.509证书的签名。签名过程如图8所示。</li><li>X.509数字证书认证 X.509数字证书的认证过程如下：<ol><li>认证者使用单向散列函数对证书中除了签名以外的所有字段进行哈希运算获得一个消息摘要M1。其中单向散列函数与CA签发证书时所用的算法一样，具体由签发证书中的相应字段确定；</li><li>认证者从证书相应字段获取CA的数字签名；</li><li>认证者用CA的公钥对证书解密证书中的数字签名，获得CA对证书字段进行散列所得的到消息摘要M2；</li><li>认证者比较消息摘要M1和M2，看两条摘要是否相等，如果两条消息摘要相等，即M1&#x3D;M2，那么可确定X.509证书由认证机构CA颁发并签名，否则便不能信任此证书，拒绝其提出的访问请求。</li></ol></li></ol><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653619819887.png" alt="image-1653619819887"></p><h1 id="2-SSL协议"><a href="#2-SSL协议" class="headerlink" title="2 SSL协议"></a><strong>2 SSL协议</strong></h1><h2 id="2-1-SSL协议概述"><a href="#2-1-SSL协议概述" class="headerlink" title="2.1 SSL协议概述"></a><strong>2.1 SSL协议概述</strong></h2><p>SSL协议是在传输层上为网络通信提供安全及数据完整性的一种安全协议，用于在平台之间建立了透明的连接通道，几乎所有支持TCP的协议都可以使用SSL提供的安全服务，因此SSL协议得到了广泛应用。它主要通过非对称密钥体系进行通信双方的身份认证，在通过认证后交换对称密钥作为通信密钥，然后采用通信密钥加密传输数据。SSL具体由SSL握手协议、修改密码协议、SSL记录协议以及警告协议组成（图8）。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653619869988.png" alt="image-1653619869988"></p><h2 id="2-2-SSL双向认证"><a href="#2-2-SSL双向认证" class="headerlink" title="2.2 SSL双向认证"></a><strong>2.2 SSL双向认证</strong></h2><p>SSL握手协议根据不同需要分为单向认证和双向认证[33]。一般SSL双向认证主要完成服务器与服务器之间的认证，当两个服务器端使用SSL协议进行通信时，需要先进行SSL双向认证然后再进行通信。SSL双向认证主要完成SSL初始化信息如版本号协商、摘要算法、加密密钥、加密算法等，同时完成对通信双方的身份认证。SSL双向认证的流程如图9所示：</p><ol><li>服务器A给服务器B发送一个连接请求。</li><li>服务器B把X.509证书和同证书的相关信息发到服务器A。</li><li>服务器A将由服务器B发送过来的X.509证书进行检查，检查此证书的签发机构是否是所信赖的CA中心。如果是，对之前的协议继续进行执行操作；如果不是，向客户发送警告消息：即警告客户当前证书并非是可以信赖的，同时向客户发送询问请求，判断是否需要继续操作行为。之后服务器A对证书中的消息与服务器B刚刚发送的相关消息进行比较处理，判断其是否一致，如果一致，对服务器的合法身份进行认可。</li><li>服务器A完成对服务器B的认证。并发送自己的X.509证书到服务器B</li><li>服务器B收到证书后后，对证书进行验证处理，若验证失败，对连接请求进行拒绝处理；若验证成功，服务器B得到服务器A的公钥。</li><li>服务器B完成对服务器A的认证。</li><li>服务器A和服务器B进行会话密码协商。具体流程是首先服务器A将所能支持的密码方案告知于服务器B，然后针对服务器A发送过来的方案，服务器B从中选择一种加密程度最高的方案，用服务器A的公钥进行加密处理，之后发送到服务器A。针对这个密码方案，服务器A生成一个会话密钥，接着用来自于服务器B的公钥同样进行加密处理，之后发送给对方。B接收到消息，用自己的私钥解密，获得会话密钥。</li><li>服务器A和B完成两个平台之间的双向认证，接下来的会话都是用对称密码进行通讯。</li></ol><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653619971132.png" alt="image-1653619971132"></p><h1 id="3-DAA"><a href="#3-DAA" class="headerlink" title="3 DAA"></a><strong>3 DAA</strong></h1><p>可信计算作为一种新的计算机体系结构，远程证明是它的重要功能之一。远程证明就是通过两个网络平台在通信前由经典的“挑战一应答”协议实现来判断对方平台的身份和可信状态。杜芸芸对云计算环境下的远程证明安全进行了研究。杨力基于可信计算提出一种改进的移动计算平台直接匿名证明方案。目前实现远程证明的方案包括TPM1.1提出的Privacy CA方案(Privacy Certification Authority)和TPM1.2提出的直接匿名证明DAA方案。 每个TPM都包含一对背书密钥EK作为平台唯一标识符，通常为保护EK不被泄露，由TPM生成一对AIK公钥，由AIK公钥完成平台身份的认证。Privacy CA认证方案就是TPM在每次证明时，在产生身份密钥AIK后，使用第三方机构Privacy CA对AIK公钥进行签名。在证明时TPM需要将由AIK签名的PCR值和接收到的Privacy CA对AIK的签名发送给验证者，由验证者根据签名值对判断身份及是否可信进行判断。基于Privacy CA的证明方案不足之处一是Privacy CA身份的安全性问题，当CA与Verifier串通时，会暴露Attestor的行为；二是由于每次证明时TPM都需要向Privacy CA申请证书，使Privacy CA成为中心环节，Privacy CA的性能决定了方案的效率，从而不适合大规模应用和部署。 而DAA直接匿名认证协议很好的弥补了前面提到的Privacy CA认证方案存在的不足，DAA直接匿名认证协议如图11所示。 DAA认证包含4个实体：TPM，Attestor，DAA Issuer，Verifier。其中Attestor是一个包含TPM的平台。DAA认证协议根据计算的安全性，将对安全性高的计算提交给TPM计算，而Attestor主机完成不需要安全的计算，在保证安全的同时提高了DAA认证协议的效率。 DAA认证协议由DAA Join和DAA Sign两个子协议组成。其中DAA Join协议是指DAA ISSUER通过验证TPM平台为符合要求的TPM平台颁发DAA证书，其中DAA证书主要用于平台身份证明；而DAA Sign协议就是TPM通过使用ISSUER颁发的DAA证书向Verifier证明自身的过程。在证明的过程中，Verifier根据零知识证明思想在不泄露TPM隐私的条件下实现了DAA证书的验证，完成了对平台身份的认证。 其过程分为三步：</p><ol><li>TPM由密钥生成器生成一对AIK公私钥对，然后由EK向DAA发布者ISSUER提供平台身份的合法信息。</li><li>DAA ISSUER对EK提供的平台信息进行验证，如果通过，DAA ISSUER将验证的一个DAA证书传送给TPM。被验证者接下来就通过使用这个证书签名相关消息。如图10中第(3)步。</li></ol><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1653620100178.png" alt="image-1653620100178"></p><ol start="3"><li>DAA Sign协议是Verifier验证Attestor合法性的协议，是在TPM与Verifier之间进 行，Verifier主要是验证Attestor中TPM颁发的AIK。其中AIK由TPM生成，并用从DAA ISSUER获得的DAA证书的签名发送到Verifier。</li></ol><p>DAA匿名认证的优点如下:</p><ol><li>DAA签署方不能把AIK的签署和EK联系在一起，同时两个DAA签名不能够区分是否来自同一TPM，DAA验证者和发布者不能对Attestor的行为进行跟踪，解决了Privacy CA方案的缺点。</li><li>DAA证书只需要TPM平台向ISSUER申请一次，而不像Privacy CA方案一样，每次证明都需要申请证书。解决了Privacy CA中出现的瓶颈问题。</li><li>在TPM获得ISSUER颁发的DAA证书后，可生成多个AIK公私钥对并由DAA证书签名，使证书得到了扩展。</li></ol><h1 id="关于DAA"><a href="#关于DAA" class="headerlink" title="关于DAA"></a><strong>关于DAA</strong></h1><p>DAA是可信计算组织TCG提出的解决Privacy CA可能会泄露信息的一种零知识证明方案。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h1><blockquote><p>原文是下列文章中的第二章相关内容。</p></blockquote><ul><li>江丽军. 基于TPM的可信DAA认证模型的研究[D]. 河北:河北大学,2015. DOI:10.7666&#x2F;d.D723749.</li></ul>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DAA</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可信计算_Qemu04 采用virsh创建Qemu/KVM虚拟机</title>
    <link href="/018.html"/>
    <url>/018.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 可信计算_Qemu04 采用virsh创建Qemu&#x2F;KVM虚拟机 date: 2022-07-11 18:38:10.702 updated: 2022-07-12 10:56:22.719 url: &#x2F;archives&#x2F;可信计算qemu04采用virsh创建qemukvm虚拟机 categories:</p><ul><li>可信计算 tags:</li><li>可信计算</li><li>KVM</li></ul><hr><h3 id="1-libvirt、virsh、virt-manager"><a href="#1-libvirt、virsh、virt-manager" class="headerlink" title="1. libvirt、virsh、virt-manager"></a><strong>1. libvirt、virsh、virt-manager</strong></h3><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657535804199.png" alt="image-1657535804199"></p><ul><li>其中，libvirt是提供了一个方便的方式来管理虚拟机和其他虚拟化功能的软件的集合，如存储和网络接口管理。这些软件包括一个API库，一个守护进程（Libvirtd），和一个命令行实用程序（virsh）。</li><li>libvirt的首要目标是能够管理多个不同的虚拟化供应商&#x2F;虚拟机管理程序提供一个单一的方式。例如，命令“virsh列表等等都可以用于任何支持现有的虚拟机管理程序列表（KVM、Xen、VMware ESX，等）不需要学习管理程序特定的工具！</li><li>而virsh是命令行工具，virt-manager是GUI，带有图形界面的工具。但他们都是通过libvirt提供的接口，来进行虚拟机管理的一些操作。</li></ul><p>virt-manager是一个面向桌面的虚拟机管理工具，通过libvirt来进行虚拟机的管理。主要用于管理KVM，也可以管理Xen和LXC（linux containers）。 Virt-manager提供了一个窗口界面用于查看运行的虚拟机（zai libvirt配置文件中，称为domain），虚拟机的性能和资源使用情况。提供了向导用来创建新虚拟机，配置、修改虚拟机的资源分配和虚拟硬件设备。一个内置的VNC 和 SPICE 客户端提供连到虚拟机的图形接口。 virt-manager还提供了命令行的支持性工具：参照官网：<a href="https://virt-manager.org/">https://virt-manager.org/</a></p><ol><li>virt-install 命令行工具，用于部署虚拟机。(安装了virt-install之后virt-clone和virt-xml就已经安装了。)</li><li>virt-viewer 轻量的UI接口，VNC和SPICE协议都支持，使用libvirt来查看图形链接信息。</li><li>virt-clone命令行工具，用于克隆已经存在的（关机状态）的主机。拷贝当前磁盘镜像，定义配置文件、名字、UUID、MAC地址到新磁盘镜像。</li><li>virt-xml命令行工具，用于编辑domain XML。（libvirt使用XML文件定义虚拟机domain）</li><li>virt-convert命令行工具，用户转换OVF和VMX 虚拟机配置以支持使用libvirt运行。</li><li>virt-bootstrap 命令行工具，用于为基于libvirt的container设置root file system。</li></ol><blockquote><p>以上工具需要单独安装 Centos 安装virt-install：<code>yum install virt-install -y</code> 之前我们已经使用过了virt-manger，所以我们就不采用virt-manager了，这次我们使用virsh来进行创建虚拟机，virsh是需要定义xml文件来进行虚拟机相关操作的，我们可以利用virt-install来进行安装虚拟机。</p></blockquote><h3 id="3-virsh常用命令"><a href="#3-virsh常用命令" class="headerlink" title="3 virsh常用命令"></a><strong>3 virsh常用命令</strong></h3><p>virsh常用命令：</p><ul><li>virsh start x                   启动名字为x的非活动虚拟机</li><li>virsh list  –all                 列出虚拟机</li><li>virsh create x.xml           创建虚拟机（创建后，虚拟机立即执行，成为活动主机）</li><li>virsh suspend x              暂停虚拟机</li><li>virsh resume x               启动暂停的虚拟机</li><li>virsh shutdown x           正常关闭虚拟机</li><li>virsh destroy x               强制关闭虚拟机</li><li>virsh undefine x          删除虚拟机</li><li>virsh dominfo x                 显示虚拟机的基本信息</li><li>virsh domname 2               显示id号为2的虚拟机名</li><li>virsh domid x                    显示虚拟机id号</li><li>virsh domuuid x                 显示虚拟机的uuid</li><li>virsh domstate x                显示虚拟机的当前状态</li><li>virsh dumpxml x                 显示虚拟机的当前配置文件（可能和定义虚拟机时的配置不同，因为当虚拟机启动时，需要给虚拟机分配id号、uuid、vnc端口号等等）</li><li>virsh setmem x 512000       给不活动虚拟机设置内存大小</li><li>virsh edit x                        编辑配置文件（一般是在刚定义完虚拟机之后）</li></ul><h3 id="2-安装虚拟机"><a href="#2-安装虚拟机" class="headerlink" title="2 安装虚拟机"></a><strong>2 安装虚拟机</strong></h3><p>同样的创建磁盘： <code>qemu-img create -f qcow2 centos7-02.qcow2 10G</code> 使用virt-install安装虚拟机</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">virt</span>-install -n centos7-<span class="hljs-number">02</span> -r <span class="hljs-number">2048</span> --vcpu=<span class="hljs-number">2</span> --disk path=centos7-<span class="hljs-number">02</span>.qcow2 --cdrom CentOS-<span class="hljs-number">7</span>-x86_64-DVD-<span class="hljs-number">2009</span>.iso<br></code></pre></td></tr></table></figure><ul><li>-n –name　指定虚拟机名称</li><li>-r –ram　指定虚拟机内存</li><li>--vcpu　指定虚拟CPU个数</li><li>--disk　指定磁盘文件</li><li>--cdrom　指定通过iso镜像文件启动</li></ul><p>报错：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">[root@centos7 devsdb]# virt-install -n centos7<span class="hljs-string">-02</span> -r 2048 --vcpu=2 --disk path=centos7<span class="hljs-string">-02</span>.qcow2 --cdrom CentOS<span class="hljs-string">-7</span>-x86_64-DVD<span class="hljs-string">-2009</span>.iso<br>WARNING  No operating system detected, VM performance may suffer. Specify an OS with --os-variant for optimal results.<br><br>Starting install...<br><span class="hljs-keyword">ERROR    </span>不支持的配置：vmport is not available with this QEMU binary<br>Domain installation does not appear to have been successful.<br>If it was, you can restart your domain by running:<br>  virsh --connect qemu:///system start centos7<span class="hljs-string">-02</span><br>otherwise, please restart your installation.<br><br></code></pre></td></tr></table></figure><p>应该是Qemu版本与libvirt版本不兼容导致的，我的qemu版本是7.0.0 ，我们通过命令查看libvirt的版本：<code>virsh version</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">root</span>@<span class="hljs-type">centos7</span> <span class="hljs-type">devsdb</span>]<span class="hljs-comment"># virsh version</span><br>Compiled against library: libvirt <span class="hljs-number">4.5</span>.<span class="hljs-number">0</span><br><span class="hljs-keyword">Using</span> library: libvirt 4.5.0<br><span class="hljs-keyword">Using</span> API: QEMU 4.5.0<br>Running hypervisor: QEMU <span class="hljs-number">7.0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到它使用的Qemu 4.5.0的API，而我们使用的是Qemu7.0.0版本的，所以出现以上问题。 需要降低Qemu版本，因为我们尝试升级libvirt失败：<code>yum update libvirtd</code> 显示：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata">[root@centos7 devsdb]# yum <span class="hljs-keyword">update</span> libvirtd<br>Loaded plugins: fastestmirror<br>Loading mirror speeds from cached hostfile<br><span class="hljs-comment"> * base: mirrors.njupt.edu.cn</span><br><span class="hljs-comment"> * extras: mirrors.cqu.edu.cn</span><br><span class="hljs-comment"> * updates: mirrors.cqu.edu.cn</span><br>qemu-firmware-jenkins                                                                                                                                                   3.0 kB  00:00:00<br><span class="hljs-keyword">No</span> Match <span class="hljs-keyword">for</span> argument: libvirtd<br><span class="hljs-keyword">No</span> package libvirtd available.<br><span class="hljs-keyword">No</span> packages marked <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><p>在安装的过程中，忘记记录了，他报了一些错误，我们换了一台机器，安装命令如下：</p><ol><li><p>先配置网卡连接：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">virsh iface-<span class="hljs-keyword">bridge </span>eth0 <span class="hljs-keyword">br0 </span><span class="hljs-comment">#eth0根据自己的机器修改</span><br></code></pre></td></tr></table></figure></li><li><p>安装命令：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">virt-install <span class="hljs-params">--connect</span>  qemu:<span class="hljs-string">///system</span> <span class="hljs-params">--virt-type</span> kvm <span class="hljs-params">--name</span> rhel6 <span class="hljs-params">--ram=1024</span>  <span class="hljs-params">--disk</span> path=<span class="hljs-string">/root/centos7-02.qcow2</span> <span class="hljs-params">--os-variant=centos7</span>.0 <span class="hljs-params">--accelerate</span> -c CentOS-7-x86_64-DVD-2009.iso <span class="hljs-params">--network</span> bridge=br0,model=virtio <span class="hljs-params">--vnc</span>  <span class="hljs-params">--vncport=5991</span> <span class="hljs-params">--vnclisten=0</span>.0.0.0 <span class="hljs-params">--force</span><br></code></pre></td></tr></table></figure></li></ol><p>需要安装vncserver，这个我们之前也介绍过，还需要修改libvirtd中qemu的权限，<code>/etc/libvirt/qemu.conf</code> ，之前也介绍过。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657589901677.png" alt="image-1657589901677">可以看到，已经安装好机器，只是弹出来的virt-view是乱码，解决一下。 解决方法:<a href="https://www.landery.cn/archives/bao-cuo-ji-lu-virt-view-he-vncviewer-xian-shi-fang-kuai-luan-ma-deng-wen-ti">https://www.landery.cn/archives/bao-cuo-ji-lu-virt-view-he-vncviewer-xian-shi-fang-kuai-luan-ma-deng-wen-ti</a></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">[root@centos7 ~]# virsh list --all<br><span class="hljs-section"> Id    Name                           State</span><br><span class="hljs-section">----------------------------------------------------</span><br><span class="hljs-code"> -     rhel6                          shut off</span><br><br>[root@centos7 ~]# virsh start rhel6<br>Domain rhel6 started<br><br>[root@centos7 ~]# virsh list --all<br><span class="hljs-section"> Id    Name                           State</span><br><span class="hljs-section">----------------------------------------------------</span><br><span class="hljs-code"> 5     rhel6                          running</span><br><br>[root@centos7 ~]# virt-viewer rhel6<br></code></pre></td></tr></table></figure><p>结果如下：启动成功。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657594009696.png" alt="image-1657594009696"></p><h3 id="导出xml文件"><a href="#导出xml文件" class="headerlink" title="导出xml文件"></a><strong>导出xml文件</strong></h3><p><code>virsh dumpxml rhel6 &gt; rhel6.xml</code> 查看生成的文件rhel6.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">domain</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;kvm&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>rhel6<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">uuid</span>&gt;</span>968cdfe5-eee2-44db-a3ce-9a9782dc3075<span class="hljs-tag">&lt;/<span class="hljs-name">uuid</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">memory</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">&#x27;KiB&#x27;</span>&gt;</span>1048576<span class="hljs-tag">&lt;/<span class="hljs-name">memory</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">currentMemory</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">&#x27;KiB&#x27;</span>&gt;</span>1048576<span class="hljs-tag">&lt;/<span class="hljs-name">currentMemory</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">vcpu</span> <span class="hljs-attr">placement</span>=<span class="hljs-string">&#x27;static&#x27;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">vcpu</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">os</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span> <span class="hljs-attr">arch</span>=<span class="hljs-string">&#x27;x86_64&#x27;</span> <span class="hljs-attr">machine</span>=<span class="hljs-string">&#x27;pc-i440fx-rhel7.0.0&#x27;</span>&gt;</span>hvm<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">boot</span> <span class="hljs-attr">dev</span>=<span class="hljs-string">&#x27;hd&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">os</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">features</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">acpi</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">apic</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">features</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cpu</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&#x27;custom&#x27;</span> <span class="hljs-attr">match</span>=<span class="hljs-string">&#x27;exact&#x27;</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&#x27;partial&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#x27;allow&#x27;</span>&gt;</span>Broadwell-noTSX-IBRS<span class="hljs-tag">&lt;/<span class="hljs-name">model</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">feature</span> <span class="hljs-attr">policy</span>=<span class="hljs-string">&#x27;require&#x27;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;md-clear&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">feature</span> <span class="hljs-attr">policy</span>=<span class="hljs-string">&#x27;require&#x27;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;spec-ctrl&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">feature</span> <span class="hljs-attr">policy</span>=<span class="hljs-string">&#x27;require&#x27;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;ssbd&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">cpu</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">clock</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">&#x27;utc&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">timer</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;rtc&#x27;</span> <span class="hljs-attr">tickpolicy</span>=<span class="hljs-string">&#x27;catchup&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">timer</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;pit&#x27;</span> <span class="hljs-attr">tickpolicy</span>=<span class="hljs-string">&#x27;delay&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">timer</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;hpet&#x27;</span> <span class="hljs-attr">present</span>=<span class="hljs-string">&#x27;no&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">clock</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">on_poweroff</span>&gt;</span>destroy<span class="hljs-tag">&lt;/<span class="hljs-name">on_poweroff</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">on_reboot</span>&gt;</span>restart<span class="hljs-tag">&lt;/<span class="hljs-name">on_reboot</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">on_crash</span>&gt;</span>destroy<span class="hljs-tag">&lt;/<span class="hljs-name">on_crash</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pm</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">suspend-to-mem</span> <span class="hljs-attr">enabled</span>=<span class="hljs-string">&#x27;no&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">suspend-to-disk</span> <span class="hljs-attr">enabled</span>=<span class="hljs-string">&#x27;no&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pm</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">devices</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">emulator</span>&gt;</span>/usr/libexec/qemu-kvm<span class="hljs-tag">&lt;/<span class="hljs-name">emulator</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">disk</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;file&#x27;</span> <span class="hljs-attr">device</span>=<span class="hljs-string">&#x27;disk&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">driver</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;qemu&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;qcow2&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&#x27;/root/centos7-02.qcow2&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">dev</span>=<span class="hljs-string">&#x27;vda&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;virtio&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x06&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">disk</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">disk</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;file&#x27;</span> <span class="hljs-attr">device</span>=<span class="hljs-string">&#x27;cdrom&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">driver</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;qemu&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;raw&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">dev</span>=<span class="hljs-string">&#x27;hda&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;ide&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">readonly</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;drive&#x27;</span> <span class="hljs-attr">controller</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">&#x27;0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">disk</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;usb&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;ich9-ehci1&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x04&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x7&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;usb&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;ich9-uhci1&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">master</span> <span class="hljs-attr">startport</span>=<span class="hljs-string">&#x27;0&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x04&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span> <span class="hljs-attr">multifunction</span>=<span class="hljs-string">&#x27;on&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;usb&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;ich9-uhci2&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">master</span> <span class="hljs-attr">startport</span>=<span class="hljs-string">&#x27;2&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x04&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x1&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;usb&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;ich9-uhci3&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">master</span> <span class="hljs-attr">startport</span>=<span class="hljs-string">&#x27;4&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x04&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x2&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;pci-root&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;ide&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;0&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x01&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x1&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">controller</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;virtio-serial&#x27;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;0&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x05&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">controller</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">interface</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;bridge&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">mac</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&#x27;52:54:00:91:eb:fb&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">bridge</span>=<span class="hljs-string">&#x27;br0&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;virtio&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x03&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">interface</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">serial</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pty&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;isa-serial&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;0&#x27;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;isa-serial&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">serial</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">console</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pty&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;serial&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">console</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">channel</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;unix&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;virtio&#x27;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;org.qemu.guest_agent.0&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;virtio-serial&#x27;</span> <span class="hljs-attr">controller</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;1&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">channel</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;tablet&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;usb&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;usb&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;1&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;mouse&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;ps2&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;keyboard&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;ps2&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">graphics</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;vnc&#x27;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&#x27;5991&#x27;</span> <span class="hljs-attr">autoport</span>=<span class="hljs-string">&#x27;no&#x27;</span> <span class="hljs-attr">listen</span>=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">listen</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;address&#x27;</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">graphics</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;cirrus&#x27;</span> <span class="hljs-attr">vram</span>=<span class="hljs-string">&#x27;16384&#x27;</span> <span class="hljs-attr">heads</span>=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-attr">primary</span>=<span class="hljs-string">&#x27;yes&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x02&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">memballoon</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;virtio&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x07&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">memballoon</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rng</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;virtio&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">backend</span> <span class="hljs-attr">model</span>=<span class="hljs-string">&#x27;random&#x27;</span>&gt;</span>/dev/urandom<span class="hljs-tag">&lt;/<span class="hljs-name">backend</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;pci&#x27;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&#x27;0x0000&#x27;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&#x27;0x00&#x27;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;0x08&#x27;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&#x27;0x0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">rng</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">devices</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">domain</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>virsh可以通过这种xml文件定义、创建虚拟机，命令<code>virsh define x.xml</code> 和 <code>virsh create x.xml</code>。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h3><ul><li><a href="http://t.zoukankan.com/BurnovBlog-p-10875747.html">http://t.zoukankan.com/BurnovBlog-p-10875747.html</a></li><li><a href="https://blog.51cto.com/u_1364952/1964774">https://blog.51cto.com/u_1364952&#x2F;1964774</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可信计算_Qemu03_VMWare上使用Qemu-KVM创建虚拟机</title>
    <link href="/017.html"/>
    <url>/017.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 可信计算_Qemu03_VMWare上使用Qemu-KVM创建虚拟机 date: 2022-06-06 21:31:08.145 updated: 2022-07-11 15:47:27.28 url: &#x2F;archives&#x2F;kxjsqemu03 categories:</p><ul><li>可信计算 tags:</li><li>可信计算</li></ul><hr><h3 id="1-计划"><a href="#1-计划" class="headerlink" title="1 计划"></a><strong>1 计划</strong></h3><p>我们在1、2已经完成了不使用KVM，只用Qemu也可以实现虚拟化，我们现在将使用KVM来对Qemu虚拟化进行加速，但是需要使用KVM，Linux 内核和硬件必须支持 KVM（基于内核的虚拟机）完全虚拟化，并且必须加载必要的内核模块。 qemu当运行与主机架构相同的目标架构时可以使用KVM，例如一个x86兼容处理器上运行qemu-system-x86，因此我们在前面的安装的ARM架构是无法利用X86架构的KVM的，我们在本次实验中，换成X86架构的虚拟机。</p><ul><li>利用Qemu实现X86_64系统上运行ARM虚拟机，学习Qemu</li><li>使用Qemu-KVM同样的搭建虚拟机，学习KVM</li><li>添加vTPM支持，实现可信虚拟机</li></ul><p> </p><h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2 注意事项"></a><strong>2 注意事项</strong></h3><ul><li>您的内核必须是2.6.29或更高版本才能运行任何版本的qemu-kvm（内核2.6.27 &#x2F; 2.6.28与kvm-kmod 2.6.29也将工作） 参考 <a href="http://www.linux-kvm.org/page/Choose_the_right_kvm_%26_kernel_version">如何选择kvm和内核版本</a></li><li>KVM内核空间组件在Linux 2.6.20之后已经被集成在Linux内核和空间，KVM用户空间组件就在Qemu中，参考<a href="http://www.linux-kvm.org/page/Main_Page">KVM官网</a>。</li></ul><h3 id="3-实验前准备😀😁"><a href="#3-实验前准备😀😁" class="headerlink" title="3 实验前准备😀😁"></a><strong>3 实验前准备😀😁</strong></h3><p>  用的是Win11上的WMware，在其中创建了CentOS 7的虚拟机，然后再在虚拟机里面使用Qemu再创建虚拟机。采用的最新版的Qemu 7.0.0 采用VMWare实现，需要开启虚拟化功能：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657246748827.png" alt="image-1657246748827"> 进入系统后查看，系统是否支持虚拟化： <code>#egrep &#39;(vmxsvm)&#39; /proc/cpuinfo</code> <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657247335267.png" alt="image-1657247335267"> 检查是否已经加载KVM模块 : <code>#modprobe kvm</code> 加载kvm内核模块：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">功能区分intel/amd的启用：<br><span class="hljs-comment">#modprobe kvm-intel</span><br><span class="hljs-comment"># lsmod grep kvm</span><br>kvm_intel      <span class="hljs-number"> 55496 </span>0<br>kvm         <span class="hljs-number"> 337772 </span>1 kvm_intel<br></code></pre></td></tr></table></figure><h3 id="4-Qemu安装"><a href="#4-Qemu安装" class="headerlink" title="4 Qemu安装"></a><strong>4 Qemu安装</strong></h3><blockquote><p>qemu-kvm安装有两个方法，可以通过 yum安装：<code>yum install -y qemu-kvm</code>，但在这个实验中，我们都是通过qemu源码编译的方式进行安装。</p></blockquote><p>  在前一个实验中，我们编译的命令如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/opt/qemu-7.0.0</span><br><span class="hljs-string">./configure</span> <span class="hljs-params">--target-list=aarch64-softmmu</span> <span class="hljs-params">--enable-vnc</span> <span class="hljs-params">--enable-sdl</span> <span class="hljs-params">--python=/usr/bin/python3</span><br></code></pre></td></tr></table></figure><p>查看qemu命令：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657247480650.png" alt="image-1657247480650"> 可以看到没有qemu-system-x86_64，因为我们上面的configure命令中并没有指定 x84_64-softmmu，需要重新编译。 重新编译命令：</p><ol><li><p>清除之前编译的配置文件等。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> /opt/qemu-<span class="hljs-number">7</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">make</span> distclean<br></code></pre></td></tr></table></figure></li><li><p>configue命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./configure</span> <span class="hljs-params">--enable-debug</span>  <span class="hljs-params">--enable-kvm</span> <span class="hljs-params">--enable-vnc</span> <span class="hljs-params">--target-list=x86_64-softmmu</span> <span class="hljs-params">--enable-sdl</span><br></code></pre></td></tr></table></figure><p><code>--target-list</code> 指定最终的虚拟机是X86架构 <code>--enable-kvm</code> 启用KVM加速，其余参数与之前的实验相同。</p></li><li><p>编译 <code>make -j4</code></p></li><li><p>安装 <code>make install</code></p></li></ol><p>安装结果，查看qemu命令：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657247444309.png" alt="image-1657247444309">上图可能看不清，放大：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657248068132.png" alt="image-1657248068132"> 可以看到现在已经有 <code>qemu-system-x86_64</code> 这个命令了🙂。</p><h3 id="5-安装VNCServer"><a href="#5-安装VNCServer" class="headerlink" title="5 安装VNCServer"></a><strong>5 安装VNCServer</strong></h3><p>我们使用VNC界面来安装操作系统。不然的话会卡住并提示：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Loading</span></span> bootlogo... Initializing gfx code...<br></code></pre></td></tr></table></figure><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657264940684.png" alt="image-1657264940684"></p><ul><li><p>安装 <code># yum install tigervnc-server tigervnc</code></p></li><li><p>设置密码</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta"># vncpasswd </span><br><span class="hljs-symbol">Password:</span> <span class="hljs-number">123456</span><br><span class="hljs-symbol">Verify:</span><br></code></pre></td></tr></table></figure></li><li><p>配置，目的：使用systemctl管理vnc窗口，只创建一个窗口</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># cp <span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>vncserver@.service <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>vncserver@:<span class="hljs-number">1</span>.service<br># vim <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>vncserver@:<span class="hljs-number">1</span>.service<br></code></pre></td></tr></table></figure><p>其内容为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br> <span class="hljs-attr">Description</span>=Remote desktop service (VNC)<br> <span class="hljs-attr">After</span>=syslog.target network.target<br><br> <span class="hljs-section">[Service]</span><br> <span class="hljs-attr">Type</span>=simple<br><br> <span class="hljs-comment"># Clean any existing files in /tmp/.X11-unix environment</span><br> <span class="hljs-attr">ExecStartPre</span>=/bin/sh -c <span class="hljs-string">&#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1  :&#x27;</span><br> <span class="hljs-attr">ExecStart</span>=/usr/bin/vncserver_wrapper &lt;USER&gt; %i<br> <span class="hljs-attr">ExecStop</span>=/bin/sh -c <span class="hljs-string">&#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1  :&#x27;</span><br><br> <span class="hljs-section">[Install]</span><br> <span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p>修改配置，将<code>&lt;USER&gt;</code>改为root <code>ExecStart=/usr/bin/vncserver_wrapper root %i</code></p></li><li><p>重启systemd <code># systemctl daemon-reload</code></p></li><li><p>配置防火墙</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit"># firewall-cmd --permanent --add-service vnc-server<br><span class="hljs-keyword">success</span><br><span class="hljs-keyword"></span># systemctl restart firewalld.service<br></code></pre></td></tr></table></figure></li><li><p>查看状态</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">root@centos7</span> <span class="hljs-string">~</span>]<span class="hljs-comment"># systemctl status firewalld.service</span><br><span class="hljs-string">●</span> <span class="hljs-string">firewalld.service</span> <span class="hljs-bullet">-</span> <span class="hljs-string">firewalld</span> <span class="hljs-bullet">-</span> <span class="hljs-string">dynamic</span> <span class="hljs-string">firewall</span> <span class="hljs-string">daemon</span><br>   <span class="hljs-attr">Loaded:</span> <span class="hljs-string">loaded</span> <span class="hljs-string">(/usr/lib/systemd/system/firewalld.service;</span> <span class="hljs-string">enabled;</span> <span class="hljs-attr">vendor preset:</span> <span class="hljs-string">enabled)</span><br>   <span class="hljs-attr">Active:</span> <span class="hljs-string">active</span> <span class="hljs-string">(running)</span> <span class="hljs-string">since</span> <span class="hljs-string">五</span> <span class="hljs-number">2022-07-08 16:27:27 </span><span class="hljs-string">CST;</span> <span class="hljs-string">25s</span> <span class="hljs-string">ago</span><br>     <span class="hljs-attr">Docs:</span> <span class="hljs-string">man:firewalld(1)</span><br>[<span class="hljs-string">root@centos7</span> <span class="hljs-string">~</span>]<span class="hljs-comment"># firewall-cmd --list-all</span><br><span class="hljs-string">public</span> <span class="hljs-string">(active)</span><br>  <span class="hljs-attr">target:</span> <span class="hljs-string">default</span><br>  <span class="hljs-attr">icmp-block-inversion:</span> <span class="hljs-literal">no</span><br>  <span class="hljs-attr">interfaces:</span> <span class="hljs-string">br0</span> <span class="hljs-string">ens32</span><br>  <span class="hljs-attr">sources:</span><br>  <span class="hljs-attr">services:</span> <span class="hljs-string">dhcpv6-client</span> <span class="hljs-string">ssh</span> <span class="hljs-string">vnc-server</span><br></code></pre></td></tr></table></figure></li><li><p>开启一个VNC窗口</p></li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dts">[root@centos7 ~]<span class="hljs-meta"># systemctl start vncserver@:1.service</span><br>[root@centos7 ~]<span class="hljs-meta"># systemctl status vncserver@:1.service</span><br>● vncserver@:<span class="hljs-number">1.</span>service - Remote desktop service (VNC)<br><span class="hljs-symbol">   Loaded:</span> loaded (<span class="hljs-keyword">/etc/</span>systemd<span class="hljs-keyword">/system/</span>vncserver@:<span class="hljs-number">1.</span><span class="hljs-attr">service</span><span class="hljs-punctuation">;</span> <span class="hljs-attr">disabled</span><span class="hljs-punctuation">;</span> vendor preset: disabled)<br><span class="hljs-symbol">   Active:</span> active (running) since 五 <span class="hljs-number">2022</span><span class="hljs-number">-07</span><span class="hljs-number">-08</span> <span class="hljs-number">16</span>:<span class="hljs-number">31</span>:<span class="hljs-number">16</span> CST<span class="hljs-punctuation">;</span> <span class="hljs-number">2</span>s ago<br><span class="hljs-symbol">  Process:</span> <span class="hljs-number">38041</span> ExecStartP<span class="hljs-attr">re</span><span class="hljs-operator">=</span><span class="hljs-keyword">/bin/</span>sh -c <span class="hljs-keyword">/usr/</span>bin/vncserver -kill %i &gt; <span class="hljs-keyword">/dev/</span>null <span class="hljs-number">2</span>&gt;<span class="hljs-variable">&amp;1</span>  : (<span class="hljs-attr">code</span><span class="hljs-operator">=</span>exited, <span class="hljs-attr">status</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>/SUCCESS)<br> Main PID: <span class="hljs-number">38046</span> (vncserver_wrapp)<br><span class="hljs-symbol">   CGroup:</span> /system.slice/system-vncserver.slice/vncserver@:<span class="hljs-number">1.</span>service<br>           └─<span class="hljs-number">38046</span> <span class="hljs-keyword">/bin/</span>sh <span class="hljs-keyword">/usr/</span>bin/vncserver_wrapper root :<span class="hljs-number">1</span><br><br><span class="hljs-number">7</span>月 <span class="hljs-number">08</span> <span class="hljs-number">16</span>:<span class="hljs-number">31</span>:<span class="hljs-number">16</span> centos7 systemd[<span class="hljs-number">1</span>]: Starting Remote desktop service (VNC)...<br><span class="hljs-number">7</span>月 <span class="hljs-number">08</span> <span class="hljs-number">16</span>:<span class="hljs-number">31</span>:<span class="hljs-number">16</span> centos7 systemd[<span class="hljs-number">1</span>]: Started Remote desktop service (VNC).<br>[root@centos7 ~]<span class="hljs-meta"># vncserver -list</span><br><br>TigerVNC server sessions:<br><br>X DISPLAY <span class="hljs-meta">#     PROCESS ID</span><br>:<span class="hljs-number">1</span>              <span class="hljs-number">38071</span><br><br></code></pre></td></tr></table></figure><ul><li>使用 vncviewer 连接 <code>vncviewer -geometry 1900x1000 :1</code></li></ul><p>关闭vncviewer。</p><h3 id="5-安装Qemu-KVM虚拟机"><a href="#5-安装Qemu-KVM虚拟机" class="headerlink" title="5 安装Qemu-KVM虚拟机"></a><strong>5 安装Qemu-KVM虚拟机</strong></h3><p>现在已经有了可以创建虚拟机的命令了，需要使用一个X86架构的虚拟机镜像，我们为了方便区分宿主机和虚拟机，我们采用x84架构的ubuntu作为虚拟机，VMware中的CentOS 7作为虚拟机。</p><ol><li>下载并上传操作系统镜像</li></ol><blockquote><p>这个版本有点问题，成功安装系统后，重新启动虚拟机会卡在黑屏界面。 试了很多方法，也没能解决这个问题，CentOS7、Ubuntu18.04都能启动，但是Ubuntu18.10没能成功启动。</p></blockquote><p>我们下载 <code>ubuntu-18.10-desktop-amd64.iso</code> 镜像(<strong>AMD64是AMD的叫法</strong>)，下载链接：<a href="https://old-releases.ubuntu.com/releases/cosmic/">https://old-releases.ubuntu.com/releases/cosmic/</a> 下好之后，上传至CentOS 7中，保存在<strong>目录&#x2F;devsdb下</strong>。这个目录需要与下面安装时指定iso文件路径一致。</p><blockquote><p>原本是放在&#x2F;root下的，但是当初给VMware Centos分配的磁盘空间太小，创建不了虚拟硬盘，而VMware扩展硬盘，需要删除之前的快照，只能新添了一个硬盘，重新挂载在&#x2F;devsdb下使用。</p></blockquote><ol start="2"><li>创建虚拟硬盘</li></ol><p>利用qemu-img指令可以创建1个空的虚拟硬盘，便于后面安装的时候将系统安装到虚拟硬盘上。这里我们采用qcow2格式的磁盘映像 <code>-f qcow2</code>。 <code>qemu-img create -f qcow2 ubuntu-18.10-desktop-amd64.qcow2 16G</code></p><ol start="3"><li>虚拟机安装</li></ol><p>第一次启动虚拟机，需要安装操作系统，指定ISO镜像文件，命令如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-x86_64 --enable-kvm -m <span class="hljs-number">2048</span> -smp <span class="hljs-number">4</span> -boot d -hda ubuntu-<span class="hljs-number">18</span>.<span class="hljs-number">10</span>-desktop-amd64.qcow2 -cdrom ubuntu-<span class="hljs-number">18</span>.<span class="hljs-number">10</span>-desktop-amd64.iso -cpu host<br></code></pre></td></tr></table></figure><p>输入命令后太会自动弹出Qemu窗口，如下图所示，安装即可。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657268618382.png" alt="image-1657268618382"></p><h3 id="6-运行并检查网络"><a href="#6-运行并检查网络" class="headerlink" title="6 运行并检查网络"></a><strong>6 运行并检查网络</strong></h3><p>操作系统安装完成后，直接关闭 VNC 窗口。 启动虚拟机：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-x86_64 --enable-kvm -m <span class="hljs-number">2048</span> -smp <span class="hljs-number">4</span> -hda ubuntu-<span class="hljs-number">18</span>.<span class="hljs-number">10</span>-desktop-amd64.qcow2  -cpu host<br></code></pre></td></tr></table></figure><p>注意：去掉 -boot d和-cdrom ubuntu-18.10-desktop-amd64.iso，因为他会指定启动方式。d代表（第一个CD-ROM），参考 <a href="https://man.archlinux.org/man/qemu.1">https://man.archlinux.org/man/qemu.1</a> 但是启动会黑屏：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657274543345.png" alt="image-1657274543345"><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657274598061.png" alt="image-1657274598061"> 经过测试：用以上步骤重新安装CentOS7，安装成功后也可以正常启动：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">qemu-system-x86_64 --enable-kvm -m 2048 -smp 4 -hda centos7.qcow2 -cpu host -device virtio-net,<span class="hljs-attribute">netdev</span>=network0 -netdev tap,<span class="hljs-attribute">id</span>=network0,ifname=tap0,script=no,downscript=no,vhost=on<br></code></pre></td></tr></table></figure><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657468335956.png" alt="image-1657468335956"> 考虑是不是安装Ubuntu 18.10的时候选择出错了。 我在尝试了ubuntu18.04版本的镜像，发现就可以了，也没有报错。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-x86_64 --enable-kvm -m <span class="hljs-number">2048</span> -smp <span class="hljs-number">2</span> -boot d -hda ubuntu18-<span class="hljs-number">04</span>.qcow2 -cpu host<br></code></pre></td></tr></table></figure><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657524241844.png" alt="image-1657524241844"> 试了很多方法，也没能解决这个问题，CentOS7、Ubuntu18.04都能启动，但是Ubuntu18.10没能成功启动。</p><h3 id="7-设置网络"><a href="#7-设置网络" class="headerlink" title="7 设置网络"></a><strong>7 设置网络</strong></h3><p>接下来我们就用刚才安装的ubuntu18.04版本来进行操作，看看网络情况如何。</p><h4 id="7-1-情况说明"><a href="#7-1-情况说明" class="headerlink" title="7.1 情况说明"></a><strong>7.1 情况说明</strong></h4><ol><li>查看宿主机CentOS地址：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657525018336.png" alt="image-1657525018336"></li><li>查看虚拟机ubuntu18.04的ip地址<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657525096831.png" alt="image-1657525096831"></li><li>目前无法访问百度：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657525157190.png" alt="image-1657525157190"></li></ol><h4 id="7-2-网络配置"><a href="#7-2-网络配置" class="headerlink" title="7.2 网络配置"></a><strong>7.2 网络配置</strong></h4><p>类似我上个实验，我们采用桥接方式来联通连网通网络 <a href="https://www.landery.cn/archives/kxjsqemu02">https://www.landery.cn/archives/kxjsqemu02</a> 。 我们如上个实验中添加启动、关闭脚本后：关闭虚拟机，在启动虚拟机的命令后添加如下参数： <code>-net tap,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown</code> 全部命令如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-x86_64 --enable-kvm -m <span class="hljs-number">2048</span> -smp <span class="hljs-number">2</span> -boot d -hda ubuntu18-<span class="hljs-number">04</span>.qcow2 -cpu host -net nic -net tap,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown<br></code></pre></td></tr></table></figure><p>进入虚拟机后，查看虚拟机ip，已经变成192.168.134.128同网段的ip地址。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657525432730.png" alt="image-1657525432730"> 测试是否能访问百度：<strong>成功</strong><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1657525581298.png" alt="image-1657525581298"> 经过测试，网络已经可以正常访问。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h3><ul><li><a href="https://www.jb51.net/article/94086.htm">https://www.jb51.net/article/94086.htm</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可信计算_Qemu02_VMWare上使用Qemu7.0.0 实现X86_64系统上运行ARM架构虚拟机</title>
    <link href="/016.html"/>
    <url>/016.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 可信计算_Qemu02_VMWare上使用Qemu7.0.0 实现X86_64系统上运行ARM架构虚拟机 date: 2022-05-19 18:52:48.023 updated: 2022-06-06 18:15:00.265 url: &#x2F;archives&#x2F;kxjsqemu02 categories:</p><ul><li>可信计算 tags:</li><li>可信计算</li><li>虚拟化</li></ul><hr><h1 id="1-上一篇回顾"><a href="#1-上一篇回顾" class="headerlink" title="1 上一篇回顾"></a><strong>1 上一篇回顾</strong></h1><p>在上一篇中，我们已经实现了在X86系统上跑起来了ARM架构的虚拟机，虽然有些小插曲，但无伤大雅。我们本此的目的就是，解决Qemu虚拟机不能访问外网的问题。 在 <a href="https://wiki.archlinux.org/title/QEMU#Running_virtualized_system">https://wiki.archlinux.org/title/QEMU#Running_virtualized_system</a> 中给出了很多种访问外网的方式，我们使用<strong>桥接</strong>的方式实现。 网上的设置方法主要有两种：<strong>NAT和桥接</strong>，也叫做user mode network和tap&#x2F;tun network。 <strong>NAT</strong> 就是虚拟机里的guestOS通过host的物理网卡eth0，连接上网。该方法方便设置，缺点是其他机器难以访问到guest。要求host机器创建虚拟网卡tap0，guest机器和该网卡tap0设置为统一网段，并以tap0的地址作为网关，host机器上的物理网卡eth0为该tap0做NAT。 因此需要安装Uml-utilites以生成虚拟网卡tap0，tunctl -t tap0 <strong>桥接</strong>：基本思想是host机器上，物理网卡eth0和虚拟网卡tapN建立网桥，guestOS通过tapN连接上网，这样guestOS和host都处于物理局域网内，其他机器也可以访问guestOS。 需要安装以下两个包，bridge-tils和Uml-utilites，前者用于建立桥接，后者用于生成虚拟网卡。 虚拟机启动命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">qemu-system-aarch64 -m 2048 -cpu cortex-a57 -smp 2 -M virt -bios QEMU_EFI.fd -nographic -drive <span class="hljs-attribute">if</span>=none,file=ubuntu16.04-arm64.img,id=hd0 -device virtio-blk-device,<span class="hljs-attribute">drive</span>=hd0<br></code></pre></td></tr></table></figure><h1 id="2-系统环境"><a href="#2-系统环境" class="headerlink" title="2 系统环境"></a><strong>2 系统环境</strong></h1><ul><li>主机：X86_64，win 11，安装了VMWare，</li><li>VMWare安装了CentOS 7虚拟机，X86_64版本，能访问外网NAT模式</li><li>CentOS中安装了Qemu 7.0.0，Qemu中运行的是Ubuntu 16.04 Server ARM64架构版虚拟机，不能访问外网</li></ul><p>接下来我们称CentOS为宿主机，Qemu中的Ubuntu 16.04为虚拟机：</p><ul><li>宿主机ip配置：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652955528279.png" alt="image-1652955528279"></li><li>Qemu虚拟机配置：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652955566653.png" alt="image-1652955566653"></li></ul><p>因为我们的启动命令没有添加网络访问方式，Qemu虚拟机目前状况：无法访问百度，开始使用桥接方式联通虚拟机：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652955603701.png" alt="image-1652955603701"></p><h1 id="3-宿主机配置"><a href="#3-宿主机配置" class="headerlink" title="3 宿主机配置"></a><strong>3 宿主机配置</strong></h1><ol><li><p>安装工具包 <code>yum install uml-utilities bridge-utils -y</code></p></li><li><p>使用TAP后端前，需要确认你的宿主机的内核支持TAP网络接口： &#x2F;dev&#x2F;net&#x2F;tun 文件存在则说明支持。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@centos7</span> ~]<span class="hljs-meta"># ls /dev/net</span><br>tun<br></code></pre></td></tr></table></figure><p>如果没有这样的文件，可以尝试手工创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> /dev/net<br>sudo <span class="hljs-built_in">mknod</span> /dev/net/tun c 10 200<br>sudo /sbin/modprobe tun<br></code></pre></td></tr></table></figure></li><li><p>创建网桥br0网桥可以理解为就是一个交换机，我们现在要做的就是创建交换机，并且将Centos上的物理网卡ens32绑定在br0上，我们可以使用brctl命令来进行创建，也可以通过编辑配置文件手动配置桥接网卡。 配置文件修改参考：<a href="https://blog.csdn.net/T_NULL/article/details/89973514">CentOS 网桥配置，静态IP配置</a>、<a href="https://www.bbsmax.com/A/obzb71bQJE/">brctl创建虚拟网卡详解</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl stop NetworkManager <span class="hljs-comment"># 先关闭networkmanager</span><br><br><span class="hljs-built_in">cp</span> /etc/sysconfig/network-scripts/ifcfg-ens32 /etc/sysconfig/network-scripts/ifcfg-br0 <span class="hljs-comment">#根据自己的网卡进行替换ens32</span><br><br>vim /etc/sysconfig/network-scripts/ifcfg-ens32 <span class="hljs-comment"># 编辑ens32</span><br><br>修改 ifcfg-ens32 的以下几项：<br>TYPE=<span class="hljs-string">&quot;Ethernet&quot;</span><br>BRIDGE=br0    //添加这一行<br>BOOTPROTO=<span class="hljs-string">&quot;none&quot;</span><br><span class="hljs-comment">#IPADDR=&quot;192.168.134.129&quot;                          //注释掉这几行</span><br><span class="hljs-comment">#PREFIX=&quot;24&quot;</span><br><span class="hljs-comment">#GATEWAY=&quot;192.168.134.2&quot;</span><br><span class="hljs-comment">#DNS1=&quot;8.8.8.8&quot;</span><br><br>vim /etc/sysconfig/network-scripts/ifcfg-br0 <span class="hljs-comment"># 编辑br0</span><br>修改 ifcfg-br0 的以下几项：<br>TYPE=<span class="hljs-string">&quot;Bridge&quot;</span>//这一行修改为Bridge<br>BOOTPROTO=<span class="hljs-string">&quot;none&quot;</span><br>NAME=<span class="hljs-string">&quot;br0&quot;</span>//修改设备名称为br0<br><span class="hljs-comment"># UUID=&quot;xxxx&quot;//这一行注释</span><br>DEVICE=<span class="hljs-string">&quot;br0&quot;</span>//修改设备为br0<br>IPADDR=<span class="hljs-string">&quot;192.168.134.129&quot;</span><br>PREFIX=<span class="hljs-string">&quot;24&quot;</span><br>GATEWAY=<span class="hljs-string">&quot;192.168.134.2&quot;</span><br>DNS1=<span class="hljs-string">&quot;8.8.8.8&quot;</span><br><br><span class="hljs-comment"># 重启网络</span><br>systemctl  restart network<br></code></pre></td></tr></table></figure><p>查看网卡配置 <code>ip addr</code><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654505805970.png" alt="image-1654505805970"> 可以看到ens32已经没有ip了，ping一下百度看能不能访问外网，可以看到没有问题。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654505865053.png" alt="image-1654505865053"></p></li><li><p>配置 qemu-ifup文件 这个文件在我创建的过程中，并没有生成，我们自己创建： 该文件用于后续启动虚拟机时，指定执行的脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bashqemu-ifup">vim /etc/qemu-ifup #创建文件，添加以下内容<br>------------<br>#!/bin/sh<br>sudo tunctl -t $1 -u root  #创建tap，每一个虚拟机对应一个tap<br>sudo ifconfig $1 up #启动tap<br>sudo brctl addif br0 $1 #将tap绑定到我们创建的网桥上<br>-----------<br>或者，如果tunctl不存在<br>#!/bin/sh<br>sudo ip tuntap add dev $1 mode tun user root<br>sudo ifconfig $1 up<br>sudo brctl addif br0 $1<br></code></pre></td></tr></table></figure></li><li><p>配置 qemu-ifdown文件 这个文件在我创建的过程中，并没有生成，我们自己创建： 该文件用于后续关闭虚拟机时，指定执行的脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bashqemu-ifdown">vim /etc/qemu-ifdown #创建文件，添加以下内容<br>------------<br>#!/bin/sh<br>sudo ifconfig $1 down # 关闭tap<br>sudo brctl delif br0 $1 # 断开与br0的连接<br>-----------<br></code></pre></td></tr></table></figure></li><li><p>赋予脚本执行权限 <code>sudo chmod +x /etc/qemu*</code></p></li><li><p>启动虚拟机，在之前的启动参数上添加<code>-net nic -net tap,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown</code> 完整的启动命令如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">qemu-system-aarch64 -m 2048 -cpu cortex-a57 -smp 2 -M virt -bios QEMU_EFI.fd -nographic -drive <span class="hljs-attribute">if</span>=none,file=ubuntu16.04-arm64.img,id=hd0 -device virtio-blk-device,<span class="hljs-attribute">drive</span>=hd0 -net nic -net tap,<span class="hljs-attribute">script</span>=/etc/qemu-ifup,downscript=/etc/qemu-ifdown<br></code></pre></td></tr></table></figure></li><li><p>虚拟机启动后，我们查看虚拟机网络配置变化：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654507697809.png" alt="image-1654507697809">可以看到，Qemu虚拟机ubuntu ip地址已经变成了<strong>192.168.134.128</strong>，变成了与宿主机CentOS的br0同网段的ip地址。我们再看一下宿主机CentOS网络配置有什么变化，应该是要生成一个tap设备。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654507812414.png" alt="image-1654507812414">果然生成了一个tap设备tap0，我们查看网桥br0的接口：<code>brctl show br0</code><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654507870957.png" alt="image-1654507870957">可以看到，tap0已经绑定到br0上。</p></li><li><p>最后测试，是否成功：虚拟机目前已经获得ip地址：192.168.134.128 1）虚拟机Ubuntu访问外网：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654507960066.png" alt="image-1654507960066">2）虚拟机访问VMware上CentOS宿主机（192.168.134.129）：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654508045445.png" alt="image-1654508045445">3）虚拟机访问本机Win11（192.168.134.1）：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654508094252.png" alt="image-1654508094252">4）VMWare上宿主机CentOS访问Qemu虚拟机ubuntu：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654510106910.png" alt="image-1654510106910">5）本机Win11 访问Qemu虚拟机ubuntu：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654510091312.png" alt="image-1654510091312">通过上述测试，发现已经能正常访问外网、VMware上的宿主机以及最终的Win11 宿主机。都能互相访问，网络配置成功。</p></li></ol><h1 id="4-扩展"><a href="#4-扩展" class="headerlink" title="4 扩展"></a><strong>4 扩展</strong></h1><p>我们查看虚拟机ubuntu的网络配置文件： <code>cat /etc/network/interfaces</code><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654508798316.png" alt="image-1654508798316">发现他是自动配置ip，我们也可以设置为静态ip，是可以设置的，效果如下，需要修改DNS等，不然无法访问外网。这里面需要重启，不然网络设置不会生效。参考：<a href="https://www.likecs.com/show-203632114.html%EF%BF%BC">https://www.likecs.com/show-203632114.html<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1654509688295.png" alt="image-1654509688295"></a></p><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a><strong>参考链接：</strong></h1><ul><li><a href="https://blog.csdn.net/leacock1991/article/details/114002541">从0开始使用QEMU模拟ARM开发环境之QEMU利用桥接联网</a></li><li><a href="https://blog.csdn.net/chen_cheng_fly/article/details/5413951">qemu网络设置 ubuntu</a></li><li><a href="https://blog.csdn.net/T_NULL/article/details/89973514">CentOS 网桥配置，静态IP配置</a></li><li><a href="https://www.bbsmax.com/A/obzb71bQJE/">brctl创建虚拟网卡详解</a></li><li><a href="https://blog.csdn.net/changzehai/article/details/124952332">使用qemu-ifup&#x2F;qemu-ifdown脚本支持运行多个qemu模拟开发板</a></li><li><a href="https://wiki.archlinux.org/title/QEMU#Running_virtualized_system">Wiki Qemu配置</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可信计算_Qemu01_VMWare上使用Qemu7.0.0 实现X86_64系统上运行ARM架构虚拟机</title>
    <link href="/015.html"/>
    <url>/015.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 可信计算_Qemu01_VMWare上使用Qemu7.0.0 实现X86_64系统上运行ARM架构虚拟机 date: 2022-05-17 18:58:33.28 updated: 2022-05-23 11:31:53.213 url: &#x2F;archives&#x2F;kxjsqemu01 categories:</p><ul><li>可信计算 tags:</li><li>可信计算</li></ul><hr><h1 id="1-计划"><a href="#1-计划" class="headerlink" title="1 计划"></a><strong>1 计划</strong></h1><p>Qemu就算不用KVM，也有自己的一套虚拟化逻辑，我们就利用Qemu来实现在X86_64架构的服务器上利用Qemu跑起来ARM架构虚拟机。顺便学习Qemu。 最终目的，实现Qemu+KVM的虚拟机中添加vTPM支持。</p><ul><li>利用Qemu实现X86_64系统上运行ARM虚拟机，学习Qemu</li><li>使用Qemu-KVM同样的搭建虚拟机，学习KVM</li><li>添加vTPM支持，实现可信虚拟机</li></ul><h1 id="2-实验前准备"><a href="#2-实验前准备" class="headerlink" title="2 实验前准备"></a><strong>2 实验前准备</strong></h1><p>本实验用的是Win11上的WMware，在其中创建了CentOS 7的虚拟机，然后再在虚拟机里面使用Qemu再创建虚拟机。采用的最新版的Qemu 7.0.0 采用VMWare实现，需要开启虚拟化功能：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652759080095.png" alt="image-1652759080095"> 进入CentOS 7后查看CPU架构等信息 <code>lscpu</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@centos7 ~]<span class="hljs-comment"># lscpu</span><br>Architecture:          x86_64<br>CPU op-mode(s):        32-bit, 64-bit<br>Byte Order:            Little Endian<br>CPU(s):                4<br>On-line CPU(s) list:   0-3<br>Thread(s) per core:    1<br>Core(s) per socket:    1<br>座：                 4<br>NUMA 节点：         1<br>厂商 ID：           GenuineIntel<br>CPU 系列：          6<br>型号：              158<br>型号名称：        Intel(R) Core(TM) i5-8400 CPU @ 2.80GHz<br>步进：              10<br>CPU MHz：             2808.002<br>BogoMIPS：            5616.00<br>虚拟化：           VT-x<br>超管理器厂商：  VMware<br>虚拟化类型：     完全<br>L1d 缓存：          32K<br>L1i 缓存：          32K<br>L2 缓存：           256K<br>L3 缓存：           9216K<br>NUMA 节点0 CPU：    0-3<br></code></pre></td></tr></table></figure><h1 id="3-Qemu下载"><a href="#3-Qemu下载" class="headerlink" title="3 Qemu下载"></a><strong>3 Qemu下载</strong></h1><p>我们将所有东西放在 <code>/opt</code> 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /opt<br>wget https://download.qemu.org/qemu-7.0.0.tar.xz<br>tar -xvJf qemu-7.0.0.tar.xz <span class="hljs-comment">#解压</span><br></code></pre></td></tr></table></figure><p>其中wget 使用的下载的链接可在官方下载地址查找 <a href="https://download.qemu.org/">https://download.qemu.org/</a></p><h1 id="4-编译运行"><a href="#4-编译运行" class="headerlink" title="4 编译运行"></a><strong>4 编译运行</strong></h1><h2 id="4-1先安装依赖"><a href="#4-1先安装依赖" class="headerlink" title="4.1先安装依赖"></a><strong>4.1先安装依赖</strong></h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">`yum install zlib-devel glib* <span class="hljs-built_in">auto</span>make libtool pixman-devel`<br></code></pre></td></tr></table></figure><blockquote><p>这里说一下源码编译的过程，可以查看Qemu编译过程中的信息，一般通过源码编译安装软件包都要运行下面三条命令：</p><ul><li><code>./configure</code></li><li><code>make</code></li><li><code>make install</code></li></ul><p><code>./configure</code> 是一个脚本会自动检查系统环境，比如编译构建工具是否齐全，源码目录，依赖库目录，安装目录等，系统平台和架构信息，其他编译选项等。这些信息可以保持默认或通过参数传递给 configure。然后configure会根据这些信息生成一个 Makefile文件。<code>./configure -h</code> 可以查看它的帮助文档。 <code>make</code> 命令会根据Makefile中的信息真正开始编译过程。make有一个重要的参数-j可以用来指定编译过程可以同时并行多少任务，一般多核 CPU 可以将该参数指定为 CPU 核数来加快编译。 <code>make install</code> 是将编译好的二进制文件安装到系统上。</p></blockquote><p>编译Qemu之前我们可以查看一下Qemu可以配置的参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>  /opt/qemu-7.0.0<br>./configure -h<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[root@centos7 qemu-7.0.0]# ./configure -h<br>Standard options:<br>  --help                   <span class="hljs-built_in">print</span> this message<br>  <span class="hljs-attribute">--prefix</span>=PREFIX          install <span class="hljs-keyword">in</span><span class="hljs-built_in"> PREFIX </span>[/usr/local]<br>  <span class="hljs-attribute">--interp-prefix</span>=PREFIX   where <span class="hljs-keyword">to</span> <span class="hljs-built_in">find</span> shared libraries, etc.<br>                           use %M <span class="hljs-keyword">for</span> cpu name [/usr/gnemul/qemu-%M]<br>  <span class="hljs-attribute">--target-list</span>=LIST       <span class="hljs-built_in">set</span> target list (default: build all)<br>                           Available targets: aarch64-softmmu alpha-softmmu<br>                           i386-softmmu m68k-softmmu microblazeel-softmmu<br><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br>  <span class="hljs-attribute">--target-list-exclude</span>=LIST exclude a <span class="hljs-built_in">set</span> of targets <span class="hljs-keyword">from</span> the<span class="hljs-built_in"> default </span>target-list<br><br>Advanced options (experts only):<br>  <span class="hljs-attribute">--cross-prefix</span>=PREFIX    use<span class="hljs-built_in"> PREFIX </span><span class="hljs-keyword">for</span> compile tools,<span class="hljs-built_in"> PREFIX </span>can be blank []<br>  <span class="hljs-attribute">--cc</span>=CC                  use C compiler CC [cc]<br>  <span class="hljs-attribute">--iasl</span>=IASL              use ACPI compiler IASL [iasl]<br>  <span class="hljs-attribute">--host-cc</span>=CC             use C compiler CC [cc] <span class="hljs-keyword">for</span> code <span class="hljs-built_in">run</span> at<br>  <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>.<br><br>Optional features, enabled with --enable-FEATURE <span class="hljs-keyword">and</span><br>disabled with --disable-FEATURE,<span class="hljs-built_in"> default </span>is enabled <span class="hljs-keyword">if</span> available<br>(unless built with --without-default-features):<br>  <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>.<br>  kvm             KVM acceleration support<br>  sdl             SDL<span class="hljs-built_in"> user interface</span><br><span class="hljs-built_in"></span>  tpm             TPM support<br>  vnc             VNC<span class="hljs-built_in"> server</span><br><span class="hljs-built_in"></span>  vnc-jpeg        JPEG lossy compression <span class="hljs-keyword">for</span> VNC<span class="hljs-built_in"> server</span><br><span class="hljs-built_in"></span>  vnc-png         PNG compression <span class="hljs-keyword">for</span> VNC<span class="hljs-built_in"> server</span><br><span class="hljs-built_in"></span>  vnc-sasl        SASL authentication <span class="hljs-keyword">for</span> VNC<span class="hljs-built_in"> server</span><br><span class="hljs-built_in"></span>  vte             vte support <span class="hljs-keyword">for</span> the gtk UI<br>  <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br></code></pre></td></tr></table></figure><p>我们只列出了一部分参数，我大致可以知道我们能指定要生成 QEMU 的平台版本，比如 x86 和 arm。还可以指定需要附加功能，其中比较重要的是 sdl、vnc，还可以启用TPM支持kvm等这些在后面都会使用到。</p><h2 id="4-2-configure"><a href="#4-2-configure" class="headerlink" title="4.2 configure"></a><strong>4.2 configure</strong></h2><p>QEMU 默认编译生成所有平台的版本，为了加快编译速度，我们只选择我们要用到的ARM64: aarch64-softmmu，使用<code>--target-list</code> 指示。 编译命令如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./configure</span> <span class="hljs-params">--target-list=aarch64-softmmu</span> <span class="hljs-params">--enable-vnc</span> <span class="hljs-params">--enable-sdl</span><br></code></pre></td></tr></table></figure><blockquote><p>参数讲解 ： <code>--target-list=aarch64-softmmu</code>，我们最终要运行的虚拟机的架构ARM64 <code>--enable-sdl</code>，用户接口用生成的 QEMU 创建的虚拟机没有画面。启动虚拟机时只会显示一行：<code>VNC server running on127.0.0.1:5900</code>，这样你就只能通过 VNC 访问虚拟机了。下面介绍VNC连接 <code>--enable-vnc</code>， VNC Server，虚拟机启动后可以用VNC连接</p></blockquote><p>报错：python版本必须大于3.6</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">[root@centos7 qemu<span class="hljs-string">-7</span>.0.0]# ./configure --target-list=aarch64-softmmu --enable-vnc --enable-sdl<br>Using &#x27;./build&#x27; as the directory for build output<br><br><span class="hljs-keyword">ERROR: </span>Cannot use &#x27;/usr/bin/python&#x27;, Python &gt;= 3.6 is required.<br>       Use --python=/path/to/python to specify a supported Python.<br></code></pre></td></tr></table></figure><p>继续修改命令，发现本地安装有python3.6.8 指定python版本<code>--python=/usr/bin/python3</code>：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">[root@centos7 qemu<span class="hljs-string">-7</span>.0.0]# ./configure --target-list=aarch64-softmmu --enable-vnc --enable-sdl --python=/usr/bin/python3<br>Using &#x27;./build&#x27; as the directory for build output<br><br><span class="hljs-keyword">ERROR: </span>Cannot find Ninja<br><br></code></pre></td></tr></table></figure><p>原因：新版本的qemu编译依赖ninja，所以需要先安装ninja,如果不安装ninja</p><h3 id="4-2-1-安装ninja"><a href="#4-2-1-安装ninja" class="headerlink" title="4.2.1 安装ninja"></a><strong>4.2.1 安装ninja</strong></h3><ol><li><p>安装编译依赖 <code>yum -y install git automake gcc+ gcc-c++ libtool</code></p></li><li><p>获取源码、并编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/skvadrik/re2c.git re2c <br><span class="hljs-built_in">cd</span> re2c<br><span class="hljs-built_in">mkdir</span> -p m4<br>./autogen.sh &amp;&amp; ./configure --prefix=/usr &amp;&amp; make<br>sudo make install<br></code></pre></td></tr></table></figure><blockquote><p>git clone <a href="https://github.com/skvadrik/re2c.git">https://github.com/skvadrik/re2c.git</a> re2c 可能报错：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">[root@centos7 <span class="hljs-keyword">opt</span>]# wget  https://github.<span class="hljs-keyword">com</span>/skvadrik/re2c.git<br> --<span class="hljs-number">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">17</span> <span class="hljs-number">16</span>:<span class="hljs-number">07</span>:<span class="hljs-number">13</span>--  https://github.<span class="hljs-keyword">com</span>/skvadrik/re2c.git<br> 正在解析主机 github.<span class="hljs-keyword">com</span> (github.<span class="hljs-keyword">com</span>)... <span class="hljs-number">20.205</span>.<span class="hljs-number">243.166</span><br> 正在连接 github.<span class="hljs-keyword">com</span> (github.<span class="hljs-keyword">com</span>)<span class="hljs-number">20.205</span>.<span class="hljs-number">243.166</span>:<span class="hljs-number">443</span>... 失败：拒绝连接。<br></code></pre></td></tr></table></figure><p>因为github在国内访问受限，我能访问官网并下载zip，但是不能通过clone的方式， 所以这里我们就直接下载zip上传到虚拟机中解压即可。</p></blockquote></li><li><p>检查是否安装成功 <code>re2c -v</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@centos7 re2c]<span class="hljs-comment"># re2c -v</span><br>re2c 3.0<br></code></pre></td></tr></table></figure><p>官方安装文档：<a href="http://re2c.org/install/install.html">http://re2c.org/install/install.html</a></p></li><li><p>安装ninja，ninja官网地址：<code>https://ninja-build.org/</code>，github仓库地址：<code>https://github.com/ninja-build/ninja</code>，可以从github仓库克隆项目切换到release分支或者下载release包，目前最新版是1.11.0，安装同样先下载到本地在上传至虚拟机，统一放到<code>opt</code>目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip ninja-1.11.0.zip<br><span class="hljs-built_in">cd</span> ninja-1.11.0<br>./configure.py --bootstrap<br><span class="hljs-built_in">cp</span> ninja /usr/bin/<br></code></pre></td></tr></table></figure></li><li><p>验证ninja是否安装成功 <code>ninja -h</code> 查看帮助文档</p></li></ol><blockquote><p>现在我们已经安装好了ninja，继续qemu安装</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/opt/qemu-7.0.0</span><br><span class="hljs-string">./configure</span> <span class="hljs-params">--target-list=aarch64-softmmu</span> <span class="hljs-params">--enable-vnc</span> <span class="hljs-params">--enable-sdl</span> <span class="hljs-params">--python=/usr/bin/python3</span><br></code></pre></td></tr></table></figure><p>报错，由于安装的qemu版本太高了，他需要GCC至少7.4版本</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">[root@centos7 qemu<span class="hljs-string">-7</span>.0.0]# ./configure --target-list=aarch64-softmmu --enable-vnc --enable-sdl --python=/usr/bin/python3<br>Using &#x27;./build&#x27; as the directory for build output<br><br><span class="hljs-keyword">ERROR: </span>You need at least GCC v7.4 or Clang v6.0 (or XCode Clang v10.0)<br></code></pre></td></tr></table></figure><p>查看gcc版本：4.8.5<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652776522710.png" alt="image-1652776522710"></p><h3 id="4-2-2-升级gcc版本"><a href="#4-2-2-升级gcc版本" class="headerlink" title="4.2.2 升级gcc版本"></a><strong>4.2.2 升级gcc版本</strong></h3><p>升级gcc版本：参考<a href="https://blog.csdn.net/weixin_43976122/article/details/108053736">CentOS系统升级gcc&#x2F;c++到7.5&#x2F;10.2版本</a></p><ul><li><p>下载高版本gcc</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> /opt<br><span class="hljs-attribute">wget</span> https://gcc.gnu.org/pub/gcc/releases/gcc-<span class="hljs-number">7</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span>/gcc-<span class="hljs-number">7</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.tar.gz --no-check-certificate<br><span class="hljs-attribute">tar</span> -zxvf /opt/gcc-<span class="hljs-number">7</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.tar.gz -C /usr/local/src<br><span class="hljs-attribute">cd</span> /usr/local/src/gcc-<span class="hljs-number">7</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span>/<br></code></pre></td></tr></table></figure></li><li><p>安装编译所需要的依赖环境 <code>./contrib/download_prerequisites</code></p><blockquote><p>报错：缺少bzip2</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">tar (child): lbzip2：无法 exec: 没有那个文件或目录<br>tar (child): Error is not recoverable: exiting now<br>tar: Child returned status 2<br>tar: Error is not recoverable: exiting now<br><span class="hljs-keyword">error: </span>Cannot extract package from gmp<span class="hljs-string">-6</span>.1.0.tar.bz2<br></code></pre></td></tr></table></figure><p>解决：<code>yum install bzip2</code></p></blockquote><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652777447355.png" alt="image-1652777447355"></p></li><li><p>建立临时文件夹并进行编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> gcc-7.5-build<br><span class="hljs-built_in">cd</span> gcc-7.5-build<br>../configure -enable-checking=release  -enable-languages=c,c++  -disable-multilib <br>make -j4 <span class="hljs-comment"># 这一步需要很久的时间</span><br>make  install<br><br><span class="hljs-comment">#备份旧gcc二进制文件，并进行替换</span><br><span class="hljs-built_in">mv</span> /usr/bin/gcc /usr/bin/gcc.bckup<br><span class="hljs-built_in">ln</span> -s /usr/local/bin/gcc /usr/bin/gcc<br>reboot   <span class="hljs-comment">##重启</span><br>gcc  -v    <span class="hljs-comment">##查看gcc/c++版本</span><br></code></pre></td></tr></table></figure><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652784219103.png" alt="image-1652784219103"> 可以看到已经是7.5.0版本的了，但是还没结束。</p></li><li><p>替换老版本gcc的动态库 1、首先检查动态库是否为老版本的 <code>strings /usr/lib64/libstdc++.so.6 grep GLIBC</code> 升级gcc的时候，新版的gcc动态库并没有替换老版本gcc的动态库，所以这里我们需要手动进行替换升级！ 2、先查找新版gcc生成的动态库位置 <code>find / -name &quot;libstdc++.so*&quot;</code> <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652784498654.png" alt="image-1652784498654"> 3、将新版gcc动态库libstdc++.so.6.0.24复制到&#x2F;usr&#x2F;lib64目录下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> /usr/lib64/<br><span class="hljs-attribute">cp</span> /usr/local/src/gcc-<span class="hljs-number">7</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span>/gcc-<span class="hljs-number">7</span>.<span class="hljs-number">5</span>-build/stage1-x86_64-pc-linux-gnu/libstdc++-v3/src/.libs/libstdc++.so.<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">24</span>  ./<br></code></pre></td></tr></table></figure><p>4、将旧版动态库备份，然后将默认库的软链接指向最新版的gcc动态库</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mv</span> libstdc++.so.<span class="hljs-number">6</span>   libstdc++.so.<span class="hljs-number">6</span>.bak<br><span class="hljs-attribute">ln</span> -s libstdc++.so.<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">24</span>   libstdc++.so.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>5、指完之后再检查动态库 <code>strings /usr/lib64/libstdc++.so.6 grep GLIBC</code></p></li></ul><blockquote><p>现在我们已经升级完成，再次执行qemu命令</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/opt/qemu-7.0.0</span><br><span class="hljs-string">./configure</span> <span class="hljs-params">--target-list=aarch64-softmmu</span> <span class="hljs-params">--enable-vnc</span> <span class="hljs-params">--enable-sdl</span> <span class="hljs-params">--python=/usr/bin/python3</span><br></code></pre></td></tr></table></figure><p>又出现报错：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Run-time dependency sdl2 found: NO (tried pkgconfig and config-tool)<br>../meson.build:842:2: ERROR: Dependency &quot;sdl2&quot; not found, tried pkgconfig and config-tool<br>A full log can be found at /opt/qemu<span class="hljs-string">-7</span>.0.0/build/meson-logs/meson-log.txt<br><span class="hljs-keyword">ERROR: </span>meson setup failed<br></code></pre></td></tr></table></figure><p>原因： 缺少sdl2</p><h3 id="4-2-3-centos-7-安装-sdl2"><a href="#4-2-3-centos-7-安装-sdl2" class="headerlink" title="4.2.3 centos 7 安装 sdl2"></a><strong>4.2.3 centos 7 安装 sdl2</strong></h3><ol><li>wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo <a href="http://mirrors.aliyun.com/repo/epel-7.repo">http://mirrors.aliyun.com/repo/epel-7.repo</a></li><li>安装以下依赖<ul><li>yum install SDL2_gfx-devel.x86_64</li><li>yum install SDL2_image-devel.x86_64</li><li>yum install SDL2_ttf-devel.x86_64</li><li>yum install SDL2.x86_64</li></ul></li></ol><p>安装成功，继续configure</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/opt/qemu-7.0.0</span><br><span class="hljs-string">./configure</span> <span class="hljs-params">--target-list=aarch64-softmmu</span> <span class="hljs-params">--enable-vnc</span> <span class="hljs-params">--enable-sdl</span> <span class="hljs-params">--python=/usr/bin/python3</span><br></code></pre></td></tr></table></figure><p>可以发现已经成功了。</p><h2 id="4-3-make编译"><a href="#4-3-make编译" class="headerlink" title="4.3 make编译"></a><strong>4.3 make编译</strong></h2><p><code>make -j4</code> 4核 , -j4加快编译。</p><h2 id="4-4-安装"><a href="#4-4-安装" class="headerlink" title="4.4 安装"></a><strong>4.4 安装</strong></h2><p><code>make install</code> 成功了，我们来验证一下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[root@centos7 qemu-7.0.0]</span># qemu-<span class="hljs-selector-tag">img</span> <span class="hljs-attr">--version</span><br>qemu-<span class="hljs-selector-tag">img</span> version <span class="hljs-number">7.0</span>.<span class="hljs-number">0</span><br>Copyright (c) <span class="hljs-number">2003</span>-<span class="hljs-number">2022</span> Fabrice Bellard and the QEMU Project developers<br><span class="hljs-selector-attr">[root@centos7 qemu-7.0.0]</span># qemu-system-aarch64 <span class="hljs-attr">--version</span><br>QEMU emulator version <span class="hljs-number">7.0</span>.<span class="hljs-number">0</span><br>Copyright (c) <span class="hljs-number">2003</span>-<span class="hljs-number">2022</span> Fabrice Bellard and the QEMU Project developers<br></code></pre></td></tr></table></figure><h1 id="5-UEFI下载和操作系统镜像下载"><a href="#5-UEFI下载和操作系统镜像下载" class="headerlink" title="5 UEFI下载和操作系统镜像下载"></a><strong>5 UEFI下载和操作系统镜像下载</strong></h1><p>UEFI下载链接： <a href="http://releases.linaro.org/components/kernel/uefi-linaro/16.02/release/qemu64/">http://releases.linaro.org/components/kernel/uefi-linaro/16.02/release/qemu64/</a> 这里我们用的是ubuntu 16.04 ARM版本的操作系统 <a href="https://old-releases.ubuntu.com/releases/16.04.3/">https://old-releases.ubuntu.com/releases/16.04.3/</a> ubuntu-16.04.2-server-arm64.iso</p><h1 id="6-创建虚拟硬盘"><a href="#6-创建虚拟硬盘" class="headerlink" title="6 创建虚拟硬盘"></a><strong>6 创建虚拟硬盘</strong></h1><p>利用qemu-img指令可以创建1个空的虚拟硬盘，便于后面安装的时候将系统安装到虚拟硬盘上。 <code>qemu-img create ubuntu16.04-arm64.img 16G</code></p><h1 id="7-虚拟机安装"><a href="#7-虚拟机安装" class="headerlink" title="7 虚拟机安装"></a><strong>7 虚拟机安装</strong></h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">qemu-system-aarch64 -m 2048 -cpu cortex-a57 -smp 2 -M virt -bios QEMU_EFI.fd -nographic -drive <span class="hljs-attribute">if</span>=none,file=ubuntu-16.04.2-server-arm64.iso,id=cdrom,media=cdrom -device virtio-scsi-device -device  scsi-cd,<span class="hljs-attribute">drive</span>=cdrom -drive <span class="hljs-attribute">if</span>=none,file=ubuntu16.04-arm64.img,format=raw,id=hd0 -device virtio-blk-device,<span class="hljs-attribute">drive</span>=hd0<br></code></pre></td></tr></table></figure><p>执行上述命令时确保QEMU_EFI.fd、ubuntu-16.04.2-server-arm64.iso、ubuntu16.04-arm64.img文件在当前目录下，否则需要修改成对应的文件路径。 键入命令就会开始安装。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652793369241.png" alt="image-1652793369241"> 安装过程截图：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652793703413.png" alt="image-1652793703413">过程会让你选择语言、地区等。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652800803711.png" alt="image-1652800803711">可以看到我们已经成功登录进去。</p><h1 id="8-qemu参数"><a href="#8-qemu参数" class="headerlink" title="8 qemu参数"></a><strong>8 qemu参数</strong></h1><p>关于我们启动的参数，可以参考这个博主的 <a href="https://blog.csdn.net/weixin_39871788/article/details/123250595">Qemu参数详解</a></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">qemu-system-aarch64 -m 2048 -cpu cortex-a57 -smp 2 -M virt -bios QEMU_EFI.fd -nographic -drive <span class="hljs-attribute">if</span>=none,file=ubuntu-16.04.2-server-arm64.iso,id=cdrom,media=cdrom -device virtio-scsi-device -device  scsi-cd,<span class="hljs-attribute">drive</span>=cdrom -drive <span class="hljs-attribute">if</span>=none,file=ubuntu16.04-arm64.img,id=hd0 -device virtio-blk-device,<span class="hljs-attribute">drive</span>=hd0<br></code></pre></td></tr></table></figure><p>可以看我我们这里面用了一些参数：</p><ul><li>-m：指定内存多少MB</li><li>-nographic：disable graphical output and redirect serial I&#x2F;Os to console，除此之外我们可以选择vnc连接 -display vnc</li></ul><blockquote><p>注意： ！！第9节中的操作如果跟着<strong>做可能出问题导致重新安装</strong>，如果不需要实践这一部分建议跳过。</p></blockquote><h1 id="9-VNC连接虚拟机"><a href="#9-VNC连接虚拟机" class="headerlink" title="9 VNC连接虚拟机"></a><strong>9 VNC连接虚拟机</strong></h1><p>我们也可以利用VNC进行登录。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">qemu-system-aarch64 -m 2048 -cpu cortex-a57 -smp 2 -M virt -bios QEMU_EFI.fd -display <span class="hljs-attribute">vnc</span>=:0 -drive <span class="hljs-attribute">if</span>=none,file=ubuntu-16.04.2-server-arm64.iso,id=cdrom,media=cdrom -device virtio-scsi-device -device  scsi-cd,<span class="hljs-attribute">drive</span>=cdrom -drive <span class="hljs-attribute">if</span>=none,file=ubuntu16.04-arm64.img,id=hd0 -device virtio-blk-device,<span class="hljs-attribute">drive</span>=hd0<br></code></pre></td></tr></table></figure><p>报如下警告：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">WARNING: Image <span class="hljs-built_in">format</span> was <span class="hljs-keyword">not</span> specified <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;ubuntu16.04-arm64.img&#x27;</span> <span class="hljs-keyword">and</span> probing guessed raw.<br>         Automatically detecting <span class="hljs-keyword">the</span> <span class="hljs-built_in">format</span> is dangerous <span class="hljs-keyword">for</span> raw images, <span class="hljs-built_in">write</span> operations <span class="hljs-keyword">on</span> <span class="hljs-title">block</span> <span class="hljs-title">0</span> <span class="hljs-title">will</span> <span class="hljs-title">be</span> <span class="hljs-title">restricted</span>.<br>         Specify <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;raw&#x27;</span> <span class="hljs-built_in">format</span> explicitly <span class="hljs-built_in">to</span> remove <span class="hljs-keyword">the</span> restrictions.<br></code></pre></td></tr></table></figure><p>磁盘格式指定为<code>format=raw</code> ;</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">qemu-system-aarch64 -m 2048 -cpu cortex-a57 -smp 2 -M virt -bios QEMU_EFI.fd -display <span class="hljs-attribute">vnc</span>=:0 -drive <span class="hljs-attribute">if</span>=none,file=ubuntu-16.04.2-server-arm64.iso,id=cdrom,media=cdrom -device virtio-scsi-device -device  scsi-cd,<span class="hljs-attribute">drive</span>=cdrom -drive <span class="hljs-attribute">if</span>=none,file=ubuntu16.04-arm64.img,format=raw,id=hd0 -device virtio-blk-device,<span class="hljs-attribute">drive</span>=hd0<br></code></pre></td></tr></table></figure><p>如果这里我们用vnc连接的话，需要我们输入密码，这里我们用的是mobaXterm这个工具来进行VNC连接的，在无外设模式下运行 QEMU 时，它会在端口 5900 上启动本地 VNC 服务器。 我们直接输入宿主机的ip和5900端口，它提示我们需要密码。</p><ul><li>设置vnc密码</li></ul><ol><li><p>我们先进入Qemu监控模式，这个模式可以换软盘或 CD等，在命令行上加入 <code>-monitor stdio</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">qemu-system-aarch64 -m 2048 -cpu cortex-a57 -smp 2 -M virt -bios QEMU_EFI.fd -display <span class="hljs-attribute">vnc</span>=:0 -drive <span class="hljs-attribute">if</span>=none,file=ubuntu-16.04.2-server-arm64.iso,id=cdrom,media=cdrom -device virtio-scsi-device -device  scsi-cd,<span class="hljs-attribute">drive</span>=cdrom -drive <span class="hljs-attribute">if</span>=none,file=ubuntu16.04-arm64.img,format=raw,id=hd0 -device virtio-blk-device,<span class="hljs-attribute">drive</span>=hd0 -monitor stdio<br>``<br></code></pre></td></tr></table></figure></li><li><p>修改vnc密码</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">(qemu) <span class="hljs-built_in">change</span> vnc password<br></code></pre></td></tr></table></figure></li><li><p>修改成功后就可以利用mobaXterm登陆了，当然你可以用其他的VNC客户端登录。</p><blockquote><p>监控模式和console模式切换：<code>Ctrl+Alt+2</code>，<code>Ctrl+Alt+1</code></p></blockquote></li></ol><blockquote><p>进入后发现又需要重新安装server，又要重新安装，但是安装过程磁盘那块划分会提示已经有磁盘划分，那块会一直报错。于是我直接删除原来的镜像，重新装一次，但是这次用的是vnc来装系统。大家可以不要跟着做，因为已经安装好了再安装一次浪费时间。</p></blockquote><p>使用VNC进行安装中….，心累<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652845597573.png" alt="image-1652845597573"> 安装成功，并成功登录。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652870229259.png" alt="image-1652870229259"></p><h1 id="10-启动虚拟机"><a href="#10-启动虚拟机" class="headerlink" title="10 启动虚拟机"></a><strong>10 启动虚拟机</strong></h1><p>我们关闭VNC重新运行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">qemu-system-aarch64 -m 2048 -cpu cortex-a57 -smp 2 -M virt -bios QEMU_EFI.fd -nographic -drive <span class="hljs-attribute">if</span>=none,file=ubuntu16.04-arm64.img,id=hd0 -device virtio-blk-device,<span class="hljs-attribute">drive</span>=hd0<br><br></code></pre></td></tr></table></figure><p>这个时候启动失败，发现博主也出现了这个问题， <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652882541683.png" alt="image-1652882541683"> 我们发现是进了EFI的shell界面，那为什么没有执行grub并引导进入ubuntu系统？说明UEFI固件没有找到ESP分区（EFI system partition，安装过程中就会看见创建了一个ESP分区）或者没有找到ESP分区中的EFI文件，因为系统需要该EFI文件来引导。在该shell下执行exit进入到UEFI的管理界面，并手动选择EFI文件启动系统，如下图所示。</p><ol><li>shell界面输入exit退出到下图界面，选择boot maintenance manager：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652882744715.png" alt="image-1652882744715"></li><li>选择 boot from file：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652882794411.png" alt="image-1652882794411"></li><li>一路enter就行，<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652882841387.png" alt="image-1652882841387">直到找到这个文件，回车即可。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652882882159.png" alt="image-1652882882159"></li></ol><p>成功进入安装的系统。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652883097277.png" alt="image-1652883097277"></p><h1 id="11-利用virt-manager启动虚拟机"><a href="#11-利用virt-manager启动虚拟机" class="headerlink" title="11 利用virt-manager启动虚拟机"></a><strong>11 利用virt-manager启动虚拟机</strong></h1><ul><li>安装virt-manager <code>yum install virt-manager</code></li><li>运行virt-manager <code>virt-manager</code></li></ul><p>使用mobaXterm ssh连接virt-manager报错：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">virt-manager 报Gtk-WARNING **: cannot open display<br></code></pre></td></tr></table></figure><p>解决方法： 出现这个问题之后，网上找了很多个博客的解决方法，安装了很多包，最后我也不清楚是安了哪些包才好的，我机器默认的ssh配置没有问题，mobaXterm默认打开X11转发的。反正记得一定要重新启动一个sshd窗口</p><ol><li>安装虚拟化相关工具，包括图形化工具（推荐使用组包安装，不容易遗漏软件包）</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">yum groupinstall <span class="hljs-string">&quot;Virtualization Hypervisor&quot;</span> <span class="hljs-string">&quot;Virutalization Client&quot;</span>,<span class="hljs-string">&quot;Virutalization Platform&quot;</span>,<span class="hljs-string">&quot;Virtualization Tools&quot;</span><br><br><span class="hljs-comment"># 下面这个也装上</span><br>yum <span class="hljs-keyword">install </span>-y <span class="hljs-keyword">xorg-x11-xauth </span><span class="hljs-keyword">xorg-x11-fonts-* </span><span class="hljs-keyword">xorg-x11-font-utils </span><span class="hljs-keyword">xorg-x11-fonts-Type1 </span>xclock<br></code></pre></td></tr></table></figure><ol start="2"><li>查看sshd服务配置文件</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># vi /etc/ssh/sshd_config</span><br><span class="hljs-attribute">X11Forwarding</span> <span class="hljs-literal">yes</span><br><br><span class="hljs-comment"># systemctl  restart sshd</span><br></code></pre></td></tr></table></figure><ol start="3"><li>关闭当前MobaXterm窗口，重新启动一个mobaXterm（十分重要！）</li><li>可以先用<code>xclock</code> 打开一个时钟看是否成功，如果成功说明显示窗口已经成功了，再用virt-manager如果失败的，就是virt-manager的问题。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652943503232.png" alt="image-1652943503232"></li></ol><p>继续启动，又报错，查看日志：<code>tailf -n 100 /root/.cache/virt-manager/virt-manager.log</code> 报错：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Libvirt URI <span class="hljs-keyword">is</span>: qemu:///<span class="hljs-keyword">system</span><br><br>Traceback (most recent <span class="hljs-keyword">call</span> last):<br>  File &quot;/usr/share/virt-manager/virtManager/connection.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">1036</span>, <span class="hljs-keyword">in</span> _do_open<br>    self._backend.<span class="hljs-keyword">open</span>(self._do_creds_password)<br>  File &quot;/usr/share/virt-manager/virtinst/connection.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">144</span>, <span class="hljs-keyword">in</span> <span class="hljs-keyword">open</span><br>    open_flags)<br>  File &quot;/usr/lib64/python2.7/site-packages/libvirt.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">104</span>, <span class="hljs-keyword">in</span> openAuth<br>    <span class="hljs-keyword">if</span> ret <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:<span class="hljs-keyword">raise</span> libvirtError(<span class="hljs-string">&#x27;virConnectOpenAuth() failed&#x27;</span>)<br>libvirtError: 将插槽连接到 <span class="hljs-string">&#x27;/var/run/libvirt/libvirt-sock&#x27;</span> 失败: 没有那个文件或目录<br></code></pre></td></tr></table></figure><p>解决方法：<strong>重启即可</strong> <code>reboot</code>。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652943639235.png" alt="image-1652943639235"> 启动这个什么字符，完全看不懂！！我们需要将他转为我们能看懂的！ 解决方法，很简单： 命令行执行： <code>Lang=C</code> 重新启动 <code>virt-manager</code> 即可</p><blockquote><p>LANG&#x3D;“” 是设置系统环境语言编码 当设置LANG&#x3D;C时，是最早最简单的C语言环境（标准ASCII码）</p></blockquote><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652944126355.png" alt="image-1652944126355"> 可以看到已经是英文了，如果我们需要将其转换成中文，参考 <a href="https://blog.csdn.net/weixin_42474905/article/details/81214087">KVM中打开virt-manager报错或者将其显示为中文界面的办法</a> 我们 Filke-&gt;New Virtual Machine-&gt;import Existing disk image，browse Local，选择本地镜像后，提示我们权限不足。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652944424470.png" alt="image-1652944424470"> 解决方法：</p><ol><li><p>修改配置文件 &#x2F;etc&#x2F;libvirt&#x2F;qemu.conf <code># vim /etc/libvirt/qemu.conf</code> 添加</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">user</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;root&quot;</span><br><span class="hljs-attribute">group</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;root&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>重启 libvirtd</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># systemctl restart libvirtd.service</span><br><span class="hljs-comment">// 或</span><br><span class="hljs-meta"># service libvirtd restart</span><br></code></pre></td></tr></table></figure></li><li><p>修改 SELinux 配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># vim /etc/selinux/config</span><br><span class="hljs-attr">SELINUX</span>=permissive<br></code></pre></td></tr></table></figure></li><li><p><strong>重启OS</strong> <code>reboot</code></p></li></ol><p>继续新建虚拟机，这回权限没问题了。 当我们选择aarch64架构的时候他会报错：<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652947356952.png" alt="image-1652947356952"> 解决方法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/yum</span>.repos.d/<br>wget https:<span class="hljs-regexp">//</span>www.kraxel.org<span class="hljs-regexp">/repos/</span>firmware.repo<br>yum install -y dnf<br>dnf install edk2.git-aarch64<br><br><span class="hljs-comment"># 编译/etc/libvirt/qemu.conf文件，添加如下语句</span><br><br>nvram = [<br>   <span class="hljs-string">&quot;/usr/share/edk2.git/aarch64/QEMU_EFI-pflash.raw:/usr/share/edk2.git/aarch64/vars-template-pflash.raw&quot;</span><br>]<br><span class="hljs-comment"># 重启</span><br>systemctl restart libvirtd<br></code></pre></td></tr></table></figure><p>再次启动发现warning不见了。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652947497520.png" alt="image-1652947497520"> 进入了Qemu-efi-pflash，但是一直在闪，无法输出。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652948788252.png" alt="image-1652948788252"> 我们将开始的Qemu-EFI.fd替换这个QEMU_EFI-pflash.raw。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=QEMU_EFI.fd <span class="hljs-attribute">of</span>=/usr/share/edk2.git/aarch64/QEMU_EFI-pflash.raw <span class="hljs-attribute">conv</span>=notrunc<br></code></pre></td></tr></table></figure><p>删除原来的虚拟机，<strong>别删除了镜像！！</strong>，做好保存，快照之类的。 重新创建虚拟机，一样的步骤就行了，成功进入EFI界面，同样选择<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652949299503.png" alt="image-1652949299503"> 发现是空的，按照网上的教程，也不行，使用virt-manager，接替已经创建的虚拟机，失败了。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652950949641.png" alt="image-1652950949641"> 按照博主的设置启动内核方式也存在问题，主要是分区表是LVM的，不能够将其中的数据对换出来。这里就先这样吧。目前毕竟只是测试，问题不大。我们也熟悉了virt-manager的运行，后期我们使用KVM的时候，再来仔细解决这些问题。 我们检查一下，虚拟机通过命令行是否正常运行。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">qemu-system-aarch64 -m 2048 -cpu cortex-a57 -smp 2 -M virt -bios QEMU_EFI.fd -nographic -drive <span class="hljs-attribute">if</span>=none,file=ubuntu16.04-arm64.img,id=hd0 -device virtio-blk-device,<span class="hljs-attribute">drive</span>=hd0<br></code></pre></td></tr></table></figure><p>正常进入问题。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652953218772.png" alt="image-1652953218772"></p><h1 id="12-下一篇"><a href="#12-下一篇" class="headerlink" title="12 下一篇"></a><strong>12 下一篇</strong></h1><p>在虚拟机中，我们尝试ping 百度试试，发现ping不通，但是解析ip是成功了，说明网不通，DNS却是正常的。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652953293243.png" alt="image-1652953293243"> 这篇文章已经很长了，我们下一篇主要解决Qemu虚拟网络的联通问题，实现Qemu虚拟机对外网的访问。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h1><ul><li><a href="https://www.cnblogs.com/bjarnescottlee/p/13872893.html">CentOS 7 安装 re2c 和 ninja</a></li><li><a href="https://blog.csdn.net/weixin_43976122/article/details/108053736">CentOS系统升级gcc&#x2F;c++到7.5&#x2F;10.2版本</a></li><li><a href="https://blog.csdn.net/weixin_39871788/article/details/123250595">Qemu参数详解</a></li><li><a href="https://man.archlinux.org/man/qemu.1">Qemu参数大全，官网</a></li><li><a href="https://blog.csdn.net/ivyxyw/article/details/114580793">libvirtError: 将插槽连接到 ‘&#x2F;var&#x2F;run&#x2F;libvirt&#x2F;libvirt-sock‘ 失败: 没有那个文件或目录</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>可信计算</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算_06_虚拟化技术_CPU硬件辅助虚拟化</title>
    <link href="/0012.html"/>
    <url>/0012.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 云计算_06_虚拟化技术_CPU硬件辅助虚拟化 date: 2022-04-29 18:11:05.0 updated: 2022-05-10 13:09:06.9 url: &#x2F;archives&#x2F;cloud061 categories:</p><ul><li>云计算 tags:</li><li>云计算</li><li>虚拟化</li></ul><hr><h1 id="1-CPU硬件辅助虚拟化"><a href="#1-CPU硬件辅助虚拟化" class="headerlink" title="1 CPU硬件辅助虚拟化"></a><strong>1 CPU硬件辅助虚拟化</strong></h1><p>之前我们已经介绍了CPU的三种虚拟化方式，也了解了KVM是基于硬件辅助的虚拟化，有些东西还是没说明白，比如VMCS是怎么用的，为什么要区分Root和Non-Root模式？引入根模式和非根模式之后，出现了八个级别，那么这几个级别又是运行的什么东西，跑的什么程序？虚拟机和宿主机之间又是怎么切换的？等等问题。由于本人才疏学浅，本文可能并不能全部解决这些问题，但是可以有一定的了解。</p><blockquote><p>注：本文大多来自网上的公开资料，参考文献在文末，只是加了本人的一点看法在其中。</p></blockquote><p>再来谈一谈是如何处理敏感指令的特权指令的问题的。 个人理解，由于原有X86系统Ring0-Ring3共4个级别，Linux只是用Ring0 和Ring 3，在没有虚拟化的场景下，操作系统OS可直接执行特权指令，运行在Ring 0级，而加入虚拟化环境后，在没有CPU硬件辅助虚拟化的技术下，就拿Linux来作为Guest OS来说，此时VMM层控制所有硬件资源，VM中的Guest OS只能处于Ring 1-Ring3级别，此时Guest OS不能直接对底层硬件进行操作，所以全虚拟化，也通过了VMM层来解决这个问题，半虚拟化通过Hypercall解决这个问题。但是前两种方式，存在软件实现，性能、兼容性等问题。 于是硬件辅助虚拟化出现，而硬件辅助虚拟化又需要怎么实现CPU虚拟化，什么是CPU虚拟化呢，目的是什么？我们先聊一下虚拟化的历史。 <em>1961年</em> — IBM709机实现了分时系统，将CPU占用切分为多个极短(1&#x2F;100sec)时间片，每一个时间片都执行着不同的任务。通过对这些时间片的轮询，这样就可以将一个CPU虚拟化或者伪装成为多个CPU，并且让每一颗虚拟CPU看起来都是在同时运行，这就是虚拟机的雏形。后来的system360机都支持分时系统。 <em>1972年</em> — IBM正式将system370机的分时系统命名为虚拟机。 <em>1990年</em> — IBM推出的system390机支持逻辑分区，即将一个cpu分为若干份(最多10份)，而且每份cpu都是独立的，也就是一个物理cpu可以逻辑的分为10个cpu。 直到IBM将分时系统开源后，个人PC终于临来了虚拟化的开端，后来才有了上述的虚拟机软件的发展。所以至今为止仍然有一部分虚拟机软件应用_分时系统_ 作为虚拟化的基础实现。就拿CPU全虚拟化来说，通过模拟这种方式实现的全虚拟化，那么VM是不清楚自己运行在虚拟机中的，因为它的OS发出的指令操作，最终都会落到底层的CPU上执行，就相当于分时使用CPU。 总结一下，<strong>虚拟化的最终目的</strong> ：使用逻辑来表示资源，从而摆脱物理限制的约束。提高物理资源的利用率。 而在虚拟化的过程中，发现Guest OS的特权指令以及敏感指令的问题，从解决这个问题的角度出发，就划分了CPU的虚拟化种类，什么全虚拟化、半虚拟化、硬件辅助虚拟化，目的是一样的，用逻辑表示资源，造成1个物理资源数量更多或者容量更大的假象！那么如何从硬件上支持这种虚拟化呢？ CPU虚拟化的问题，就转变为了如何解决敏感指令的问题，硬件辅助虚拟化方式就是引入了Root和Non-Root模式，将原来对CPU来说的4个级别，划分成了8个级别，CPU知道自己处于Root模式还是Non-Root模式，VMM运行在Root模式中，而Guest VM则运行在Non-Root的受限模式中，当VM中的OS执行到敏感指令时，此时CPU处于Non-Root模式，就会产生VM-Exit事件，通过VMCS转入Root模式，VMM接管CPU，模拟结果后，发出VM-Entry，重新加载vcPU状态，返回VM。</p><h1 id="2-硬件辅助虚拟化-AMD-Intel"><a href="#2-硬件辅助虚拟化-AMD-Intel" class="headerlink" title="2 硬件辅助虚拟化 AMD&#x2F;Intel"></a><strong>2 硬件辅助虚拟化 AMD&#x2F;Intel</strong></h1><p>目前主要有Intel的VT-x和AMD的AMD-V这两种技术。其核心思想都是通过引入新的指令和运行模式，使VMM和Guest OS分别运行在不同模式（ROOT模式和非ROOT模式）下，且Guest OS运行在Ring 0下。通常情况下，Guest OS的核心指令可以直接下达到计算机系统硬件执行，而不需要经过VMM。当Guest OS执行到特殊指令的时候，系统会切换到VMM，让VMM来处理特殊指令。 我们就主要讲Intel的VT-x技术，AMD-V同理。</p><h1 id="3-Intel-VT-x技术"><a href="#3-Intel-VT-x技术" class="headerlink" title="3 Intel VT-x技术"></a><strong>3 Intel VT-x技术</strong></h1><p>经过前面的介绍，我们也知道了Intel VT技术包含CPU、内存和I／O三方面的虚拟化技术。CPU硬件辅助虚拟化技术，分为对应安腾架构的VT-i(Intel Virtualization Technology for ltanium)和对应x86架构的VT-x(Intel Virtualization Technologyfor x86)两个版本。内存硬件辅助虚拟化技术包括EPT(Extended Page Table)技术。I&#x2F;O 硬件辅助虚拟化技术的代表Intel VT-d(Intel Virtualization Technology for Directed I&#x2F;O)。 Intel VT-x解决了X86架构敏感指令和特权指令的问题，引入了Root和Non-Root模式，也就是根模式和非根模式，可使未经修改的Guest OS运行在特权级0，同时减少VMM对Guest OS的干预。CPU硬件辅助虚拟化技术简要说明流程图： <img src="https://b3logfile.com/file/2022/04/image-67164bbd.png" alt="image.png"> 效法IBM 大型机，VT-x提供了2 个运行环境：根（Root）环境和非根（Non-root）环境。根环境专门为VMM准备，很像原来没有VT-x 的x86，只是多了对VT-x 支持的几条指令。<strong>非根环境作为一个受限环境</strong>用来运行多个虚拟机。 <img src="https://b3logfile.com/file/2022/04/solo-fetchupload-349785463087908807-bb7bd82b.png" alt="CPU硬件辅助虚拟化技术_Intel_02"> 如上图所示，根操作模式与非根操作模式都有相应的特权级0至特权级3。VMM运行在根模式的特权级0，GuestOS的内核运行在非根模式的特权级0，GuestOS的应用程序运行在非根模式的特权级3。运行环境之间相互转化，从根环境到非根环境叫VMEntry；从非根环境到根环境叫VMExit。VT-x定义了VMEntry操作，使CPU由根模式切换到非根模式，运行客户机操作系统指令。若在非根模式执行了敏感指令或发生了中断等，会执行VMExit操作，切换回根模式运行VMM。</p><h1 id="VMX操作"><a href="#VMX操作" class="headerlink" title="VMX操作"></a><strong>VMX操作</strong></h1><p>VMX（Virtual Machine Extension）是Intel 64和IA-32架构处理器级别的功能，用于支持虚拟化。VMX支持两种类型的软件：</p><ol><li>Virtual-machine monitor（VMM），VMM对处理器和平台硬件具有完全的控制权限。VMM为客户软件提供虚拟处理器的抽象，从而让客户软件能够直接在逻辑CPU上跑。</li><li>客户软件（Guest software）。每个虚拟机（VM）就是一个客户软件运行环境。</li></ol><p>根操作模式与非根操作模式之间的转换称作VMX转换，从根操作模式转换到非根操作模式称作VMX进入（VMX Entry），相反从非根操作模式转换到根操作模式称作VMX退出（VMX Exit）。 当处理器运行于VMX<strong>根操作模式</strong>的时候，它类似于运行在没有打开VMX功能的环境下，跟不打开VMX功能的主要区别是，在VMX根操作模式中，可以执行VMX指令，但是当加载数据到某些特定的寄存器的时候，也会受到一些限制。 当处理器运行于VMX<strong>非根操作模式</strong>的时候，处理器的某些行为被限制住或者被更改以便实现虚拟化，即某些指令或者事件会引起VM exits，从而让处理器从VMX非操作模式退出到根操作模式的VMM里，从而让VMM去模拟这些指令的行为从而实现虚拟化。 根模式与非根模式之问的相互转换是通过VMX操作实现的。VMM 可以通过VMXON 和VMXOFF打开或关闭VT-x。如下图所示： <img src="https://b3logfile.com/file/2022/04/solo-fetchupload-3471718971278561740-396dd6be.png"> VMX操作模式流程：</p><ol><li>VMM执行VMXON指令进入VMX操作模式。</li><li>VMM可执行VMLAUNCH指令或VMRESUME指令产生VM Entry操作，进入到Guest OS，此时CPU处于非根模式。</li><li>Guest OS执行特权指令等情况导致VM Exit的发生，此时将陷入VMM，CPU切换为根模式。VMM根据VMExit的原因作出相应处理，处理完成后将转到2)，继续运行GuestOS。</li><li>VMM可决定是否退出VMX操作模式，通过执行VMXOFF指令来完成。</li></ol><h1 id="VMCS-结构"><a href="#VMCS-结构" class="headerlink" title="VMCS 结构"></a><strong>VMCS 结构</strong></h1><p>在虚拟化中，为了实现vCPU，既要模拟CPU的运行，又要记录vCPU的状态（包括对vCPU运行的控制信息），在Intel x86处理器的VMX（Virtual Machine Extension）功能中，通过引入根运行模式（VMX root operation）和非根模式（VMX non-root operation），直接让vCPU运行在逻辑CPU上，在软件上省去了对vCPU运行的模拟，同时也大大提升了性能。剩下的就是对vCPU状态的记录了，为此Intel引入了VMCS（Virtual Machine Control Structure）功能。 VMCS是保存在内存中的数据结构，其包括虚拟CPU的相关寄存器的内容及相关的控制信息。CPU在发生VM Entry或VM Exit时，都会查询和更新VMCS。VMM也可通过指令来配置VMCS，达到对虚拟处理器的管理。VMCS架构图如下图所示： <img src="https://b3logfile.com/file/2022/04/solo-fetchupload-11635459080763948743-f4431b72.png" alt="CPU硬件辅助虚拟化技术_技术_04"> VMCS中保存了客户机和宿主机之间切换的vCPU&#x2F;CPU的状态和控制信息，有点类似Linux中的进程上下文信息。 VMCS（Virtual Machine Control Structure）是Intel x86处理器中实现CPU虚拟化，记录vCPU状态的一个关键数据结构。该数据结构主要包含如下六方面的信息：</p><ol><li>Guest-state area，即vCPU的状态信息，包括vCPU的基本运行环境（如通用寄存器等）和一些非寄存器信息，如当前vCPU是否接收中断，是否有挂起的exception，VMCS的状态等等。</li><li>Host-state area，即主机物理CPU的状态信息，因为物理CPU是在主机CPU和vCPU之间来回切换运行的，所以在VMCS中既要记录vCPU的状态，也需要记录主机CPU的状态，这样vCPU才能有足够的信息恢复到原来主机CPU的状态，继续主机CPU的运行。其包含的具体信息和前面记录的vCPU的状态信息大体相同。</li><li>VM-execution control fields，该方面信息主要用于对vCPU的运行行为进行控制，这是VMM对vCPU进行配置最复杂的一部分，如<ol><li>控制vCPU在接收到某些中断事件的时候，是否直接在vCPU中处理掉，即虚拟机直接处理掉该中断事件还是需要退出到VMM中，让VMM去处理该中断事件。</li><li>是否使用EPT（Extended Page Table）功能。</li><li>是否允许vCPU直接访问某些I&#x2F;O口，MSR寄存器等资源。</li><li>vCPU执行某些指令的时候，是否会出发VM Exit等等。</li></ol></li><li>VM-exit control fields，即对VM Exit的行为进行控制，如VM Exit的时候对vCPU来说需要保存哪些MSR寄存器，对于主机CPU来说需要恢复哪些MSR寄存器。</li><li>VM-entry control fields，即对VM Entry的行为进行控制，如需要保存和恢复哪些MSR寄存器，是否需要向vCPU注入中断和异常等事件（VM Exit的时候不需要向主机CPU注入中断&#x2F;异常事件，因为可以让那些事件直接触发VM Exit）。</li><li>VM-exit information fields，即记录下发生VM Exit发生的原因及一些必要的信息，方便于VMM对VM Exit事件进行处理，如vCPU访问了特权资源造成VM Exit，则在该区域中，会记录下这个特权资源的类型，如I&#x2F;O地址，内存地址或者是MSR寄存器，并且也会记录下该特权资源的地址，好让VMM对该特权资源进行模拟。</li></ol><h1 id="VMCS-操作"><a href="#VMCS-操作" class="headerlink" title="VMCS 操作"></a><strong>VMCS 操作</strong></h1><p>每个vCPU都有自己的一份VMCS数据结构，并且在同一个VM中的vCPU可能会通过VMCS中的指针共享一些数据，如I&#x2F;O bitmap，MSR bitmap和EPT表等。VMCS的大小需要查看VMX capability MSR IA32_VMX_BASIC寄存器来决定，不同的处理器可能要求的不一样，最大不超过4KB。 每个VMCS都会有一个8字节的头部，前面4字节主要用来表示VMCS的版本号并且表示VMCS是否为shadow VMCS。然后从偏移量8开始，就是VMCS的数据区，不同版本号的VMCS数据区分布会不一样。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image.png" alt="image"> 当VMCS数据结构被load到逻辑CPU上（即执行VMPTRLD指令）后，处理器并没法通过普通的内存访问指令去访问VMCS，如果那样做的话，会引起处理器报错，唯一可用的方法就是通过<strong>VMREAD和VMWRITE</strong>指令去访问。 VMCS数据结构也会记录下当前vCPU的状态，基本上VMCS的状态由三个域来表示：</p><ol><li>Active或Inactive，表示该VMCS是否处于激活状态，即对于逻辑CPU来说，该VMCS是否是直接可用的，有点类似于Linux进程的可运行状态（虽然可运行，但并不意味着现在就必须运行）</li><li>Current或Non Current，该状态表示当前逻辑CPU执行VMX指令（如VMCLEAR，VMLAUNCH，VMRESUME等）时的目标VMCS（或者可以理解为目标vCPU），这些VMX指令的目标都是状态为Current的VMCS所代表的vCPU。</li><li>Clear或者Launched，用于表示VMCS所对应的vCPU是否有在逻辑CPU上执行过，如果没有，则为Clear状态，如果有，则为Launched状态，Launched状态的VMCS也可以通过VMCLEAR指令恢复到Clear状态。当一个vCPU从一个逻辑CPU迁移到另外一个逻辑CPU的时候，需要先将相应VMCS的状态恢复到Clear，撇清该VMCS根原本逻辑CPU的关系，然后在另外一个逻辑CPU上执行VMPTRLD，将该VMCS和新的逻辑CPU建立联系。</li></ol><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652158611885.png" alt="image-1652158611885">对于VMM而言，配置并运行一个VM的最基本步骤如下所示：</p><ol><li>根据IA32_VMX_BASIC MSR寄存器提供的VMCS region大小信息，在内存中创建一个4KB对齐的VMCS region（为了防止被直接内存访问到，可以将该page frame从页表中删除）；</li><li>根据IA32_VMX_BASIC MSR寄存器提供的VMCS版本信息，初始化新创建的VMCS region中的版本信息，并且将VMCS前4字节的bit31设置为0（表示该VMCS不是shadow VMCS）；</li><li>针对新创建的VMCS region执行VMCLEAR指令，这会对新创建的VMCS region进行初始化，并且将VMCS的状态设置为Clear；</li><li>针对新创建的VMCS region执行VMPTRLD指令，该指令会将新创建的VMCS region设置为逻辑CPU的当前VMCS，即新创建的VMCS从原来的Not Current状态变为Current状态，后面所有的VMX相关指令操作的对象都将是新创建的VMCS；</li><li>通过一系列的VMWRITE指令对VMCS中的Host-state area进行初始化，该区域将记录VM返回到VMM时，或者是VM Entry不成功时，逻辑CPU的状态及执行位置等信息；</li><li>通过VMWRITE指令对VMCS中VM-Exit control field，VM-Entry control field和VM execution control field等区域进行设置；</li><li>通过WMWRITE指令对VMCS中guest state area区域进行设置，该区域表示了VM中vCPU的执行时vCPU的状态，起始执行位置等信息；</li><li>执行VMLAUNCH指令，开始vCPU的执行。通过VMM需要判断VMLAUNCH的返回结果，确定vCPU是否真正被执行，还是因为某些逻辑冲突导致vCPU没有被执行就返回。</li></ol><p>注意：在设置VMCS的各个数据区域的时候，是有顺序讲究的，需要先设置Host-state area，这样可以防止后边步骤出现问题，CPU无法返回到正确的状态和位置，另外页可以减少后面设置对Host CPU状态的干扰。 下面这张图就展示了不同的VCPU的切换和状态转换过程： <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652159076468.png" alt="image-1652159076468"> 可以看到，不同的VMCS的切换就像Linux中不同的进程在逻辑CPU上切换，通过时分复用的方式共享着物理CPU的资源。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h1><ul><li><a href="https://blog.51cto.com/tasnrh/1736769">CPU硬件辅助虚拟化技术_我拿流年乱了浮生的技术博客_51CTO博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/49009600">VMX(1) – 简介 - 知乎 (</a><a href="http://zhihu.com/">zhihu.com</a><a href="https://zhuanlan.zhihu.com/p/49009600">)</a></li><li><a href="https://zhuanlan.zhihu.com/p/49257842">VMX(2) – VMCS理解 - 知乎 (</a><a href="http://zhihu.com/">zhihu.com</a><a href="https://zhuanlan.zhihu.com/p/49257842">)</a></li><li><a href="https://www.cnblogs.com/linuxxl/p/11658387.html">【转载】x86 平台安装arm虚拟机 - Linux_xl - 博客园 (</a><a href="http://cnblogs.com/">cnblogs.com</a><a href="https://www.cnblogs.com/linuxxl/p/11658387.html">)</a></li><li><a href="https://blog.csdn.net/weixin_34115824/article/details/90331902">(49条消息) 虚拟化的发展历程和实现方式_weixin_34115824的博客-CSDN博客</a></li><li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf">Intel 64 and IA-32 Architectures Software Developers Manual,Volume 3C: System Programming Guide,Part 3</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算_05_虚拟化_KVM虚拟化技术</title>
    <link href="/026.html"/>
    <url>/026.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 云计算_05_虚拟化_KVM虚拟化技术 date: 2022-04-25 23:42:49.0 updated: 2022-05-10 15:01:55.073 url: &#x2F;archives&#x2F;cloud05 categories:</p><ul><li>云计算</li><li>可信计算 tags:</li><li>云计算</li><li>虚拟化</li><li>KVM</li></ul><hr><h1 id="1-KVM虚拟化架构"><a href="#1-KVM虚拟化架构" class="headerlink" title="1 KVM虚拟化架构"></a><strong>1 KVM虚拟化架构</strong></h1><h2 id="1-1-主流虚拟化架构对比"><a href="#1-1-主流虚拟化架构对比" class="headerlink" title="1.1 主流虚拟化架构对比"></a><strong>1.1 主流虚拟化架构对比</strong></h2><h1 id="2-KVM-CPU虚拟化"><a href="#2-KVM-CPU虚拟化" class="headerlink" title="2 KVM CPU虚拟化"></a><strong>2 KVM CPU虚拟化</strong></h1><p>作为VMM，KVM分为两部分，分别是运行于Kernel模式的KVM内核模块和运行于User模式的Qemu模块。这里的Kernel模式和User模式，实际上指的是VMX根模式下的特权级0和特权级3。另外，KVM将虚拟机所在的运行模式称为Guest模式。所谓Guest模式，实际上指的是VMX的非根模式。<img src="https://b3logfile.com/file/2022/04/solo-fetchupload-1527156098614079296-d2fc0492.jpeg" alt="kvm_vmx_intel_oenhan"> 利用VT-x技术的支持，KVM中的每个虚拟机可具有多个虚拟处理器VCPU，每个VCPU对应一个Qemu线程，VCPU的创建、初始化、运行以及退出处理都在Qemu线程上下文中进行，需要Kernel、User和Guest三种模式相互配合，其工作模型如图2.1所示。Qemu线程与KVM内核模块间以ioctl的方式进行交互，而KVM内核模块与客户软件之间通过VM Exit和VM entry操作进行切换。 Qemu线程以ioctl的方式指示KVM内核模块进行VCPU的创建和初始化等操作，主要指VMM创建VCPU运行所需的各种数据结构并初始化。其中很重要的一个数据结构就是VMCS，其初始化配置见附2。 初始化工作完成之后，Qemu线程以ioctl的方式向KVM内核模块发出运行VCPU的指示，后者执行VM entry操作，将处理器由kernel模式切换到Guest模式，中止宿主机软件，转而运行客户软件。注意，宿主机软件被中止时，正处于Qemu线程上下文，且正在执行ioctl系统调用的kernel模式处理程序。客户软件在运行过程中，如发生异常或外部中断等事件，或执行I&#x2F;O操作，可能导致VM exit，将处理器状态由Guest模式切换回Kernel模式。KVM内核模块检查发生VM exit的原因，如果VM exit由于I&#x2F;O操作导致，则执行系统调用返回操作，将I&#x2F;O操作交给处于User模式的Qemu线程来处理，Qemu线程在处理完I&#x2F;O操作后再次执行ioctl，指示KVM切换处理器到Guest模式，恢复客户软件的运行；如果VM exit由于其它原因导致，则由KVM内核模块负责处理，并在处理后切换处理器到Guest模式，恢复客户机的运行。</p><h1 id="3-Qemu-KVM"><a href="#3-Qemu-KVM" class="headerlink" title="3 Qemu&#x2F;KVM"></a><strong>3 Qemu&#x2F;KVM</strong></h1><p><img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652162290321.png" alt="image-1652162290321">可以看到，对于宿主机来说，一个虚拟机对应一个Qemu进程，Qemu的作用可以理解为，为Qemu内部的虚拟机VM，创建内存，创建vcpu，或者可以换个角度来说，是其内部的VM使用了Qemu进程映射的内存，但是Qemu实际映射的内存，其实是由KVM来实现的，Qemu只是调用了KVM内核接口来分配内存、vcpu等操作，这里可以理解为我们普通的进程申请内存空间，都得通过linux内核给的接口来实现内存申请是一样的。 而对于宿主机来说，Qemu只是一个普通的进程，宿主机并不把它认为是Guest OS。 而且Qemu对于KVM来说，主要是用来做IO的虚拟化，简单地说就是IO的操作模拟。 加入Qemu进程中的VM发生了VM-Exit事件，会进入Root模式的KVM中，KVM会分析引起事件的原因是什么？如果是IO事件，这里就分为几种不同的方式。之前我们已经提到过Qemu&#x2F;KVM实现的IO虚拟化是有全虚拟化和半虚拟化两种方式的。</p><h2 id="3-1-IO全虚拟化"><a href="#3-1-IO全虚拟化" class="headerlink" title="3.1 IO全虚拟化"></a><strong>3.1 IO全虚拟化</strong></h2><p>全虚拟化我们已经讲过，他是使用软件模拟的方式。这种方式，当VM发生IO事件时，如果这些操作发生了VM-Exit，那么在KVM判断过后，发现是IO事件，会将这个IO请求交给Qemu进程处理，例如发网络数据包、输出字符等。 于是qemu进程将此操作代替Guest完成后并执行相应的“回调”，通过ioctl调用告诉KVM IO操作已完成，进入VM继续运行。这个过程就涉及到VM-Exit和VM-Entry操作，会造成较大的开销。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652164950883.png" alt="image-1652164950883"> 当然在这个图中，不能完全的描述IO过程，例如如果是IO事件，KVM将事件交给Qemu进程处理后，就类似我们打印机IO，CPU并不会等待IO执行完成，而是采用了DMA的方式，在IO处理的期间，Qemu中的虚拟机也是可以继续运行的。当IO操作结束后，通过设置vcpu或者cpu中断告知VM IO事件已经处理完成，vcpu中断也是通过设置相应的中断寄存器实现的。</p><h2 id="3-2-IO半虚拟化"><a href="#3-2-IO半虚拟化" class="headerlink" title="3.2 IO半虚拟化"></a><strong>3.2 IO半虚拟化</strong></h2><p>前面文章我们也说过了，IO半虚拟化。qemu&#x2F;kvm的半虚拟化实现，是通过virtio 驱动来实现的，通过了共享内存的方式来实现优化。<img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652165156131.png" alt="image-1652165156131">上图是KVM&#x2F;Qemu Virtio 网络虚拟化的一个图，相较于之前的全虚拟化，Virtio通过在Guest的Driver层引入了两个队列和相应的队列就绪描述符与qemu-kvm层Virtio Backend进行通信，并用文件描述符来替代之前的中断。 Virtio front-end与后端之间通过Vring buffer交互，<strong>在qemu中，使用事件循环机制来描述buffer</strong>的状态，这样当buffer中有数据的时候，qemu-kvm会监听到eventfd的事件就绪，于是就可以读取数据后发送到tap设备，当有数据从tap设备过来的时候，qemu将数据写入到buffer，并设置eventfd，这样front-end监听到事件就绪后从buffer中读取数据。 可以看到，这种方式不像全虚拟化方式，频繁发生VM-Exit和VM-Entry事件，减少了处理器的开销。但是这种方式依然存在问题，可以看到存在多次内存拷贝，对于网络io来说，效果不怎么好，于是vhost-net出现了。这个我们简单说一下，有时间再细说。 <img src="https://datamanage-1301168767.cos.ap-chengdu.myqcloud.com/halo/image-1652165812364.png" alt="image-1652165812364"> vhost-net 绕过了 QEMU 直接在Guest的front-end和backend之间通信，减少了数据的拷贝，特别是减少了用户态到内核态的拷贝。性能得到大大加强，就吞吐量来说，vhost-net基本能够跑满一台物理机的带宽。vhost-net需要内核支持，Redhat 6.1 后开始支持，默认状态下是开启的。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h1><ul><li><a href="https://zhuanlan.zhihu.com/p/105499858">KVM 虚拟化详解 - 知乎 (</a><a href="http://zhihu.com/">zhihu.com</a><a href="https://zhuanlan.zhihu.com/p/105499858">)</a></li><li><a href="https://oenhan.com/kvm-src-3-cpu">KVM源代码分析3:CPU虚拟化 OenHan</a></li><li><a href="https://blog.csdn.net/tycoon1988/article/details/45103231">看操作系统虚拟化原理总结篇——VMCS详解_tycoon1988的博客-CSDN博客</a></li><li><a href="https://shunliz.gitbooks.io/libvrit-qemu-kvm/content/di-yi-zhang-xu-ni-hua-ji-zhu-jian-jie/ioxu-ni-hua.html">libvirt+kvm+qemu IO 虚拟化简介</a></li><li><a href="https://blog.actorsfit.com/a?ID=01700-49738565-ba6f-4f67-9892-1449aeebad6e">基于KVM的Qemu功能 英文原版</a></li><li><a href="https://www.intel.com/content/www/us/en/developer/articles/guide/kvm-tuning-guide-on-xeon-based-systems.html">Intel官方文档 KVM&#x2F;Qemu 虚拟化架构</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算_04_虚拟化技术总结</title>
    <link href="/0011.html"/>
    <url>/0011.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 云计算_04_虚拟化技术总结 date: 2022-04-28 14:51:55.0 updated: 2022-05-05 22:29:52.914 url: &#x2F;archives&#x2F;cloud041 categories:</p><ul><li>云计算 tags:</li><li>云计算</li><li>虚拟化</li></ul><hr><h1 id="关于我们常说的虚拟化和半虚拟化"><a href="#关于我们常说的虚拟化和半虚拟化" class="headerlink" title="关于我们常说的虚拟化和半虚拟化"></a><strong>关于我们常说的虚拟化和半虚拟化</strong></h1><p>本次我们知道了I&#x2F;O虚拟化也存在半虚拟化、全虚拟化、硬件辅助虚拟化。但是我们常常听到某某Hypervisor产品是全虚拟化还是半虚拟化，但个人认为FV和PV的更主要区别是在于<strong>CPU的虚拟化技术</strong> 。 CPU的FV&#x2F;PV和l&#x2F;O 的FV&#x2F;PV并不是紧密联系的，例如早期的VMware ESX使用CPU FV +I&#x2F;O FV，早期的Xen使用CPU PV +I&#x2F;O PV，但在HVM技术出现之后，其各自主流结构已经变成VMware ESXi使用VT-x+I&#x2F;O FV, Xen使用VT-x+I&#x2F;O PV了，所以目前的Xen也都没有必须使用修改过内核的Guest OS的限制了。 因此当我们说一项技术是全虚拟化还是半虚拟化，应该关注的是它对于CPU、内存、I&#x2F;O虚拟化是如何实现的。</p><h1 id="KVM虚拟化"><a href="#KVM虚拟化" class="headerlink" title="KVM虚拟化"></a><strong>KVM虚拟化</strong></h1><p>这里以KVM为例，CPU、内存虚拟化由KVM实现，I&#x2F;O虚拟化由QEMU实现。网上公开的资料称KVM是硬件辅助的全虚拟化方式。</p><ul><li>CPU虚拟化：基于硬件辅助的全虚拟化。</li><li>内存虚拟化：硬件辅助的EPT页表虚拟化。</li><li>I&#x2F;O虚拟化：默认使用QEMU软件实现全虚拟化，也支持Virtio的半虚拟化方式，也支持硬件直通和SR-IOV的方式。</li></ul><p>接下来会详细介绍KVM虚拟化架构。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h1><ul><li><a href="https://www.cnblogs.com/sammyliu/p/4548194.html">KVM 介绍（4）：I&#x2F;O 设备直接分配和 SR-IOV [KVM PCI&#x2F;PCIe Pass-Through SR-IOV] - SammyLiu - 博客园 (</a><a href="http://cnblogs.com/">cnblogs.com</a><a href="https://www.cnblogs.com/sammyliu/p/4548194.html">)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
      <category>云计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云计算_03_虚拟化技术_内存虚拟化</title>
    <link href="/0010.html"/>
    <url>/0010.html</url>
    
    <content type="html"><![CDATA[<hr><p>title: 云计算_03_虚拟化技术_内存虚拟化 date: 2022-04-25 18:13:29.0 updated: 2022-05-05 23:36:33.896 url: &#x2F;archives&#x2F;cloud03 categories:</p><ul><li>云计算 tags:</li><li>云计算</li><li>虚拟化</li></ul><hr><h1 id="1-内存虚拟化"><a href="#1-内存虚拟化" class="headerlink" title="1 内存虚拟化"></a><strong>1 内存虚拟化</strong></h1><p>物理机的内存是一段连续分配的地址空间，VMM上层的各个虚拟机共享物理机的物理内存地址空间。由于虚拟机对于内存的访问是随机的，并且又需要保证虚拟机内部的内存地址是连续的，因此VMM就需要合理映射虚拟机内部看到的内存地址到物理机上的真实内存地址。</p><h1 id="2-操作系统地址转换"><a href="#2-操作系统地址转换" class="headerlink" title="2 操作系统地址转换"></a><strong>2 操作系统地址转换</strong></h1><p>再说虚拟机内存地址转换之前，我们先讨论一下，宿主机上操作系统的地址转换。 为什么在操作系统中不直接使用物理地址，而使用虚拟地址？ 因为使用虚拟地址可以带来诸多好处：</p><ol><li>在支持多进程的系统中，如果各个进程的镜像文件都使用物理地址，则在加载到同一物理内存空间的时候，可能发生冲突。</li><li>直接使用物理地址，不便于进行进程地址空间的隔离。</li><li>物理内存是有限的，在物理内存整体吃紧的时候，可以让多个进程通过分时复用的方法共享一个物理页面（某个进程需要保存的内容可以暂时swap到外部的disk&#x2F;flash），这有点类似于多线程分时复用共享CPU的方式。</li></ol><p>既然使用虚拟地址，就涉及到将虚拟地址转换为物理地址的过程，这需要MMU（Memory Management Unit）和页表（page table）的共同参与。在这里就不阐述了，具体的可以查看这篇文章：<a href="https://zhuanlan.zhihu.com/p/65298260">虚拟地址转换[一] - 基本流程 - 知乎 (</a><a href="http://zhihu.com/">zhihu.com</a><a href="https://zhuanlan.zhihu.com/p/65298260">)</a>。 反正我们只要记住，虚拟地址到物理地址的转换需要操作系统完成。 这是传统虚拟地址到物理地址转换的过程。 <img src="https://b3logfile.com/file/2022/04/solo-fetchupload-177851005796352991-89f9c086.jpeg"> 这里需要简单了解一下<strong>TLB</strong>。为了减少访问内存次数，一般查找页表时会先去查找TLB，它是一个硬件缓存。 因为访问内存中的页表相对耗时，尤其是在现在普遍使用多级页表的情况下，需要多次的内存访问，为了加快访问速度，系统设计人员为page table设计了一个硬件缓存 - <strong>TLB</strong> ，CPU会首先在TLB中查找，因为在TLB中找起来很快。TLB之所以快，一是因为它含有的entries的数目较少，二是TLB是集成进CPU的，它几乎可以按照CPU的速度运行。</p><h1 id="3-虚拟机内存地址转换"><a href="#3-虚拟机内存地址转换" class="headerlink" title="3 虚拟机内存地址转换"></a><strong>3 虚拟机内存地址转换</strong></h1><p>虚拟机中存在一个Guest OS，虚拟机之中的应用程序使用的是虚拟地址，该地址我们称为GVA（Guest Virtual Address），经过Guest OS地址转换后变成的中间的物理地址，我们称为GPA（Guest Physical Address），然后这个物理地址对于VMM来说，依然是虚拟地址，需要再一次进行地址转换，最终转换后的真实内存物理地址，我们称为HPA（Host Physical Address）。 <img src="https://b3logfile.com/file/2022/04/image-c5596141.png" alt="image.png"> 从下图，可以清晰看出地址转换的过程，可以看到相较于传统系统，需要进行两次地址转换。 <img src="https://b3logfile.com/file/2022/04/image-240c711c.png" alt="image.png"> 那么如何实现呢？</p><h2 id="4-软件实现-影子页表"><a href="#4-软件实现-影子页表" class="headerlink" title="4 软件实现-影子页表"></a><strong>4 软件实现-影子页表</strong></h2><p>为了支持GVA-&gt;GPA-&gt;HPA的两次转换，可以计算出GVA-&gt;HPA的映射关系，将其写入一个单独的影子页表（<strong>sPT</strong> - shadow Page Table）。在一个运行Linux的guest VM中，每个进程有一个由内核维护的页表，用于GVA-&gt;GPA的转换，这里我们把它称作<strong>gPT</strong> (guest Page Table)。 VMM层的软件会将gPT本身使用的物理页面设为write protected的，那么每当gPT有变动的时候（比如添加或删除了一个页表项），就会产生被VMM截获的page fault异常，之后VMM需要重新计算GVA-&gt;HPA的映射，更改sPT中对应的页表项。可见，这种纯软件的方法虽然能够解决问题，但是其存在两个缺点：</p><ul><li>实现较为复杂，需要为每个guest VM中的每个进程的gPT都维护一个对应的sPT，增加了内存的开销。</li><li>VMM使用的截获方法增多了page fault和trap&#x2F;vm-exit的数量，加重了CPU的负担。</li></ul><p>在一些场景下，这种影子页表机制造成的开销可以占到整个VMM软件负载的75%。<img src="https://b3logfile.com/file/2022/04/solo-fetchupload-3881046762424832134-3c33e2ca.png"> 虚拟CR3和物理CR3</p><ul><li>虚拟CR3：保存客户机页表的基地址。</li><li>物理CR3：保存影子页表的宿主机物理基地址。</li></ul><h2 id="5-硬件辅助-EPT-NPT"><a href="#5-硬件辅助-EPT-NPT" class="headerlink" title="5 硬件辅助-EPT&#x2F;NPT"></a><strong>5 硬件辅助-EPT&#x2F;NPT</strong></h2><p>为什么需要硬件辅助的内存虚拟化？ 传统的IA32架构，从硬件上只支持一次地址转换，导致单纯的软件虚拟化方法存在种种问题，例如实现复杂，内存开销大，CPU开销大，TLB性能低下。通过在CPU体系架构上增加相应的硬件支持，可以彻底解决这些问题。如模拟器使用的HAXM，KVM。 为此，各大CPU厂商相继推出了硬件辅助的内存虚拟化技术，比如Intel的EPT(Extended Page Table)和AMD的NPT(Nested Page Table），它们都能够从硬件上同时支持GVA-&gt;GPA和GPA-&gt;HPA的地址转换的技术。 GVA-&gt;GPA的转换依然是通过查找<strong>gPT</strong> 页表完成的，而GPA-&gt;HPA的转换则通过查找<strong>nPT</strong> 页表来实现，每个guest VM有一个由VMM维护的nPT。其实，EPT&#x2F;NPT就是一种扩展的MMU（以下称EPT&#x2F;NPT MMU），它可以交叉地查找gPT和nPT两个页表： 假设gPT和nPT都是4级页表，那么EPT&#x2F;NPT MMU完成一次地址转换的过程是这样的（不考虑TLB）： 首先它会查找guest VM中CR3寄存器（gCR3）指向的PML4页表，由于gCR3中存储的地址是GPA，因此CPU需要查找nPT来获取gCR3的GPA对应的HPA。这里我们称一次nPT的查找过程为一次<strong>nested walk</strong> 。 如果在nPT中没有找到，则产生EPT violation异常（可理解为VMM层的page fault）。如果找到了，也就是获得了PML4页表的物理地址后，就可以用GVA中的bit位子集作为PML4页表的索引，得到PDPE页表的GPA。接下来又是通过一次nested walk进行PDPE页表的GPA-&gt;HPA转换，然后重复上述过程，依次查找PD和PE页表，最终获得该GVA对应的HPA。 <img src="https://b3logfile.com/file/2022/04/solo-fetchupload-7190647901521006191-d8090f0a.png"> 不同于影子页表是一个进程需要一个sPT，EPT&#x2F;NPT MMU解耦了GVA-&gt;GPA转换和GPA-&gt;HPA转换之间的依赖关系，一个VM只需要一个nPT，减少了内存开销。如果guest VM中发生了page fault，可直接由guest OS处理，不会产生vm-exit，减少了CPU的开销。可以说，EPT&#x2F;NPT MMU这种硬件辅助的内存虚拟化技术解决了纯软件实现存在的两个问题。</p><h3 id="EPT-NPT-MMU优化"><a href="#EPT-NPT-MMU优化" class="headerlink" title="EPT&#x2F;NPT MMU优化"></a><strong>EPT&#x2F;NPT MMU优化</strong></h3><p>EPT TLB：EPT TLB存储的是GVA-&gt;HPA的映射，EPT MMU在查找GPT和EPT之前，会先去查找自己的EPT TLB是否存在(GVA-&gt;HPA)映射（前面为了描述的方便省略了这一步）, 没有则查找GPT和EPT页表，还是没有CPU则抛出EPT Violation异常由VMM来处理（产生VM-Exit）。 1、 <strong>TLB优化一：通过PCID&#x2F;ASID区分同一VM内不同的进程提高进程切换的效率</strong></p><ul><li><strong>原因：</strong> 不能区分一个TLB表项属于客户机内哪个进程，所以每次进程切换时，为避免不同进程间TLB混用，CPU会强制TLB全部失效。</li><li><strong>解决方法</strong>：同一VM内不同的进程可能会有相同的GVA，为了避免进程切换的时候flush刷新所有的TLB，可通过给TLB entry加上一个标识进程的tag来区分，这个tag标志在x86体系中则被叫做PCID，在ARM体系中被叫做ASID。</li><li><strong>原理</strong>：通过在每个TLB entry（GVA-&gt;HPA）上增加一个标志PCID，标识并区分来自不同的进程，利用PCID可以区分一个TLB entry属于哪个进程。CR3寄存器存储了当前进程对应的PCID，CR3中的PCID只占12个bits，最多能表达4096个process，这样虚拟机内部的进程切换不需要刷新TLB。</li><li><strong>意义</strong>：硬件级的对TLB资源管理的优化，硬件具备了区分不同的TLB entry属于不同进程的能力，避免了在每次进程切换时，使全部TLB失效，提高了进程切换的效率。</li></ul><p>2、<strong>TLB优化二：通过VPID&#x2F;VMID区分不同的VCPUs和宿主机（VMM），提高VM切换的效率</strong></p><ul><li><strong>背景</strong>：不能区分一个TLB表项属于哪个客户机VCPU或VMM，所以每次VM-Exit和VM-Entry，为避免VMM以及不同虚拟机间TLB混用，CPU会强制TLB全部失效。</li><li><strong>解决方法</strong>：不同的VM内的进程会有相同的GVA，VM和宿主机（VMM）也会有相同的VA，为了避免VM和宿主机（VMM）切换的时候flush刷新所有的TLB，可通过给每个TLB加上一个标识VM与VMM的tag来区分，这个tag标志在x86体系中则被叫做VPID，在ARM体系中被叫做VMID。</li><li><strong>原理</strong>：<ul><li>通过在每个TLB上增加一个标志VPID，标识并区分来自不同的VCPU或VMM。每个TLB表项与一个VPID相关联，用于唯一标识一个VCPU或VMM，利用VPID可以区分一个TLB表项属于哪个VCPU或VMM。（VMM的VPID为0，每个VCPU也各对应一个VPID。）</li><li>当进行虚拟地址到物理地址转换的时候，只有一个TLB表项对应的VPID与当前正在运行的虚拟机的VCPU的VPID相同的时候，才可以用该TLB表项把虚拟地址转换为物理地址。</li></ul></li><li><strong>意义</strong>：硬件级的对TLB资源管理的优化，硬件具备了区分不同的TLB项属于不同虚拟处理器地址空间的能力，避免了在每次VM-Exit和VM-Entry时，使全部TLB失效，提高了VM切换的效率。</li></ul><p>3、<strong>优化三、减少内存访问次数</strong> <strong>背景</strong>：以上述例子为例，假设客户机页表和EPT扩展页表都是4级页表，在最坏的情况下（也就是TLB一次也没有命中），gPT中的每一级转换都需要一次<strong>nested walk</strong>，而每次nested walk需要4次内存访问，因此5次nested walk总共需要 （4+1）*5-1 &#x3D; 24 次内存访问（就像一个5x5的二维矩阵一样）： <img src="https://b3logfile.com/file/2022/04/solo-fetchupload-10615508730671065051-e3466e9c.jpeg" alt="preview"> 虽然这24次内存访问都是由硬件自动完成的，不需要软件的参与，但是内存访问的速度毕竟不能与CPU的运行速度同日而语，而且内存访问还涉及到对总线的争夺，次数自然是越少越好。 <strong>解决</strong>：要想减少内存访问次数，要么是增大EPT&#x2F;NPT TLB的容量，增加TLB的命中率，要么是减少gPT和nPT的级数。 减少级数，需要采用大页（<a href="https://zhuanlan.zhihu.com/p/66427560">large page</a>）&#x2F;巨页（<a href="https://zhuanlan.zhihu.com/p/66427560">huge page</a>）技术：减少EPT的级数（空间换时间） 4、<strong>自伸缩内存调节技术：通过气球（balloon）回收或分配虚拟机内存</strong> 自伸缩内存调节技术：一个guest VM在创建的时候就获得了VMM分配给它的一定大小的宿主机物理内存，VMM通过“气球（balloon）”诱导客户机操作系统来回收或分配客户机所拥有的宿主机物理内存。</p><ul><li>原理：<ul><li>气球膨胀（balloon inflation）：当VMM需要从客户机回收宿主机物理内存时，VMM通知植入客户机操作系统的气球模块，气球发生膨胀，气球模块调用客户机操作系统本身的内存分配函数申请更多的客户机物理内存，VMM相应地把这些客户机物理内存所对应宿主机物理内存回收掉。这些气球模块申请的客户机物理内存名义上还是guest VM的，但实际上已经被VMM控制了，VMM完全可以把这些回收的内存挪作他用。（保留GVA-&gt;GPA的映射，取消GPA-&gt;HPA的映射）</li><li>气球收缩（balloon deflation）：当客户机操作系统企图访问被气球回收的客户机物理内存时，由于这些客户机物理内存对应的宿主机物理内存已经被VMM回收，所以会触发page fault缺页错误，并被VMM捕获。VMM按照同样的方法，从其他的guest VM那里回收点内存，放到内存紧缺的这个guest VM的气球里，并让气球收缩以释放内存，之后再重新建立GPA-&gt;HPA的映射就可以了。虽然物理页面被VMM替换了，但对于guest VM来说，它的GPA没有变，所以它根本感觉不到。</li></ul></li><li>意义：让有限的物理内存资源在各个guest VM之间得到充分合理的利用。</li></ul><p>5、<strong>透明页共享技术等</strong> <strong>简介：</strong> 这个虚机有这么多内存页面，都最终落到物理内存上，有可能不同虚机或同一虚机进程的内存页面，里面的数据是一模一样的，一个驱动运行了两次，一个软件运行了两次等。 <strong>原理：</strong> 利用指针指向相同的物理内存页面，就节省了空间，这就叫透明页共享技术。 <strong>意义</strong>：让有限的物理内存资源在各个guest VM之间得到充分合理的利用，利于内存超分。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p><img src="https://b3logfile.com/file/2022/04/solo-fetchupload-11183169216517180844-2d282c7b.png"></p><ul><li>提高性能：VMCS中保存有gCR3和nCR3的值，gCR3可以用于访问客户机页表，nCR3可以用于访问ePT&#x2F;nPT页表，在VM中处于非root模式的CPU可以利用这两个值自动完成GVA-&gt;GPA和GPA-&gt;HPA这两次地址转换。</li><li>减少内存开销：不同于影子页表是一个进程需要一个sPT，EPT&#x2F;NPT MMU解耦了GVA-&gt;GPA转换和GPA-&gt;HPA转换之间的依赖关系，一个VM只需要一个ePT&#x2F;nPT，减少了内存开销。</li><li>减少CPU开销：不同于影子页表中，guest VM中发生了page fault，由VMM截获处理。EPT&#x2F;NPT MMU解耦了GVA-&gt;GPA转换和GPA-&gt;HPA转换之间的依赖关系，如果guest VM中发生了page fault，可直接由guest OS处理，不会产生VM-Exit，减少了CPU的开销。</li><li>提高TLB性能：通过VPID使CPU具备了区分不同的TLB项属于不同VCPU和VMM的能力，避免了在每次VM-Exit和VM-Entry时，使全部TLB失效，提高了VM切换的效率。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h1><ul><li><a href="https://zhuanlan.zhihu.com/p/65298260">虚拟地址转换[一] - 基本流程 - 知乎 (</a><a href="http://zhihu.com/">zhihu.com</a><a href="https://zhuanlan.zhihu.com/p/65298260">)</a></li><li><a href="https://zhuanlan.zhihu.com/p/69828213">虚拟化技术 - 内存虚拟化 [一] - 知乎 (</a><a href="http://zhihu.com/">zhihu.com</a><a href="https://zhuanlan.zhihu.com/p/69828213">)</a></li><li><a href="https://xinsheng.huawei.com/cn/index.php?app=forum&mod=Detail&act=index&id=7715831#">虚拟化技术专题分享四：内存虚拟化 (</a><a href="http://huawei.com/">huawei.com</a><a href="https://xinsheng.huawei.com/cn/index.php?app=forum&mod=Detail&act=index&id=7715831#">)</a></li><li><a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.html">英特尔® 64 位和 IA-32 架构开发人员手册，卷 3C (</a><a href="http://intel.cn/">intel.cn</a><a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.html">)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算_02_虚拟化技术_I/O虚拟化</title>
    <link href="/0009.html"/>
    <url>/0009.html</url>
    
    <content type="html"><![CDATA[<hr><h1 id="1-I-O虚拟化"><a href="#1-I-O虚拟化" class="headerlink" title="1 I&#x2F;O虚拟化"></a><strong>1 I&#x2F;O虚拟化</strong></h1><p>前面我们已经讲过CPU的虚拟化技术，而I&#x2F;O虚拟化，也是虚拟化技术中之分重要的一部分。虚拟化包含CPU、内存、I&#x2F;O设备（网络属于特殊的IO设备）的虚拟化。前面我们也提到了，I&#x2F;O设备虚拟化也分为全虚拟化、半虚拟化以及硬件辅助的虚拟化。</p><h1 id="2-知识回顾"><a href="#2-知识回顾" class="headerlink" title="2 知识回顾"></a><strong>2 知识回顾</strong></h1><p>虚拟化分类早期有两种模型host模型和hypervisor模型，这两种模型的划分其实是来自于早期VMware的ESX和GSX。 <img src="https://b3logfile.com/file/2022/04/image-b0cf5674.png" alt="image.png"> 上述两种虚拟技术类型，其中 Type1 的HyperVisor独立于硬件之上，但是个人理解，HyperVisor不可能脱离OS（Operating System）去独立地进行硬件的操作，Type1中的HyperVisor也包含了一个最简单的OS内核，无非就是这个内核上不能跑其他的应用罢了。因此可以将Type1的HyperVisor理解为 Mini OS+VMM（Virtual Machine Manager），而Type2的HyperVisor可以理解为单独的VMM。但是目前主流的HyperVisor产品之一KVM的出现已经打破了这种简单的划分方式，对虚拟化技术还未有更精确的分类方式出现。</p><h1 id="3-I-O虚拟化分类"><a href="#3-I-O虚拟化分类" class="headerlink" title="3 I&#x2F;O虚拟化分类"></a><strong>3 I&#x2F;O虚拟化分类</strong></h1><p>在详细介绍各个分类之前，我们先考虑一下，在没有虚拟化技术之前，操作系统是怎么对I&#x2F;O请求进行处理的。当某个应用或者进程发出I&#x2F;O请求，会通过系统调用的方式进入内核，调用相应的设备驱动程序，请求到具体的I&#x2F;O设备，最后再将结果返回给进程。 那么存在虚拟机的情况，又怎么让每个虚拟机都有自己的一套宿主机上的I&#x2F;O设备呢？ 常见的I&#x2F;O虚拟化实现方案分为以下三类： <img src="https://b3logfile.com/file/2022/04/image-cd81f207.png" alt="image.png"> 分别是整体模型、服务VM模型、直通模型。 第一种情况是整体模型，它将I&#x2F;O服务和设备驱动都直接装载在HyperVisor的Mini OS上，所有VM的I&#x2F;O请求都会被VMM捕获，然后通过软件模拟的方式，将结果返回给Guest OS。<strong>图中说这种方式拥有较高的性能，据我个人理解，应该是和第二种模型进行比较，因为该种方式是因为所有的I&#x2F;O请求都必须通过VMM层软件进行模拟，上下切换频繁，性能并不一定高。</strong> 但是确定却很明显，Hypervisor会很大，代表产品就是VMWare的ESX和ESXi，另一个缺点就是对新设备的驱动加载不够方便，有时需要升级整个Hypervisor，比如ESXi直到5.0版本才能识别出Qlogic驱动的CNA网卡。如果采用这种方案，一定要先确认好Hypervisor的支持驱动列表再进行安装。 第二种服务VM模型，从图中可以看到，它通过加载一个服务系统（如Domain 0）来减少Hypervisor的负担，所有的产品驱动都安装在服务系统上，这样便于其他外设硬件的管理和增加，同时减小了Hypervisor，越小意味着越安全，降低了故障的风险。缺点是性能相较于第一种，性能不好，因为所有的服务调用都要经过服务系统。典型代表就是Xen和Hyper-V。KVM有些类似，但是不完全一样，因为KVM的Hypervisor和服务系统使用同一个Linux内核，而Xen和Hyper-V使用的各自精简的内核，与服务系统不同，之后会介绍。</p><blockquote><p>提到这里有必要讲一下有些公开资料上提到的I&#x2F;O 全虚拟化、半虚拟化了，我参考的这篇文章作者提到上述两种模型又被称为I&#x2F;O Full-virtualization（全虚拟化）和I&#x2F;O Para-Virtualization（半虚拟化），但是与此同时，我在网上公开中找到的I&#x2F;O全虚拟化、半虚拟化技术的解释完全不同，他们都说I&#x2F;O全虚拟化技术性能不高，半虚拟化技术性能相较于全虚拟化技术有所提高。由于没找到上述图片的出处，倒是在中兴公司的云计算技术PPt中找到了上述三个模型的分类，在IBM的开发社区中也找了类似的说法，到那时IBM中描述的是设备仿真架构，一个是基于Hypervisor的设备仿真（对应于第一种整体模型），一个是用户空间的设备仿真（对应第二种服务VM模型），他们都说的是第二种比第一种安全性稿、性能差，并不像《从半空看虚拟化》文章中提到的，上述两种可以被称之为全虚拟化和半虚拟化。这点我们先留个疑问，后续章节详细介绍一下，这两种分类的区别。</p></blockquote><p>第三种直通模型则是从硬件层面已经将各个设备进行了划分，分配给不同的VM使用，由每个VM自行维护其使用的IO和设备驱动。Hypervisor只提供通道，不再对I&#x2F;O和设备驱动进行管理。这样做的好处是可以达到最高的性能和最小的代码量(Hypervisor），但缺点是设备非完全共享且对VM迁移提出了一定挑战。这种方案只有在对I&#x2F;O操作要求较高的特定场景下使用，不具备普适性。部署时I&#x2F;O设备支持逻辑划分技术如SR IOV( Single RootI&#x2F;o virtualization）等即可，对 Hypervisor没有什么特殊要求，前面说的几款主流产品都提供了此种工作方式。 Intel的VT-d技术作为一种平台结构在硬件层面可以有效的对上面三种方案全部提供支持。其根本目的就是为了多个VM在对虚拟设备进行I&#x2F;O操作时，能够对其DMA和中断处理进行隔离保护与提升性能。</p><h1 id="4-另一种分类方式"><a href="#4-另一种分类方式" class="headerlink" title="4 另一种分类方式"></a><strong>4 另一种分类方式</strong></h1><p>在网上可以查到的公开资料中，大家又将I&#x2F;O虚拟化分为全虚拟化、半虚拟化、I&#x2F;O直通或透传技术三种。这三种技术，最终经过查证，我认为上节中的前两种模型和全虚拟化、半虚拟化联系并不大，全虚拟化、半虚拟化区分角度应该是是否需要修改Guest OS。因为全虚拟化、半虚拟化都是通过软件的方式来进行模拟。下面我们简单介绍一下，这种分类方式。</p><h2 id="4-1-I-O-全虚拟化"><a href="#4-1-I-O-全虚拟化" class="headerlink" title="4.1 I&#x2F;O 全虚拟化"></a><strong>4.1 I&#x2F;O 全虚拟化</strong></h2><p>全虚拟化即不修改Guest OS，通过VMM来实现模拟IO设备。全虚拟化，既可以是上节中的第一种模型，也可以是第二种模型。全虚拟化和半虚拟化可以通过观察是否修改了Guest OS来划分。 在全虚拟化情况下，Guest OS所能看到的就是一组统一的I&#x2F;O设备。下面我们以KVM和Xen的两种IO全虚拟化模型为例介绍全虚拟化，相信大家可以找到I&#x2F;O全虚拟化的共同点。</p><h3 id="4-1-1-KVM-QEMU"><a href="#4-1-1-KVM-QEMU" class="headerlink" title="4.1.1 KVM-QEMU"></a><strong>4.1.1 KVM-QEMU</strong></h3><p>下面以KVM的全虚拟化I&#x2F;O为例 ，KVM 在 IO 虚拟化方面，传统或者默认的方式是使用 QEMU 纯软件的方式来模拟 I&#x2F;O 设备，包括键盘、鼠标、显示器，硬盘 和 网卡 等。模拟设备可能会使用物理的设备，或者使用纯软件来模拟。模拟设备只存在于软件中。 <img src="https://b3logfile.com/file/2022/04/solo-fetchupload-16768431353293598248-974a2811.jpeg" title="KVM I/O全虚拟化"> 过程：</p><ol><li>客户机的设备驱动程序发起 I&#x2F;O 请求操作请求</li><li>KVM 模块中的 I&#x2F;O 操作捕获代码拦截这次 I&#x2F;O 请求</li><li>经过处理后将本次 I&#x2F;O 请求的信息放到 I&#x2F;O 共享页 （sharing page），并通知用户空间的 QEMU 程序。</li><li>QEMU 程序获得 I&#x2F;O 操作的具体信息之后，交由硬件模拟代码来模拟出本次 I&#x2F;O 操作。</li><li>完成之后，QEMU 将结果放回 I&#x2F;O 共享页，并通知 KMV 模块中的 I&#x2F;O 操作捕获代码。</li><li>KVM 模块的捕获代码读取 I&#x2F;O 共享页中的操作结果，并把结果放回客户机。</li></ol><blockquote><p>注意：当客户机通过DMA （Direct Memory Access）访问大块I&#x2F;O时，QEMU 模拟程序将不会把结果放进共享页中，而是通过内存映射的方式将结果直接写到客户机的内存中共，然后通知KVM模块告诉客户机DMA操作已经完成。</p></blockquote><h3 id="4-1-2-Xen"><a href="#4-1-2-Xen" class="headerlink" title="4.1.2 Xen"></a><strong>4.1.2 Xen</strong></h3><p>我们再看一下基于I&#x2F;O全虚拟化的Xen的模型： <img src="https://b3logfile.com/file/2022/04/solo-fetchupload-15904759936678890355-91b0f264.png"> <strong>当虚拟机访问虚拟设备时，访问请求被虚拟机监视器截获，然后监视器程序将 I&#x2F;O 请求交由 domain 0 来模拟完成，最后将结果返回给虚拟机</strong> 。</p><h3 id="4-1-3-I-O-全虚拟化总结"><a href="#4-1-3-I-O-全虚拟化总结" class="headerlink" title="4.1.3 I&#x2F;O 全虚拟化总结"></a><strong>4.1.3 I&#x2F;O 全虚拟化总结</strong></h3><p>可以看出，不论是KVM还是Xen的IO全虚拟化实现，都是修改Hypervisor层的东西，并没有修改Guest OS，都是通过软件模拟设备的方式，因此可移植性与兼容性很好，这也是它被广泛使用的主要原因。但是 I&#x2F;O 全虚拟化有一个很大的不足之处，就是性能较差，主要原因有两方面：</p><ul><li>第一、模拟方式是用软件行为进行模拟，这种方式本身就无法得到很高的性能；</li><li>第二、这种模型下 I&#x2F;O 请求的完成需要虚拟机与监视器程序多次的交互，产生大量的上下文切换，造成巨大开销。</li></ul><p>讲了那么多，可以发现，全虚拟化与第三节中提到的整体模型和服务VM模型都有重合的点。</p><h2 id="4-2-I-O-半虚拟化"><a href="#4-2-I-O-半虚拟化" class="headerlink" title="4.2 I&#x2F;O 半虚拟化"></a><strong>4.2 I&#x2F;O 半虚拟化</strong></h2><p>众多公开资料中都显示，I&#x2F;O半虚拟化是采用前后端驱动的方式来实现，相较于全虚拟化，半虚拟化提高了性能。而其原因为：</p><ol><li>采用 I&#x2F;O 环机制，使得 Guest 端和 Host 端可以共享内存，减少了虚拟机与 VMM 之间的交互；</li><li>采用事件和回调的机制来实现 Guest 与 Host VMM 之间的通信。这样，在进行中断处理时，就可以直接采用事件和回调机制，无需进行上下文切换，减少了开销。</li></ol><p>下面，我们同样也以KVM和Xen两种实现的不同I&#x2F;O半虚拟化作为例子来介绍。</p><h3 id="4-2-1-KVM-QEMU"><a href="#4-2-1-KVM-QEMU" class="headerlink" title="4.2.1 KVM-QEMU"></a><strong>4.2.1 KVM-QEMU</strong></h3><p>先以KVM为例，针对 I&#x2F;O 全虚拟化纯软件模拟性能不高这一点，I&#x2F;O 半虚拟化前进了一步。它提供了一种机制，使得 Guest 端与 Host 端可以建立连接，直接通信，摒弃了VMM截获模拟这种方式，从而获得较高的性能。 <img src="https://b3logfile.com/file/2022/04/image-1401b4a7.png" alt="image.png"> 这种方式类似C&#x2F;S通信的方式，在Guest中添加前端驱动，Host的Qemu中添加后端驱动，前后端通过通向内存的方式传递数据。KVM使用的就是Virtio这个Linux上的设备驱动标准框架来实现。这里提一下，KVM&#x2F;QEMU 的 virtio 实现采用在 Guest OS 内核中安装前端驱动 （Front-end driver）和在 QEMU 中实现后端驱动（Back-end）的方式。前后端驱动通过 vring 直接通信，这就绕过了经过 KVM 内核模块的过程，达到提高 I&#x2F;O 性能的目的。 <img src="https://b3logfile.com/file/2022/04/solo-fetchupload-3564000190077047494-f7a4f21e.jpeg"> 显然这种方式需要修改Guest OS内核，因此是半虚拟化。</p><h3 id="4-2-2-Xen"><a href="#4-2-2-Xen" class="headerlink" title="4.2.2 Xen"></a><strong>4.2.2 Xen</strong></h3><p>下图是Xen的IO半虚拟化模型，可以看到和KVM的基本类似，只是Xen的Domain 0 是作为服务系统，其前后端驱动通过共享内存等方式，优化了性能。 <img src="https://b3logfile.com/file/2022/04/solo-fetchupload-5048239728373337256-cca4a779.png"></p><h3 id="4-2-3-I-O半虚拟化总结"><a href="#4-2-3-I-O半虚拟化总结" class="headerlink" title="4.2.3 I&#x2F;O半虚拟化总结"></a><strong>4.2.3 I&#x2F;O半虚拟化总结</strong></h3><p>通过上述描述，可以看出半虚拟化方式，相较于全虚拟化方式提升了性能，这跟第三节中的前两种模型也是互有交叉，不能把半虚拟化等同于服务VM模型、全虚拟化等同与整体模型，因为半虚拟化性能相较于全虚拟化性能提升，而整体模型性能优于服务VM模型。 对于I&#x2F;O半虚拟化，性能提升是其主要的有点，但是由于它要修改操作系统内核以及驱动程序，因此会存在移植性和适用性方面的问题，导致其使用受限。</p><h2 id="4-3-I-O直通或透传技术"><a href="#4-3-I-O直通或透传技术" class="headerlink" title="4.3 I&#x2F;O直通或透传技术"></a><strong>4.3 I&#x2F;O直通或透传技术</strong></h2><p>也有的称为硬件辅助虚拟化。 上面两种虚拟化方式，还是从软件层面上来实现，性能自然不会太高。最好的提高性能的方式还是从硬件上来解决。如果让虚拟机独占一个物理设备，像宿主机一样使用物理设备，那无疑性能是最好的。I&#x2F;O 直通技术就是提出来完成这样一件事的。它通过硬件的辅助可以让虚拟机直接访问物理设备，而不需要通过 VMM 或被 VMM 所截获。 X86主要设备厂商Intel和 AMD 都在其较新的处理器架构中提供对I&#x2F;O直通的支持（除了辅助虚拟机管理程序的新指令之外）。Intel 将其称为_Technology for Directed I&#x2F;O_ (VT-d) , 而 AMD 则将其称为 <em>I&#x2F;O Memory Management Unit_（IOMMU）。不论是哪一种，新的 CPU 都提供了将 PCI 物理地址映射到Guest 虚拟地址的方法。发生此映射时，硬件负责访问（和保护），并且客户机操作系统可以使用设备，就好像它是非虚拟化系统一样。除了将Guest映射到物理内存之外，还提供了隔离，以便阻止其他Guest（或虚拟机管理程序）访问它。 在IBM开发者中心提到，有一种技术叫做_Message Signaled Interrupts</em> (MSI)，可以用于中断大量虚拟机，将中断更容易虚拟化，并且允许隔离中断源，IBM甚至称这是I&#x2F;O虚拟化的理想选择，感兴趣的同学可以在文末参考文献中找到。 <img src="https://b3logfile.com/file/2022/04/solo-fetchupload-11460338417772294778-5c682eba.webp"> 可以看到I&#x2F;O直通技术可以让当虚拟机独占物理设备，这样虽然性能提升了，但是一个设备只能被一个虚拟器使用，降低了设备使用率。为了实现一个物理设备能被多个虚拟机共享，学术界和工业界都为此作了大量的改进，于是PCI-SIG 发布了 SR-IOV (Single Root I&#x2F;O Virtualizmion) 规范，其中详细阐述了硬件供应商在多个虚拟机中如何共享单个 I&#x2F;O 设备硬件。这里也不详细介绍SR-IOV了，有机会再去深究。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h1><ul><li>《从半空看虚拟化》</li><li><a href="https://www.jianshu.com/p/7a656326c439">I&#x2F;O 虚拟化的三种形式 - 简书 (</a><a href="http://jianshu.com/">jianshu.com</a><a href="https://www.jianshu.com/p/7a656326c439">)</a></li><li><a href="https://zhuanlan.zhihu.com/p/72491679">Linux云计算底层技术之 I&#x2F;O 虚拟化的三种形式 - 知乎 (</a><a href="http://zhihu.com/">zhihu.com</a><a href="https://zhuanlan.zhihu.com/p/72491679">)</a></li><li><a href="https://slidesplayer.com/slide/14035570/">虚拟化技术. - ppt download (</a><a href="http://slidesplayer.com/">slidesplayer.com</a><a href="https://slidesplayer.com/slide/14035570/">)</a></li><li><a href="https://developer.ibm.com/tutorials/l-pci-passthrough/">Linux virtualization and PCI passthrough - IBM Developer</a></li><li><a href="https://www.jianshu.com/p/fc40104eba23">浅谈网络I&#x2F;O全虚拟化、半虚拟化和I&#x2F;O透传 - 简书 (</a><a href="http://jianshu.com/">jianshu.com</a><a href="https://www.jianshu.com/p/fc40104eba23">)</a></li><li><a href="https://www.cnblogs.com/dion-90/articles/8522718.html">KVM 介绍（3）：I&#x2F;O 全虚拟化和准虚拟化 - dion至君 - 博客园 (</a><a href="http://cnblogs.com/">cnblogs.com</a><a href="https://www.cnblogs.com/dion-90/articles/8522718.html">)</a></li><li><a href="https://blog.csdn.net/lkn910907/article/details/41866109">(49条消息) IO虚拟化及虚拟化模型_暗夜公爵LKN的博客-CSDN博客_io虚拟化</a></li><li>胡冷非, 李小勇. 基于 Xen 的 I&#x2F;O 准虚拟化驱动研究[J]. 计算机工程, 2009, 35(23): 258-259.</li><li><a href="https://zhuanlan.zhihu.com/p/337213808">Linux 下检查 VT-d &#x2F; IOMMU 是否开启 - 知乎 (</a><a href="http://zhihu.com/">zhihu.com</a><a href="https://zhuanlan.zhihu.com/p/337213808">)</a></li><li><a href="https://blog.51cto.com/gzsamlee/1876890">虚拟化技术之虚拟化技术介绍及Xen的应用实现_Opensamlee的技术博客_51CTO博客</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>I/O虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算_01_虚拟化技术_CPU虚拟化</title>
    <link href="/0008.html"/>
    <url>/0008.html</url>
    
    <content type="html"><![CDATA[<h1 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a><strong>CPU虚拟化</strong></h1><p>目前大多数人都将虚拟化分为<strong>全虚拟化</strong>、<strong>半虚拟化</strong>、<strong>硬件辅助虚拟化</strong>。但是对划分的原因，也不太了解。因此本文主要是讨论一下关于虚拟化的分类以及原因。</p><h2 id="虚拟化分类原因"><a href="#虚拟化分类原因" class="headerlink" title="虚拟化分类原因"></a><strong>虚拟化分类原因</strong></h2><p>我们都知道，cpu指令系统分为特权指令和非特权指令。以X86系统为例，共分为Ring0-Ring3 4个级别。其中Ring0 处于内核级别，拥有最高权限，Ring1-Ring3运行在用户级别，虽然CPU指令级别这样划分，但是操作系统不一定用完所有的指令级别，例如Linux只使用了Ring0 和 Ring3两个级别，分别在内核态和用户态运行。</p><ol><li>为什么需要CPU虚拟化？<ul><li>没有虚拟化：操作系统处于最高的特权级，可直接访问所有物理资源（寄存器、内存、I&#x2F;O外设等）。</li><li>虚拟化：操作系统变为客户机操作系统（虚拟机操作系统）而降级到非最高特权级，这时，其试图访问关键资源的指令就成为了敏感指令。VMM 会通过各种手段，保证这些敏感指令的执行能够触发异常，从而陷入到VMM进行模拟，VMM将客户机操作系统的访问定位到VMM为其设计的虚拟的资源上以防止对VMM自身的运行造成破坏。</li></ul></li><li>CPU虚拟化要做什么？<ul><li>CPU虚拟化的重点：由VMM和（物理）CPU共同完成敏感指令的模拟。</li><li>对于虚拟机执行的非敏感指令，物理CPU直接解码处理，并将相关的效果直接反映到物理寄存器上；对于虚拟机执行的敏感指令，让虚拟机里执行的敏感指令陷入然后被VMM模拟，而不要直接作用于真实硬件上。</li></ul></li></ol><p>在非x86系统中经典的虚拟化做法，就是令VMM拥有超级特权，其指令都想运行在Ring0级别；令Guest OS运行在Ring1-Ring3级别，当其运行特权指令时，这些指令会产生异常并被VMM捕获到，VMM会在核心级别中模拟执行，再将运行结果返回给Guest OS。这种经典的虚拟化技术被称为<strong>特权解除和陷入模拟</strong>，以IBM的Power系列为代表。 其次，我们将操作系统会涉及底层公共资源调用的一些运行指令称为<strong>敏感指令</strong>。显然这些敏感指令在虚拟化的结构中也需要陷入到Ring0的核心级别执行，否则会导致不同GuestOS之间的资源调用冲突。大型服务器如PowerPC和SPARC运行的RISC指令集中,所有的敏感指令都属于特权指令，因此可以采用上面说的特权解除和陷入模拟技术完美的进行虚拟化实现。 <strong>但对于X86的CISC指令集而言,存在17条非特权指令的敏感指令，这些指令被GuestOS在Ring1级别执行时，会被直接执行，无法产生异常从而陷入Ring0处理，也就导致无法采用经典技术进行虚拟化，</strong> 因此下文将介绍的一系列方案都是为了解决此问题而设计的。 <img src="https://b3logfile.com/file/2022/04/image-f3a45c0d.png" alt="image.png"> 在上述问题中,涉及到三个主要对象，GuestOS、VMM和硬件CPU的指令集,其中VMM是新插入的对象，修改起来很方便，但OS和CPU改起来就难一-些了。解决方案的思路也由此分为三个方向:</p><ol><li>只变动VMM。好处是兼容性最强，OS和CPU都不用动，但效率肯定是最低的。这种方案也被称为CPU Full-Virtualization，全虚拟化。</li><li>改动GuestOS。好处是效率较高,但缺点是Windows肯定不愿意干，只能在Linux上做些文章，而且使用特制的OS，会带来一些可扩展性方面的隐患。这种方案也被称为CPU Para-Virtualization ，半虚拟化。</li><li>改动CPU指令集。这个改动就只有Intel&#x2F;AMD能做了，好处是对Guest OS可以不需变动，兼容Linux和Windows，VMM的使用效率也较高。缺点也有，就是增加了一些虚拟化指令和结构，导致对CPU的利用率下降，在部分应用场景下的性能表现不如前面的CPUPara-Virtualization方案。这种方案也被称为硬件辅助虚拟化技术HVM ( Hardware-assisted Virtualization Machine)。随着Intel&#x2F;AMD的服务器CPU全部更新换代对其提供支持,HVM已经成为当前虚拟化技术应用的主流，硬件辅助虚拟化。</li></ol><p>于是就出现了三个虚拟化种类，分别是全虚拟化（改动VMM）、半虚拟化（改动Guest OS）、硬件辅助虚拟化（改动CPU指令集）</p><h1 id="CPU全虚拟化"><a href="#CPU全虚拟化" class="headerlink" title="CPU全虚拟化"></a><strong>CPU全虚拟化</strong></h1><p>CPU Full-Virtualization（CPU FV），这种思路又被细分为三种解决方案。Emulation、Scan-and-Patch和 Binary Translation。其中Emulation是根本解决方案，而Scan-and-Patch和 Binary Translation可以理解为是Emulation在X86体系上使用的扩展实现方案。CPU Full-Virtualization由于实现较为简单，早在上世纪末就已经出现，是最早期的x86虚拟化技术。</p><ol><li>Emulation：主要应用在跨平台进行虚拟机模拟。由于Guest OS和底层系统平台不同，尤其是指令集的不同，比如你需要在X86系统上模拟ARM的系统，那么VMM所做的工作就是实现将Guest OS的指令读取后进行模拟，模拟出结果后，再返回，逐条执行不区分用户指令和敏感指令，由于每条命令都陷入到Ring 0级别中，所以也就解决了之前的敏感指令的问题。代表产品就是Linux上的QEMU和Bochs，其中QEMU还可以通过KQEMU来提升处理速度。</li><li>Scan-and-Patch：主要思路是将Guest OS的指令提前扫描一遍，找到其中的敏感指令，然后在VMM层中生成对应的补丁指令，同时将敏感指令修改为跳转指令，指向补丁指令。这样当执行到敏感指令时，会跳转到VMM中的补丁指令执行，在将结果返回给Guest OS。代表产品是Oracle的开源虚拟机系统VirtualBox，目前主要应用于在主机上进行虚拟机的模拟，服务器使用较少。</li><li>Binary Translation，二进制转换，主要思路是将Guest OS的指令段进行整段翻译，将其中敏感指令替换成Ring 0中的对应特权指令，然后在执行的同时翻译下一个指令段。代表产品VMWare WorkStation、Microsoft virtual PC主机虚拟化工具，以及早期VMWare的 ESX&#x2F;GSX系列服务器虚拟化系统，目前服务器上很少使用。</li></ol><p>由于CPU FV受性能影响，在服务器上目前被逐渐淘汰。主要代表产品VirtualBox和VMware WorkStation大都应用于主机虚拟化的一些开发测试环境中。</p><h1 id="CPU半虚拟化"><a href="#CPU半虚拟化" class="headerlink" title="CPU半虚拟化"></a><strong>CPU半虚拟化</strong></h1><p>CPU Para-Virtualization称为半虚拟化。此技术以Hyper-V和Xen作为代表，但VMware的ESX Server和Linux的KVM两种主流的虚拟化产品也都支持Para-Virtualization，另外还有基于Linux的Lguest和基于Windows的CoLinux等各具特色的小型产品也都通过部分Para-Virtualization技术来实现操作系统的虚拟化。CPU Para-virtualization以下简称CPU PV。 CPU PV技术实现的主要原理如下，首先VMM公布其一些称为 Hypercalls的接口函数出来，然后在 Guest OS中增加根据这些接口函数修改内核中的代码以替代有问题的17条敏感指令执行系统调用操作。修改后的指令调用通常被称为 Hypercalls，Guest OS可以通过 Hypercalls 直接调用VMM进行系统指令执行，相比较前面提到的陷入模拟方式极大的提升了处理效率。 然而CPU PV修改操作系统内核代码的方式带来了对Guest OS的很多使用限制，如只有Hyper-v可以支持 Para-Virtualization方式的Windows Server作为Guest Os，另外由于KVM&#x2F;Xen&#x2F;VMware vMI&#x2F;Hyper-V各自Hypercalls代码进入Linux内核版本不同，因此采用Linux作为Guest OS时也必须关注各个发行版的Linux内核版本情况。KVM是2.6.20,VMI是2.6.22，Xen是2.6.23，Hyper-V是2.6.32。 由于CPU PV方式对Guest OS的限制，应用范围不是很广，但是由于其技术上的系统调用效率提升，仍然被部分开发与使用者所看好，在某些特定场景也有一定存在需求。</p><h1 id="CPU硬件辅助虚拟化-HVM"><a href="#CPU硬件辅助虚拟化-HVM" class="headerlink" title="CPU硬件辅助虚拟化 HVM"></a><strong>CPU硬件辅助虚拟化 HVM</strong></h1><p>硬件辅助虚拟化就是从硬件出发，修改CPU指令集来解决敏感指令的问题。当前的X86厂商主要是Intel和AMD两家，这两家都提出了自己的CPU虚拟化技术，Intel推出的技术是在Xeon CPU上的 VT-x，和Itanium CPU上的 VT-i，AMD提出的是AMD-V。下面以VT-x为例介绍HVM技术，其他的两种类似。 VT-x在CPU操作方面有两个主要特性：</p><ol><li>是增加了VMCS (Virtual-Machine ControlStructure)数据结构和13条专门针对vM的处理指令,用于提升VM切换时的处理效率。</li><li>通过引入Root&#x2F;Non-Root操作模式解决前面遇到的Guest OS敏感指令无法陷入问题。</li></ol><p>13条新指令中包括5条用于VMCS维护, 4条用于VMX管理,2条用于VMX对TLB(TranslationLook aside Buffer）的管理，2条用于Guest OS调用。 Root&#x2F;Non-Root 操作模式将原有的CPU操作区分为VMM所在的Root操作与VM的Non-Root操作,每个操作都拥有Ring0-Ring3的所有级别。通过VMCS数据结构指向Guest OS到VMM的操作切换。 <img src="https://b3logfile.com/file/2022/04/image-88ec361d.png" alt="image.png"> VMM在初始化的时候会在物理内存中为每个VM开辟一段空间用于存储对应的一个VMCS数据结构，可以理解一个VMCS就对应一个vCPU。VM切换时，VMM可以通过VMCS 指针方便的在不同VMCS间进行跳转，有效的提升了CPU使用效率。 VT-x技术还包含以下三个重要内容:</p><ol><li>**EPT (Extended Page Table)**： 由VMM控制的一种新页表结构，主要目的为了在保证多个VM访问物理内存相互隔离的同时,提升大块内存的读写效率。</li><li><strong>FlexMigration</strong>：灵活迁移技术，用于VM在使用不同型号CPU的物理服务器间进行迁移，促成了类似vMotion的vM迁移技术的发展。</li><li><strong>FlexPriority</strong> ：灵活优先级技术，用于优化 CPU中断处理过程中对TPR(Task-Priority Register）的使用，提高中断处理效率。</li></ol><p>VT-x和AMD-v等技术的出现，解决了前面两种纯软件方案进行X86虚拟化时，CPuFull-Virtualization性能低和Para-Virtualization的Guest OS兼容性差问题.随着服务器CPU两三年一换代的更新速度,当前的主流x86服务器已经都可以支持VT-x&#x2F;AMD-v等技术，因此HVM成为当前云计算 laaS服务器虚拟化的主流。主要的几款vMM产品Xen&#x2F;VMware ESXi&#x2F;KVM&#x2F;Hyper-V都已经能够支持HVM功能。</p><h1 id="CPU虚拟化总结"><a href="#CPU虚拟化总结" class="headerlink" title="CPU虚拟化总结"></a><strong>CPU虚拟化总结</strong></h1><p>虚拟化分类，个人理解是从CPU虚拟化角度来分类较为恰当，虽然从I&#x2F;O设备虚拟化的角度来说，也有所谓的I&#x2F;O FV、I&#x2F;O PV，但是个人觉得从CPU角度来区分全虚拟化、半虚拟化、硬件辅助虚拟化较为恰当。接下来会继续介绍虚拟化技术02_I&#x2F;O虚拟化。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h1><blockquote><p>感谢以下作者的分享，文章大部分内容来自以下参考文献。</p></blockquote><ul><li><a href="https://www.doc88.com/p-6951962040261.html">从半空看虚拟化 - 道客巴巴 (</a><a href="http://doc88.com/">doc88.com</a><a href="https://www.doc88.com/p-6951962040261.html">)</a></li><li><a href="https://xinsheng.huawei.com/cn/index.php?app=forum&mod=Detail&act=index&id=7715651">虚拟化技术专题分享二：CPU虚拟化 (</a><a href="http://huawei.com/">huawei.com</a><a href="https://xinsheng.huawei.com/cn/index.php?app=forum&mod=Detail&act=index&id=7715651">)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
